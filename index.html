
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Signal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        /* Slightly smaller base size so more content fits on screen */
        :root { font-size: 14px; }

        .bg-gray-950 { background-color: #0d1117; }
        .bg-gray-850 { background-color: #1a1f26; }

     .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Tab Styles */
        .tab-content {
            display: block;
        }
        .tab-content.hidden {
            display: none;
        }
        .tab-btn.active {
            color: #60a5fa;
            border-bottom-color: #3b82f6;
        }
        .tab-btn:hover {
            color: #60a5fa;
        }

        .primary-btn {
            background-image: linear-gradient(to right, #3b82f6, #2563eb);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px 0 rgba(59, 130, 246, 0.4);
        }
        .primary-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 15px 0 rgba(59, 130, 246, 0.4);
        }

        #finalScoreCard {
            border: 2px solid transparent;
            background-clip: padding-box, border-box;
            background-origin: padding-box, border-box;
            background-image: linear-gradient(to bottom right, #1f2937, #111827);
            border-image: linear-gradient(to bottom right, #3b82f6, #0a4d96) 1;
            box-shadow: 0 10px 25px -5px rgba(59, 130, 246, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 50;
        }
        
        /* Print styles - Professional light theme for PDF */
        @media print {
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            body {
                background: #ffffff !important;
                color: #111827 !important;
                font-size: 10px !important;
                line-height: 1.3 !important;
            }
            
            /* Reduce overall spacing */
            * {
                margin-top: 0 !important;
                margin-bottom: 0 !important;
            }
            
            /* Main containers */
            .bg-gray-700,
            .bg-gray-800,
            .bg-gray-900,
            .bg-gray-950,
            .bg-gray-850 {
                background: #ffffff !important;
                border: 1px solid #e5e7eb !important;
                border-radius: 8px !important;
                box-shadow: none !important;
            }
            
            /* Text colors */
            .text-white {
                color: #111827 !important;
                font-weight: 600 !important;
            }
            
            .text-gray-100,
            .text-gray-200,
            .text-gray-300 {
                color: #111827 !important;
            }
            
            .text-gray-400 {
                color: #6b7280 !important;
            }
            
            .text-gray-500 {
                color: #4b5563 !important;
            }
            
            /* Blue (Bullish) */
            .text-blue-400,
            .text-blue-500 {
                color: #1e40af !important;
                font-weight: 600 !important;
            }
            
            .bg-blue-600,
            .bg-blue-500 {
                background: #dbeafe !important;
                color: #1e40af !important;
                font-weight: 600 !important;
                border: 1px solid #93c5fd !important;
            }
            
            .bg-blue-900\/20,
            .bg-blue-900\/30 {
                background: #eff6ff !important;
                border: 1px solid #bfdbfe !important;
            }
            
            .border-blue-500,
            .border-blue-700 {
                border-color: #3b82f6 !important;
            }
            
            /* Green (Positive) */
            .text-green-400,
            .text-green-500 {
                color: #047857 !important;
                font-weight: 600 !important;
            }
            
            .bg-green-600,
            .bg-green-500 {
                background: #d1fae5 !important;
                color: #047857 !important;
                font-weight: 600 !important;
                border: 1px solid #6ee7b7 !important;
            }
            
            .bg-green-900\/20,
            .bg-green-900\/30 {
                background: #ecfdf5 !important;
                border: 1px solid #a7f3d0 !important;
            }
            
            .border-green-500,
            .border-green-700 {
                border-color: #10b981 !important;
            }
            
            /* Red (Bearish) */
            .text-red-400,
            .text-red-500 {
                color: #dc2626 !important;
                font-weight: 600 !important;
            }
            
            .bg-red-600,
            .bg-red-500 {
                background: #fee2e2 !important;
                color: #dc2626 !important;
                font-weight: 600 !important;
                border: 1px solid #fca5a5 !important;
            }
            
            .bg-red-900\/20,
            .bg-red-900\/30 {
                background: #fef2f2 !important;
                border: 1px solid #fecaca !important;
            }
            
            .border-red-500,
            .border-red-700 {
                border-color: #ef4444 !important;
            }
            
            /* Yellow/Orange (Warning) */
            .text-yellow-400,
            .text-yellow-500,
            .text-orange-400,
            .text-orange-500 {
                color: #d97706 !important;
                font-weight: 600 !important;
            }
            
            .bg-yellow-900\/20,
            .bg-yellow-900\/30,
            .bg-orange-900\/20,
            .bg-orange-900\/30 {
                background: #fffbeb !important;
                border: 1px solid #fde68a !important;
            }
            
            .border-yellow-500,
            .border-yellow-700,
            .border-orange-500,
            .border-orange-700 {
                border-color: #f59e0b !important;
            }
            
            /* Borders */
            .border-gray-700,
            .border-gray-600,
            .border-gray-800 {
                border-color: #d1d5db !important;
            }
            
            /* Cards and sections */
            .rounded-xl,
            .rounded-lg {
                border-radius: 8px !important;
            }
            
            /* Tables */
            table {
                border-collapse: collapse !important;
                width: 100% !important;
            }
            
            th {
                background: #f9fafb !important;
                color: #111827 !important;
                font-weight: 600 !important;
                border: 1px solid #e5e7eb !important;
                padding: 8px !important;
            }
            
            td {
                border: 1px solid #e5e7eb !important;
                padding: 8px !important;
                color: #374151 !important;
            }
            
            /* Hide elements */
            canvas {
                display: none !important;
            }
            
            button,
            .primary-btn {
                display: none !important;
            }
            
            /* Hide input section to save space */
            .input-section,
            main > div:first-child,
            main > div:has(#tickerInput),
            main > div:has(input#tickerInput) {
                display: none !important;
            }
            
            /* Hide nav bar */
            nav {
                display: none !important;
            }
            
            /* Hide footer */
            footer {
                display: none !important;
            }
            
            /* Images - Scale down for better fit */
            img {
                max-width: 100% !important;
                height: auto !important;
                display: block !important;
                max-height: 180px !important;
            }
            
            /* Chart images - make smaller */
            img[id*="Chart"],
            img[id*="Chart_img"],
            img[id*="priceChart"],
            img[id*="scoreTimeSeriesChart"],
            img[id*="monthlyMacdChart"],
            img[id*="dailyMacdChart"] {
                max-height: 140px !important;
            }
            
            /* Final Score Card special styling */
            #finalScoreCard {
                background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%) !important;
                border: 2px solid #3b82f6 !important;
                box-shadow: none !important;
                padding: 6px !important;
            }
            
            /* Remove shadows and effects */
            .shadow-xl,
            .shadow-2xl,
            .shadow-lg {
                box-shadow: none !important;
            }
            
            /* Typography - reduce sizes for compact layout */
            h1 {
                font-size: 14px !important;
                margin-bottom: 2px !important;
            }
            
            h2 {
                font-size: 12px !important;
                margin-bottom: 2px !important;
            }
            
            h3 {
                font-size: 11px !important;
                margin-bottom: 2px !important;
            }
            
            h4 {
                font-size: 10px !important;
                margin-bottom: 1px !important;
            }
            
            p, span, div, label {
                font-size: 9px !important;
                line-height: 1.2 !important;
            }
            
            /* Reduce padding and margins */
            .p-4,
            .p-6 {
                padding: 6px !important;
            }
            
            .mb-2 {
                margin-bottom: 3px !important;
            }
            
            .mb-4 {
                margin-bottom: 5px !important;
            }
            
            .mb-6 {
                margin-bottom: 6px !important;
            }
            
            .mb-8,
            .mb-10 {
                margin-bottom: 8px !important;
            }
            
            .mt-2 {
                margin-top: 3px !important;
            }
            
            .mt-4 {
                margin-top: 5px !important;
            }
            
            /* Grid gaps - reduce spacing */
            .gap-4 {
                gap: 4px !important;
            }
            
            .gap-6 {
                gap: 6px !important;
            }
            
            /* Tables - compact */
            table {
                font-size: 8px !important;
            }
            
            th, td {
                padding: 3px 4px !important;
            }
            
            /* Page break controls */
            .grid,
            .bg-gray-800,
            .bg-gray-900,
            .rounded-xl {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            
            /* Keep cards together */
            .grid > div,
            [class*="grid-cols"] > div {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            
            /* Keep chart containers together */
            canvas + img,
            [id*="Chart"] {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            
            /* Prevent breaking inside tables */
            table {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            
            tr {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            
            /* Keep final score card together */
            #finalScoreCard {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            
            /* Allow breaks between major sections */
            .mb-8,
            .mb-10 {
                page-break-after: auto !important;
            }
            
            /* Prevent orphans and widows */
            p, div, span {
                orphans: 2 !important;
                widows: 2 !important;
            }
            
            /* Compact borders */
            .border {
                border-width: 1px !important;
            }
            
            .rounded-xl,
            .rounded-lg {
                border-radius: 4px !important;
            }
            
            /* Page settings - Continuous landscape format (no page breaks) */
            @page {
                margin: 0.5cm;
                /* Continuous format: Very tall page to avoid page breaks */
                /* Width: 297mm (A4 landscape width), Height: 10000mm (very tall for continuous) */
                size: 297mm 10000mm;
            }
            
            /* Remove page breaks for continuous format */
            * {
                page-break-before: avoid !important;
                page-break-after: avoid !important;
            }
            
            /* Allow natural flow - remove forced page-break-inside rules */
            .grid > div,
            [class*="grid-cols"] > div,
            canvas + img,
            [id*="Chart"],
            table,
            tr,
            #finalScoreCard,
            .grid,
            .bg-gray-800,
            .bg-gray-900,
            .rounded-xl {
                page-break-inside: auto !important;
                break-inside: auto !important;
            }
        }
    </style>
</head>
<body class="bg-gray-700">
    <div class="sticky-header">
        <nav class="bg-gray-800 border-b border-blue-700/50 p-4 shadow-xl">
            <div class="max-w-7xl mx-auto flex justify-between items-center">
                <h1 class="text-2xl font-extrabold text-blue-400"><i class="fas fa-microchip mr-2 text-blue-500"></i>QUANTUM Signal</h1>
                <div class="text-xs text-gray-400">Mark Pittman 2025 | Algorithmic Trading</div>
            </div>
        </nav>

        <!-- Tab Navigation -->
        <div class="bg-gray-800 border-b border-gray-700/50">
            <div class="max-w-7xl mx-auto px-4 md:px-10">
                <div class="flex space-x-1">
                    <button onclick="switchTab('quantum')" id="tab-quantum" class="tab-btn active px-6 py-3 text-sm font-semibold text-blue-400 border-b-2 border-blue-500 bg-gray-800 transition-colors">
                        <i class="fas fa-microchip mr-2"></i>Quantum Signal
                    </button>
                    <button onclick="switchTab('macro')" id="tab-macro" class="tab-btn px-6 py-3 text-sm font-semibold text-gray-400 hover:text-blue-400 border-b-2 border-transparent hover:border-blue-500/50 transition-colors">
                        <i class="fas fa-chart-line mr-2"></i>Macro
                    </button>
                    <button onclick="switchTab('interest')" id="tab-interest" class="tab-btn px-6 py-3 text-sm font-semibold text-gray-400 hover:text-blue-400 border-b-2 border-transparent hover:border-blue-500/50 transition-colors">
                        <i class="fas fa-percent mr-2"></i>Interest Rates
                    </button>
                    <button onclick="switchTab('taa')" id="tab-taa" class="tab-btn px-6 py-3 text-sm font-semibold text-gray-400 hover:text-blue-400 border-b-2 border-transparent hover:border-blue-500/50 transition-colors">
                        <i class="fas fa-chart-pie mr-2"></i>TAA
                    </button>
                    <button onclick="switchTab('fiscal')" id="tab-fiscal" class="tab-btn px-6 py-3 text-sm font-semibold text-gray-400 hover:text-blue-400 border-b-2 border-transparent hover:border-blue-500/50 transition-colors">
                        <i class="fas fa-file-invoice-dollar mr-2"></i>Debt & Fiscal
                    </button>
                    <button onclick="switchTab('employment')" id="tab-employment" class="tab-btn px-6 py-3 text-sm font-semibold text-gray-400 hover:text-blue-400 border-b-2 border-transparent hover:border-blue-500/50 transition-colors">
                        <i class="fas fa-users-cog mr-2"></i>Employment
                    </button>
                    <button onclick="switchTab('ai-insights')" id="tab-ai-insights" class="tab-btn px-6 py-3 text-sm font-semibold text-gray-400 hover:text-blue-400 border-b-2 border-transparent hover:border-blue-500/50 transition-colors">
                        <i class="fas fa-robot mr-2"></i>AI Insights
                    </button>
                    <button onclick="switchTab('warsh-powell')" id="tab-warsh-powell" class="tab-btn px-6 py-3 text-sm font-semibold text-gray-400 hover:text-blue-400 border-b-2 border-transparent hover:border-blue-500/50 transition-colors">
                        <i class="fas fa-balance-scale mr-2"></i>Warsh v Powell
                    </button>
                </div>
            </div>
        </div>
    </div>

    <main class="max-w-7xl mx-auto p-4 md:p-10">
        
        <!-- Quantum Signal Tab -->
        <div id="tab-content-quantum" class="tab-content">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-10 border border-gray-700/50">
            <h2 class="text-xl font-semibold mb-4 text-white">Enter Ticker to Analyze</h2>
            <div class="grid grid-cols-1 md:grid-cols-12 gap-4 items-end">
                <div class="md:col-span-2">
                    <label class="block text-xs uppercase tracking-wider text-gray-400 mb-1">Stock Ticker (e.g., AAPL)</label>
                    <input type="text" id="tickerInput" value="AAPL" class="w-full bg-gray-900 border border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition h-[48px]" placeholder="e.g. AAPL">
                </div>
                <div class="md:col-span-2">
                    <label class="block text-xs uppercase tracking-wider text-gray-400 mb-1">Forecast Horizon</label>
                    <div class="bg-gray-900 border border-gray-600 rounded-lg p-1 grid grid-cols-2 gap-1 h-[48px]">
                        <button type="button" class="lookahead-btn text-xs text-gray-300 bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded px-1.5 py-0.5 transition-colors flex items-center justify-center" data-value="10" style="font-size: 0.65rem;">10 Days</button>
                        <button type="button" class="lookahead-btn text-xs text-white bg-blue-600 hover:bg-blue-700 border border-blue-500 rounded px-1.5 py-0.5 transition-colors active flex items-center justify-center" data-value="30" style="font-size: 0.65rem;">30 Days</button>
                        <button type="button" class="lookahead-btn text-xs text-gray-300 bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded px-1.5 py-0.5 transition-colors flex items-center justify-center" data-value="60" style="font-size: 0.65rem;">60 Days</button>
                        <button type="button" class="lookahead-btn text-xs text-gray-300 bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded px-1.5 py-0.5 transition-colors flex items-center justify-center" data-value="90" style="font-size: 0.65rem;">90 Days</button>
                    </div>
                </div>
                <div class="md:col-span-3">
                    <label class="block text-xs uppercase tracking-wider text-gray-400 mb-1">Model Selection</label>
                    <select id="modelSelection" class="w-full bg-gray-900 border border-gray-600 rounded-lg p-3 h-[48px] text-xs text-gray-300 focus:ring-blue-500 focus:border-blue-500">
                        <option value="ridge">Ridge Regression (Fast)</option>
                        <option value="elasticnet">Elastic Net (Balanced)</option>
                        <option value="gradientboosting">Gradient Boosting (Slow)</option>
                        <option value="regimeswitching">Regime-Switching Ensemble (Adaptive)</option>
                    </select>
                </div>
                <div class="md:col-span-3">
                    <label class="block text-xs uppercase tracking-wider text-gray-400 mb-1">Weighting Method</label>
                    <div class="flex items-center bg-gray-900 border border-gray-600 rounded-lg p-3 h-[48px]">
                        <input type="checkbox" id="useEqualCategoryWeighting" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                        <label for="useEqualCategoryWeighting" class="ml-2 text-xs text-gray-300">
                            <span class="text-yellow-400">Equal Category Weighting</span> Forces equal Mo/Trend/Reversal Weights                       </label>
                    </div>
                </div>
                <div class="md:col-span-2">
                    <div class="flex gap-2">
                        <button onclick="calculateSignal()" class="primary-btn flex-1 text-white font-bold py-3 px-4 rounded-lg transition transform hover:scale-[1.01]">
                            <i class="fas fa-calculator mr-2"></i> Calculate Signal
                        </button>
                    </div>
                </div>
            </div>
            <p class="text-xs text-gray-400 mt-3"><i class="fas fa-shield-alt mr-1"></i> Data powered by TwelveData API</p>
            <p id="errorMsg" class="text-red-400 text-sm mt-3 hidden bg-red-900/20 p-2 rounded-lg border border-red-800"></p>
        </div>

        <div id="resultsArea" class="hidden">

            <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">

                <div id="finalScoreCard" class="rounded-xl p-6 shadow-xl fade-in md:col-span-2"> <h3 class="text-blue-400 text-sm uppercase tracking-widest mb-2 font-semibold">Composite Signal Score</h3>

                    <div class="flex flex-col mb-2"> <div class="text-white text-3xl font-extrabold" id="tickerCompanyNameDisplay">---</div>
                        <div class="text-gray-400 text-base font-semibold mt-1">
                            <span class="mr-2">Current Price:</span>
                            <span id="currentPriceDisplay" class="text-white font-black text-lg">$0.00</span>
                        </div>
                    </div>

                    <hr class="border-gray-700/50 mb-4">

                    <div class="flex items-center justify-between mb-4"> <div>
                            <span id="finalScoreDisplay" class="text-4xl font-extrabold text-white transition-colors">0%</span>
                            <div class="mt-2">
                                <span class="text-gray-400 text-sm font-semibold">Probability Higher: </span>
                                <span id="probabilityHigherDisplay" class="text-lg font-extrabold text-blue-400 transition-colors">50%</span>
                            </div>
                        </div>
                        <div id="signalTextDisplay" class="text-lg font-extrabold px-3 py-1 rounded-full shadow-lg text-yellow-400 bg-yellow-900/30 border border-yellow-700 transition-colors">NEUTRAL</div> </div>

                    <div id="historicalStatsDisplay" class="grid grid-cols-3 gap-y-1 gap-x-4 text-xs font-mono text-gray-400 border-b border-gray-700/50 pb-2 mb-2">
                        </div>
                    <div id="validationMetricsDisplay" class="grid grid-cols-3 gap-y-1 gap-x-4 text-xs font-mono text-gray-400 border-b border-gray-700/50 pb-2 mb-2 mt-2">
                        </div>
                    <div class="mt-2 pt-2 border-t border-gray-700/50">
                        <h4 class="text-xs uppercase tracking-wider text-gray-400 mb-1">Score Trend (Last 100 Days)</h4>
                        <div class="relative h-40 w-full"> <canvas id="scoreTimeSeriesChart"></canvas> </div>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-4 border border-gray-700 shadow-lg fade-in md:col-span-2 text-sm flex flex-col">
                    <h3 class="text-blue-400 text-sm uppercase tracking-widest mb-2 font-semibold">Key Technical Levels (Daily)</h3>
                    <div id="keyTechLevelsDisplay" class="space-y-2">
                        </div>
                    <div id="philosophyDisplay" class="mt-auto pt-3">
                        <!-- Philosophical Framework Analysis will be displayed here -->
                    </div>
                </div>
            </div>

            <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-8 border border-gray-700/50 fade-in">
                <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">Price Trend & Key Technical Levels</h3>
                <div class="relative h-96">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>

            <div class="grid grid-cols-1 gap-6">

                <div class="bg-gray-800 rounded-xl shadow-lg overflow-hidden border border-gray-700/50 fade-in">
                    <div class="px-6 py-4 border-b border-gray-700 bg-gray-700/30">
                        <h3 class="font-bold text-white text-lg"><i class="fas fa-list-check mr-2 text-blue-400"></i>Indicator Breakdown</h3>
                    </div>
                    <div>
                        <table id="breakdownTable" class="w-full text-left border-collapse">
                            <thead>
                                <tr class="text-gray-400 text-xs uppercase bg-gray-700/50 border-b border-gray-700">
                                    <th class="p-4 whitespace-nowrap">Indicator</th>
                                    <th class="p-4 whitespace-nowrap">Detailed Stats</th>
                                    <th class="p-4">Interpretation</th>
                                    <th class="px-2 py-4 text-center">Raw Score</th>
                                    <th class="px-2 py-4 text-center">Weight</th>
                                    <th class="px-2 py-4 text-right">Contribution</th>
                                    <th class="px-2 py-4 text-right text-gray-500" style="font-size: 0.7em;">Ridge (Ref)</th>
                                </tr>
                            </thead>
                            <tbody id="breakdownTableBody" class="divide-y divide-gray-700/50 text-sm">
                                </tbody>
                            <tfoot class="bg-gray-900 font-bold">
                                <tr>
                                    <td colspan="6" class="py-4 px-2 text-right uppercase text-gray-400">Total Signal Score</td>
                                    <td id="footerTotalScore" class="py-4 px-2 text-right text-blue-400 text-xl">0%</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </div>
            </div>

            <div class="mt-8 grid grid-cols-1">
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 border border-gray-700/50 fade-in">
                    <h3 class="text-blue-400 text-base uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">MACD (Monthly) - Macro Signal</h3>
                    <div class="relative h-64">
                        <canvas id="monthlyMacdChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 border border-gray-700/50 fade-in">
                    <h3 class="text-blue-400 text-base uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">MACD (Daily) - Trend Confirmation</h3>
                    <div class="relative h-64">
                        <canvas id="dailyMacdChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="mt-8">
                <div class="bg-gray-800 rounded-xl shadow-lg overflow-hidden border border-gray-700/50 fade-in">
                    <div class="px-6 py-4 border-b border-gray-700 bg-gray-700/30">
                        <h3 class="font-bold text-white text-lg"><i class="fas fa-layer-group mr-2 text-purple-400"></i>Category Analysis</h3>
                    </div>
                    <div id="categoryAnalysisCard" class="p-6 space-y-4">
                        <!-- Category cards will be populated here -->
                    </div>
                </div>
            </div>
            <div class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6 text-xs text-gray-400">
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700/50 shadow-lg">
                    <h4 class="text-white font-bold mb-3 text-sm border-b pb-2 border-gray-700/50"><i class="fas fa-arrow-up text-green-400 mr-2"></i> Logic Rules (+1.0 Base)</h4>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li><span class="text-green-300 font-semibold">MACD (Monthly):</span> Line &gt; Signal (Macro Trend Up)</li>
                        <li><span class="text-green-300 font-semibold">MACD (Daily):</span> Histogram &gt; 0 with slope &gt; 0.005, or |Hist| ≤ 0.02 with slope &gt; 0.005 (bullish crossover forming)</li>
                        <li><span class="text-green-300 font-semibold">RSI:</span> Value &lt; 30 (Oversold bias / bounce risk)</li>
                        <li><span class="text-green-300 font-semibold">ADX:</span> ADX &gt; 25 &amp; +DI &gt; -DI (Strong Uptrend)</li>
                        <li><span class="text-green-300 font-semibold">Price vs. 200-DMA:</span> Price &gt; 200-DMA by more than 1%</li>
                        <li><span class="text-green-300 font-semibold">50-DMA Z-Score:</span> Z-Score &lt; -1.25 (Undervalued / oversold)</li>
                    </ul>
                </div>
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700/50 shadow-lg">
                    <h4 class="text-white font-bold mb-3 text-sm border-b pb-2 border-gray-700/50"><i class="fas fa-arrow-down text-red-400 mr-2"></i>Bearish Logic Rules (-1.0 Base)</h4>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li><span class="text-red-300 font-semibold">MACD (Monthly):</span> Line &lt; Signal (Macro Trend Down)</li>
                        <li><span class="text-red-300 font-semibold">MACD (Daily):</span> Histogram &lt; 0 with slope &lt; -0.005, or |Hist| ≤ 0.02 with slope &lt; -0.005 (bearish crossover forming)</li>
                        <li><span class="text-red-300 font-semibold">RSI:</span> Value &gt; 70 (Overbought / reversal risk)</li>
                        <li><span class="text-red-300 font-semibold">ADX:</span> ADX &gt; 25 &amp; +DI &lt; -DI (Strong Downtrend)</li>
                        <li><span class="text-red-300 font-semibold">Price vs. 200-DMA:</span> Price &lt; 200-DMA by more than 1%</li>
                        <li><span class="text-red-300 font-semibold">50-DMA Z-Score:</span> Z-Score &gt; +1.25 (Overvalued / sell-off risk)</li>
                    </ul>
                </div>
            </div>
        </div>

        <div id="loading" class="hidden mt-12 text-center">
            <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
            <p class="text-blue-400 mt-4 text-lg font-semibold">Crunching the complex numbers... Please hold.</p>
        </div>
        </div> <!-- End Quantum Signal Tab -->

        <!-- Macro Tab -->
        <div id="tab-content-macro" class="tab-content hidden">
            <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-10 border border-gray-700/50">
                <h2 class="text-xl font-semibold mb-4 text-white">
                    <i class="fas fa-chart-line mr-2 text-blue-400"></i>Macro Economic Indicators
                </h2>
                <p class="text-gray-400 text-sm mb-6">Real-time economic data from FRED (Federal Reserve Economic Data)</p>
                <!-- AI Summary Box -->
                <div id="macroAISummary" class="bg-gradient-to-r from-blue-900/20 to-purple-900/20 rounded-xl shadow-lg p-4 mb-6 border border-blue-500/30 hidden">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-blue-400 text-lg font-semibold flex items-center">
                            <i class="fas fa-brain mr-2"></i>AI Market Analysis
                        </h3>
                        <button id="macroAIRefresh" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded-lg transition-colors flex items-center" title="Refresh AI Analysis">
                            <i class="fas fa-sync-alt mr-1"></i>Refresh
                        </button>
                    </div>
                    <div id="macroAISummaryContent" class="text-gray-300 text-sm leading-relaxed">
                        <div class="animate-pulse">
                            <div class="h-4 bg-gray-700 rounded w-3/4 mb-2"></div>
                            <div class="h-4 bg-gray-700 rounded w-1/2 mb-2"></div>
                            <div class="h-4 bg-gray-700 rounded w-5/6"></div>
                        </div>
                    </div>
                </div>

                
                <div id="macroLoading" class="text-center py-8">
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading macro data...</p>
                </div>

                <div id="macroContent" class="hidden">
                    <!-- Composite Macro Score -->
                    <div class="bg-gray-850 rounded-xl shadow-2xl p-4 mb-6 border-2 border-blue-700/50 fade-in">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-chart-pie mr-2"></i>Composite Macro Score
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="macroScoreLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="text-center">
                                <div id="macroScoreValue" class="text-4xl font-extrabold text-white mb-1">--</div>
                                <div id="macroScoreLabel" class="text-sm font-bold text-gray-400 mb-3">--</div>
                                <div id="macroScoreInterpretation" class="text-gray-300 text-sm leading-relaxed mb-4">--</div>
                                <div id="macroScoreAnalysis" class="bg-gray-800 rounded-lg p-3 border border-gray-700/50 text-left">
                                    <div class="text-gray-400 text-xs uppercase mb-2">AI-Generated Analysis</div>
                                    <div id="macroScoreDetailedAnalysis" class="text-gray-300 text-xs leading-relaxed">--</div>
                                </div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-3 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">All Indicator Contributions</div>
                                <div id="macroScoreContributions" class="space-y-1.5 max-h-96 overflow-y-auto">--</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Sahm Rule Indicator -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center gap-4 mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold min-w-0 flex-1">
                                <i class="fas fa-exclamation-triangle mr-2"></i>Real-Time Sahm Rule (Recession Warning)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="sahmLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current 3-Month MA Unemployment Rate</div>
                                <div id="sahmCurrentRate" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-4">12-Month Minimum: <span id="sahmMinRate" class="text-white font-semibold">--</span></div>
                                <div id="sahmStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Change from 12-Month Low</div>
                                <div id="sahmChange" class="text-3xl font-extrabold mb-2 text-white">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> Triggers when 3-month moving average of unemployment rate rises by 0.50 percentage points or more relative to its low during the previous 12 months. This is a coincident indicator that tells you a recession has likely already started.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="sahmChart"></canvas>
                        </div>
                    </div>

                    <!-- Yield Curve Spread -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-chart-area mr-2"></i>10Y-2Y Yield Curve Spread (Leading Indicator)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="yieldLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Spread</div>
                                <div id="yieldSpread" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-2">10-Year Rate: <span id="yield10Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-4">2-Year Rate: <span id="yield2Y" class="text-white font-semibold">--</span></div>
                                <div id="yieldStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Status</div>
                                <div id="yieldAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> When short-term rates (2-year) are higher than long-term rates (10-year), the curve is "inverted," historically predicting a recession within 6 to 18 months. Watch for "re-steepening" after a long inversion; that is often when the economy actually begins to contract.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <button id="yieldCurveZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="yieldChart"></canvas>
                        </div>
                    </div>

                    <!-- Real Wage Growth -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-dollar-sign mr-2"></i>Real Wage Growth Index (Consumer Health)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="wageLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Year-over-Year Real Wage Growth</div>
                                <div id="realWageGrowth" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-2">Average Hourly Earnings: <span id="avgEarnings" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-4">CPI: <span id="cpiValue" class="text-white font-semibold">--</span></div>
                                <div id="wageStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Consumer Spending Health</div>
                                <div id="wageAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> This indicator adjusts wages for inflation to show if the average worker's purchasing power is increasing. If this number is negative, consumer spending (70% of US GDP) will eventually buckle, regardless of what the "nominal" numbers say.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="wageChart"></canvas>
                        </div>
                    </div>

                    <!-- Fed Net Liquidity -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-water mr-2"></i>Fed Net Liquidity (Market Flow Indicator)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="liquidityLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Net Liquidity</div>
                                <div id="netLiquidityValue" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-2"><span class="text-green-400">+</span> Total Assets (WALCL): <span id="walclValue" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-2"><span class="text-red-400">−</span> Treasury Account (WTREGEN): <span id="tgaValue" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-2"><span class="text-red-400">−</span> Reverse Repo (RRPONTSYD): <span id="rrpValue" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-4">4 Week ROC: <span id="liquidityRocDollar" class="text-white font-semibold">--</span> (<span id="liquidityRocPercent" class="text-white font-semibold">--</span>)</div>
                                <div id="liquidityStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Liquidity Trend</div>
                                <div id="liquidityTrend" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> Net Liquidity = (Total Assets - Treasury Account - Reverse Repo) / 1000. This tracks the actual "flow" of money available to financial markets. When Net Liquidity is rising, it provides tailwinds for risk assets. When falling, it creates headwinds and increases the risk of volatility events or corrections.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-80">
                            <button id="liquidityZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="liquidityChart"></canvas>
                        </div>
                    </div>

                    <!-- High-Yield Spread -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-chart-line mr-2"></i>High-Yield Spread (Credit Risk Gauge)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="hySpreadLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Spread</div>
                                <div id="hySpread" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-4">ICE BofA US High Yield Index OAS</div>
                                <div id="hyStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Market Timing Signal</div>
                                <div id="hyAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> Measures extra yield demanded for risky corporate debt over Treasuries. When spread spikes above 7-8% then declines, it marks generational buying opportunities (2009, 2016, 2020). When below 3.5%, markets are "priced for perfection" and vulnerable to corrections. Bond traders are more sensitive to credit risk than equity traders.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="hySpreadChart"></canvas>
                        </div>
                    </div>

                    <!-- NFCI -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-building mr-2"></i>Chicago Fed National Financial Conditions Index (NFCI)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="nfciLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current NFCI</div>
                                <div id="nfciValue" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-4">Combines 105 measures of liquidity, credit, and leverage</div>
                                <div id="nfciStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Financial Conditions</div>
                                <div id="nfciAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> Meta-indicator centered at 0 (historical average). When deeply negative (below -0.5), conditions are extremely loose and markets often peak. When moving sharply positive, indicates liquidity crunch - S&P 500 usually bottoms when index retreats from high positive peak. Captures the "plumbing" of the financial system.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="nfciChart"></canvas>
                        </div>
                    </div>

                    <!-- CFNAI -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-microchip mr-2"></i>Chicago Fed National Activity Index (CFNAI-MA3)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="cfnaiLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current 3-Month Moving Average</div>
                                <div id="cfnaiValue" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-4">Normalized index (0.0 = trend growth)</div>
                                <div id="cfnaiStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Economic Signal</div>
                                <div id="cfnaiAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> The CFNAI-MA3 smooths monthly volatility. A value below <strong>-0.70</strong> suggests a recession has begun. A value above <strong>+0.20</strong> suggests a recession has ended. If it moves above -0.70 after a dip, it indicates an "increasing likelihood" that a recession has ended.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="cfnaiChart"></canvas>
                        </div>
                    </div>

                    <!-- Marshallian K -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-landmark mr-2"></i>Marshallian K (Money Demand Ratio)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="marshallianKLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">M2 / Nominal GDP Ratio</div>
                                <div id="marshallianKValue" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-2">M2 Money Supply: <span id="m2Value" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-4">Nominal GDP: <span id="gdpValue" class="text-white font-semibold">--</span></div>
                                <div id="marshallianKStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Ratio Analysis</div>
                                <div id="marshallianKAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> Marshallian K is the ratio of M2 Money Supply to Nominal GDP. It measures the demand for cash balances relative to the size of the economy. A rising ratio indicates that money supply is expanding faster than economic output, which often precedes asset price inflation.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="marshallianKChart"></canvas>
                        </div>
                    </div>

                    <!-- Excess Liquidity -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-coins mr-2"></i>Excess Liquidity (Growth Spread)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="excessLiquidityLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Excess Liquidity Spread</div>
                                <div id="excessLiquidityValue" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-2">M2 Growth (YoY): <span id="m2GrowthValue" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-4">Nominal GDP Growth (YoY): <span id="gdpGrowthValue" class="text-white font-semibold">--</span></div>
                                <div id="excessLiquidityStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Market Regime Analysis</div>
                                <div id="excessLiquidityAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> Excess Liquidity is the spread between Money Supply (M2) growth and Nominal GDP growth. This is the metric Mike Wilson cites to explain why stocks can rise even if earnings are flat. When M2 grows faster than the economy, "excess" money leaks into financial assets, driving multiple expansion.
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="excessLiquidityChart"></canvas>
                        </div>
                    </div>

                    <!-- Equity Risk Premium -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-balance-scale mr-2"></i>Equity Risk Premium (ERP) Proxy
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current ERP</div>
                                <div id="erpValue" class="text-3xl font-extrabold text-white mb-2">--</div>
                                <div class="text-gray-400 text-sm mb-2">Earnings Yield: <span id="earningsYield" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-4">10Y Treasury Yield: <span id="treasury10Y" class="text-white font-semibold">--</span></div>
                                <div id="erpStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                                
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Valuation Signal</div>
                                <div id="erpAnalysis" class="text-gray-300 text-sm mb-4">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> ERP = Earnings Yield - 10Y Treasury Yield. High ERP (large gap) means stocks are undervalued. Low/Negative ERP means stocks are expensive relative to bonds. Explains why S&P 500 can crash when earnings are good (bond yields rose too fast) or rally when earnings are bad (yields fell faster).
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="erpChart"></canvas>
                        </div>
                    </div>

                    <!-- Combined S&P 500 Timing Signals -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-signal mr-2"></i>Combined S&P 500 Entry/Exit Signals
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Values</div>
                                <div class="text-gray-300 text-sm mb-1">VIX: <span id="vixCurrent" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">High-Yield Spread: <span id="hyCurrent" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">NFCI: <span id="nfciCurrent" class="text-white font-semibold">--</span></div>
                                <div id="combinedSignal" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Signal Analysis</div>
                                <div id="combinedAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>Pattern Recognition:</strong><br>
                                    • <strong>Double Confirmation Bottom:</strong> VIX > 35 & Spread > 7% both declining = powerful buy signal<br>
                                    • <strong>Quiet Risk Divergence:</strong> Low VIX but rising Spread = warning to trim positions<br>
                                    • <strong>Panic Peak:</strong> VIX > 40 with flat Spread = flash crash, not deep bear market
                                </div>
                            </div>
                        </div>
                        <div class="relative h-96">
                            <canvas id="combinedChart"></canvas>
                        </div>
                    </div>

                    <!-- 3 Headed Monster -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-dragon mr-2"></i>3 Headed Monster (Oil, 10Y Yield, Dollar)
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Values</div>
                                <div class="text-gray-300 text-sm mb-1">Oil (WTI): <span id="monsterOil" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">10Y Treasury Yield: <span id="monster10Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">US Dollar Index: <span id="monsterDollar" class="text-white font-semibold">--</span></div>
                                <div id="monsterStatus" class="inline-block px-4 py-2 rounded-full text-sm font-bold mb-4">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Signal Analysis</div>
                                <div id="monsterAnalysis" class="text-gray-300 text-sm mb-3">--</div>
                                <div class="text-gray-400 text-xs mt-4">
                                    <strong>How it works:</strong> When oil, 10-year Treasury yield, and the US dollar all move in the same direction, it creates a powerful signal for S&P 500 direction. All three falling together = tailwind for stocks (liquidity/lower costs). All three rising together = headwind (higher costs/inflationary pressure).
                                </div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <canvas id="threeHeadedMonsterChart"></canvas>
                        </div>
                    </div>

                    <!-- H.O.P.E. Model Dashboard -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-home mr-2"></i>H.O.P.E. Model - Recession Progression Tracker
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="hopeLatestDate">--</span></span>
                        </div>
                        <div class="text-gray-400 text-xs mb-4 italic">
                            Developed by Michael Kantrowitz (Piper Sandler). Tracks the typical sequence: <strong>H</strong>ousing → <strong>O</strong>rders → <strong>P</strong>rofits → <strong>E</strong>mployment
                        </div>
                        
                        <!-- HOPE Status Overview -->
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Housing</div>
                                <div id="hopeHousingStatus" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs" id="hopeHousingValue">--</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Orders</div>
                                <div id="hopeOrdersStatus" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs" id="hopeOrdersValue">--</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Profits</div>
                                <div id="hopeProfitsStatus" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs" id="hopeProfitsValue">--</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Employment</div>
                                <div id="hopeEmploymentStatus" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs" id="hopeEmploymentValue">--</div>
                            </div>
                        </div>

                        <!-- HOPE Model Stage Indicator -->
                        <div class="mb-6">
                            <div class="text-gray-400 text-sm mb-3">Current Recession Stage:</div>
                            <div id="hopeStageIndicator" class="inline-block px-6 py-3 rounded-lg text-lg font-bold mb-3">--</div>
                            <div id="hopeStageAnalysis" class="text-gray-300 text-sm mb-4">--</div>
                            
                            <!-- HOPE Progress Bar -->
                            <div class="relative w-full h-8 bg-gray-800 rounded-full overflow-hidden border border-gray-700/50">
                                <div id="hopeProgressBar" class="h-full bg-gradient-to-r from-green-500 via-yellow-500 via-orange-500 to-red-500 transition-all duration-500" style="width: 0%"></div>
                                <div class="absolute inset-0 flex items-center justify-center">
                                    <span id="hopeProgressText" class="text-xs font-semibold text-white drop-shadow-lg">--</span>
                                </div>
                            </div>
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>Housing</span>
                                <span>Orders</span>
                                <span>Profits</span>
                                <span>Employment</span>
                            </div>
                        </div>

                        <!-- Detailed HOPE Components -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Housing Indicators</div>
                                <div class="text-gray-300 text-xs mb-1">Housing Starts: <span id="hopeHousingStarts" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-1">Building Permits: <span id="hopeBuildingPermits" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-3">Existing Home Sales: <span id="hopeHomeSales" class="text-white font-semibold">--</span></div>
                                <div id="hopeHousingAnalysis" class="text-gray-400 text-xs">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Orders Indicators</div>
                                <div class="text-gray-300 text-xs mb-1">Durable Goods Orders: <span id="hopeDurableOrders" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-1">ISM Manufacturing Orders: <span id="hopeISMOrders" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-3">Orders Trend: <span id="hopeOrdersTrend" class="text-white font-semibold">--</span></div>
                                <div id="hopeOrdersAnalysis" class="text-gray-400 text-xs">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Profits Indicators</div>
                                <div class="text-gray-300 text-xs mb-1">Corporate Profits: <span id="hopeCorporateProfits" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-1">S&P 500 Earnings: <span id="hopeSP500Earnings" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-3">Profits Trend: <span id="hopeProfitsTrend" class="text-white font-semibold">--</span></div>
                                <div id="hopeProfitsAnalysis" class="text-gray-400 text-xs">--</div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Employment Indicators</div>
                                <div class="text-gray-300 text-xs mb-1">Unemployment Rate: <span id="hopeUnemployment" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-1">Non-Farm Payrolls: <span id="hopePayrolls" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-xs mb-3">Initial Jobless Claims: <span id="hopeJoblessClaims" class="text-white font-semibold">--</span></div>
                                <div id="hopeEmploymentAnalysis" class="text-gray-400 text-xs">--</div>
                            </div>
                        </div>

                        <div class="text-gray-400 text-xs mt-4">
                            <strong>How it works:</strong> The HOPE model tracks the typical sequence of economic deterioration before recessions. Housing weakens first (sensitive to rates), followed by Orders (demand), then Profits (business impact), and finally Employment (lagging indicator). When all four stages show weakness, recession risk is high. The model helps identify early warning signs and track recession progression.
                        </div>

                        <div class="relative h-96 mt-4">
                            <canvas id="hopeChart"></canvas>
                        </div>
                    </div>

                    <!-- Summary Dashboard -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-tachometer-alt mr-2"></i>Macro Indicator Summary
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Recession Risk</div>
                                <div id="summaryRecession" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">Based on Sahm Rule</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Yield Curve</div>
                                <div id="summaryYield" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">10Y-2Y Spread</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Consumer Health</div>
                                <div id="summaryConsumer" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">Real Wage Growth</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Market Liquidity</div>
                                <div id="summaryLiquidity" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">Fed Net Liquidity</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Credit Risk</div>
                                <div id="summaryCredit" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">High-Yield Spread</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Financial Conditions</div>
                                <div id="summaryNFCI" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">NFCI Index</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Valuation</div>
                                <div id="summaryERP" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">Equity Risk Premium</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Combined Signal</div>
                                <div id="summaryCombined" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">VIX + Spread + NFCI</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">3 Headed Monster</div>
                                <div id="summaryMonster" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">Oil + Yield + Dollar</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">Excess Liquidity</div>
                                <div id="summaryExcessLiquidity" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">Marshallian K Spread</div>
                            </div>
                            <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                                <div class="text-gray-400 text-xs uppercase mb-2">HOPE Model</div>
                                <div id="summaryHOPE" class="text-2xl font-bold mb-2">--</div>
                                <div class="text-gray-500 text-xs">Recession Stage</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div> <!-- End Macro Tab -->

        <!-- Interest Rates Tab -->
        <div id="tab-content-interest" class="tab-content hidden">
            <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-10 border border-gray-700/50">
                <h2 class="text-xl font-semibold mb-4 text-white">
                    <i class="fas fa-percent mr-2 text-blue-400"></i>Interest Rates Dashboard
                </h2>
                <p class="text-gray-400 text-sm mb-6">Comprehensive interest rate data from FRED (Federal Reserve Economic Data)</p>
                <!-- AI Summary Box -->
                <div id="interestAISummary" class="bg-gradient-to-r from-blue-900/20 to-purple-900/20 rounded-xl shadow-lg p-4 mb-6 border border-blue-500/30 hidden">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-blue-400 text-lg font-semibold flex items-center">
                            <i class="fas fa-brain mr-2"></i>AI Market Analysis
                        </h3>
                        <button id="interestAIRefresh" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded-lg transition-colors flex items-center" title="Refresh AI Analysis">
                            <i class="fas fa-sync-alt mr-1"></i>Refresh
                        </button>
                    </div>
                    <div id="interestAISummaryContent" class="text-gray-300 text-sm leading-relaxed">
                        <div class="animate-pulse">
                            <div class="h-4 bg-gray-700 rounded w-3/4 mb-2"></div>
                            <div class="h-4 bg-gray-700 rounded w-1/2 mb-2"></div>
                            <div class="h-4 bg-gray-700 rounded w-5/6"></div>
                        </div>
                    </div>
                </div>

                
                <div id="interestLoading" class="text-center py-8">
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading interest rate data...</p>
                </div>

                <div id="interestContent" class="hidden">
                    <!-- Term Premium -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-chart-area mr-2"></i>Term Premium (2-Year & 10-Year - Kim & Wright Model)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="termPremiumLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Term Premium</div>
                                <div class="text-gray-300 text-sm mb-1">2-Year: <span id="termPremium2Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">10-Year: <span id="termPremium10Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-xs">
                                    <strong>How it works:</strong> Term premium (Kim & Wright model) represents the extra yield investors demand for holding longer-term bonds instead of rolling over short-term ones. Positive = compensation for duration risk. Negative = "bond mania" - investors accept no risk premium during peak liquidity. Spiking premium = headwind for stocks (investor nervousness, not just growth).
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Analysis</div>
                                <div id="termPremiumAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <button id="termPremiumZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="termPremiumChart"></canvas>
                        </div>
                    </div>

                    <!-- Forward Term Premium -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-forward mr-2"></i>Forward Term Premium (Long-Run Expectations)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="forwardPremiumLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Forward Term Premium</div>
                                <div class="text-gray-300 text-sm mb-1">5-Year Forward (5 years hence): <span id="forwardPremium5Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">10-Year Forward (10 years hence): <span id="forwardPremium10Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-xs">
                                    <strong>How it works:</strong> Forward term premiums show what the market expects the premium to be at a specific future point (rather than an average over the bond's life). Used by the Fed to gauge "long-run inflation uncertainty." If this spikes, it suggests the market is worried about long-term fiscal stability or inflation.
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Analysis</div>
                                <div id="forwardPremiumAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <button id="forwardPremiumZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="forwardPremiumChart"></canvas>
                        </div>
                    </div>

                    <!-- 10Y Term Premium vs Forward Term Premium Comparison -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-balance-scale mr-2"></i>10Y Term Premium vs Forward Term Premium
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Values</div>
                                <div class="text-gray-300 text-sm mb-1">10Y Term Premium: <span id="termPremium10YCurrent" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">10Y Forward Term Premium: <span id="forwardPremium10YCurrent" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">Difference: <span id="termPremiumDiff" class="text-yellow-400 font-semibold">--</span></div>
                                <div class="text-gray-400 text-xs">
                                    <strong>How it works:</strong> This compares the current 10-year term premium (risk compensation today) with the 10-year forward term premium (expected risk compensation 10 years from now). The difference shows whether markets expect term premiums to rise or fall over the next decade. A positive difference suggests markets expect higher future risk premiums.
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Analysis</div>
                                <div id="termPremiumComparisonAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <button id="termPremiumComparisonZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="termPremiumComparisonChart"></canvas>
                        </div>
                    </div>

                    <!-- Yield Decomposition -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-pie-chart mr-2"></i>10-Year Yield Decomposition
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="yieldDecompLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Breakdown</div>
                                <div class="text-gray-300 text-sm mb-1">Nominal Yield (GS10): <span id="yield10YTotal" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">Real Rate (r*): <span id="yieldRealRate" class="text-green-400 font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">Expected Inflation: <span id="yieldInflation" class="text-orange-400 font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">Term Premium: <span id="yieldTermPremium" class="text-blue-400 font-semibold">--</span></div>
                                <div class="text-gray-400 text-xs">
                                    <strong>Formula:</strong> Nominal Yield = Real Rate + Expected Inflation + Term Premium.<br>
                                    <strong>Real Rate (r*)</strong>: Pure cost of borrowing after stripping out inflation; reflects expected growth (10Y TIPS, DFII10).<br>
                                    <strong>Expected Inflation</strong>: Average inflation the market expects over the bond's life (calculated as breakeven rate = nominal 10yr yield − TIPS real yield).<br>
                                    <strong>Term Premium</strong>: Extra yield for duration risk—the &quot;uncertainty tax&quot; (Kim-Wright THREEFYTP10). Term premium is adjusted to reconcile any discrepancy between nominal yield and the sum of components (due to data timing, measurement differences, or model estimation).
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Analysis</div>
                                <div id="yieldDecompAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <button id="yieldDecompZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="yieldDecompChart"></canvas>
                        </div>
                    </div>

                    <!-- Inflation Expectations -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-fire mr-2"></i>Implied Inflation Expectations
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="inflationExpectLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Expectations</div>
                                <div class="text-gray-300 text-sm mb-1">10-Year Breakeven: <span id="inflation10Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">5Y-5Y Forward: <span id="inflation5Y5Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-xs">
                                    <strong>How it works:</strong> Breakeven inflation is the difference between nominal and inflation-indexed bonds. 5Y-5Y forward shows expected inflation 5 years from now for the following 5 years.
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Analysis</div>
                                <div id="inflationAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <button id="inflationChartZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="inflationChart"></canvas>
                        </div>
                    </div>

                    <!-- Real Yields -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-calculator mr-2"></i>Real Yields (Inflation-Adjusted)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="realYieldLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Real Yield</div>
                                <div class="text-3xl font-extrabold text-white mb-2"><span id="realYield10Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-400 text-sm mb-4">10-Year TIPS Real Yield</div>
                                <div class="text-gray-400 text-xs">
                                    <strong>How it works:</strong> Real yield is the return on Treasury Inflation-Protected Securities (TIPS), representing the actual return after inflation. Positive real yields = investors compensated for inflation risk.
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Analysis</div>
                                <div id="realYieldAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="relative h-64">
                            <button id="realYieldZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="realYieldChart"></canvas>
                        </div>
                    </div>

                    <!-- Market vs Model Rate Comparison Card -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-purple-700/50 fade-in">
                        <h3 class="text-purple-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-purple-700/50">
                            <i class="fas fa-balance-scale-right mr-2"></i>Market vs Model: Real Rate & Inflation Comparison
                        </h3>
                        <div class="mb-4">
                            <p class="text-gray-400 text-xs mb-3">
                                Comparing the <strong class="text-cyan-400">Risk-Neutral Yield</strong> (Kim-Wright model) to the <strong class="text-green-400">Market Real Rate</strong> (TIPS) reveals how much "insurance premium" investors are charging and whether the Fed's policy is truly restrictive.
                            </p>
                        </div>
                        
                        <!-- Comparison Table -->
                        <div class="overflow-x-auto mb-6">
                            <table class="w-full text-sm">
                                <thead>
                                    <tr class="border-b border-gray-700">
                                        <th class="text-left py-2 px-3 text-gray-400 font-semibold">Metric</th>
                                        <th class="text-center py-2 px-3 text-green-400 font-semibold">Market-Based (TIPS)</th>
                                        <th class="text-center py-2 px-3 text-cyan-400 font-semibold">Model-Based (Kim-Wright)</th>
                                        <th class="text-center py-2 px-3 text-yellow-400 font-semibold">Gap (Premium)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="border-b border-gray-700/50">
                                        <td class="py-3 px-3 text-gray-300 font-medium">Real Rate</td>
                                        <td id="mktRealRate" class="py-3 px-3 text-center text-green-400 font-semibold">--</td>
                                        <td id="modelRealRate" class="py-3 px-3 text-center text-cyan-400 font-semibold">--</td>
                                        <td id="realRateGap" class="py-3 px-3 text-center text-yellow-400 font-semibold">--</td>
                                    </tr>
                                    <tr class="border-b border-gray-700/50">
                                        <td class="py-3 px-3 text-gray-300 font-medium">Inflation Expectation</td>
                                        <td id="mktInflation" class="py-3 px-3 text-center text-green-400 font-semibold">--</td>
                                        <td id="modelInflation" class="py-3 px-3 text-center text-cyan-400 font-semibold">--</td>
                                        <td id="inflationGap" class="py-3 px-3 text-center text-yellow-400 font-semibold">--</td>
                                    </tr>
                                    <tr class="border-b border-gray-700/50">
                                        <td class="py-3 px-3 text-gray-300 font-medium">Nominal Yield</td>
                                        <td id="mktNominal" class="py-3 px-3 text-center text-green-400 font-semibold">--</td>
                                        <td id="modelNominal" class="py-3 px-3 text-center text-cyan-400 font-semibold">--</td>
                                        <td id="nominalGap" class="py-3 px-3 text-center text-yellow-400 font-semibold">--</td>
                                    </tr>
                                    <tr>
                                        <td class="py-3 px-3 text-gray-300 font-medium">Term Premium</td>
                                        <td id="mktTermPrem" class="py-3 px-3 text-center text-green-400 font-semibold">--</td>
                                        <td id="modelTermPrem" class="py-3 px-3 text-center text-cyan-400 font-semibold">--</td>
                                        <td id="termPremGap" class="py-3 px-3 text-center text-yellow-400 font-semibold">--</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Key Insights Grid -->
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                            <!-- Insight 1: Real Term Premium -->
                            <div class="bg-gray-800/50 rounded-lg p-4 border border-red-700/30">
                                <div class="flex items-center mb-2">
                                    <i class="fas fa-exclamation-triangle text-red-400 mr-2"></i>
                                    <h4 class="text-red-400 text-sm font-semibold">Real Rate Risk Premium</h4>
                                </div>
                                <div id="realRatePremiumValue" class="text-2xl font-bold text-white mb-1">--</div>
                                <p id="realRatePremiumText" class="text-gray-400 text-xs">
                                    The gap between TIPS yield and the model's "fair" real rate. Higher = investors fear r* has structurally risen due to deficits.
                                </p>
                            </div>
                            
                            <!-- Insight 2: Fed Restrictiveness -->
                            <div class="bg-gray-800/50 rounded-lg p-4 border border-orange-700/30">
                                <div class="flex items-center mb-2">
                                    <i class="fas fa-university text-orange-400 mr-2"></i>
                                    <h4 class="text-orange-400 text-sm font-semibold">Fed Policy Stance</h4>
                                </div>
                                <div id="fedStanceValue" class="text-2xl font-bold text-white mb-1">--</div>
                                <p id="fedStanceText" class="text-gray-400 text-xs">
                                    Current real rate vs Fed's traditional neutral rate (0.5%-1.0%). Above = restrictive monetary policy.
                                </p>
                            </div>
                            
                            <!-- Insight 3: Inflation Premium -->
                            <div class="bg-gray-800/50 rounded-lg p-4 border border-yellow-700/30">
                                <div class="flex items-center mb-2">
                                    <i class="fas fa-fire text-yellow-400 mr-2"></i>
                                    <h4 class="text-yellow-400 text-sm font-semibold">Inflation Risk Premium</h4>
                                </div>
                                <div id="inflationPremiumValue" class="text-2xl font-bold text-white mb-1">--</div>
                                <p id="inflationPremiumText" class="text-gray-400 text-xs">
                                    Gap between market breakeven and survey expectations. Positive = inflation uncertainty premium.
                                </p>
                            </div>
                        </div>
                        
                        <!-- Summary Box -->
                        <div class="bg-gradient-to-r from-purple-900/20 to-blue-900/20 rounded-lg p-4 border border-purple-500/30">
                            <div class="flex items-center mb-2">
                                <i class="fas fa-lightbulb text-purple-400 mr-2"></i>
                                <h4 class="text-purple-400 text-sm font-semibold uppercase tracking-wider">The "Sticker Price" vs. "True Cost"</h4>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                                <div>
                                    <div class="text-gray-400 text-xs uppercase mb-1">Risk-Neutral ("True Cost")</div>
                                    <div id="summaryRiskNeutral" class="text-xl font-bold text-cyan-400">--</div>
                                    <div class="text-gray-500 text-xs">What the economy "needs"</div>
                                </div>
                                <div>
                                    <div class="text-gray-400 text-xs uppercase mb-1">Nominal ("Sticker Price")</div>
                                    <div id="summaryNominal" class="text-xl font-bold text-green-400">--</div>
                                    <div class="text-gray-500 text-xs">What you actually pay</div>
                                </div>
                                <div>
                                    <div class="text-gray-400 text-xs uppercase mb-1">Insurance Premium</div>
                                    <div id="summaryPremium" class="text-xl font-bold text-yellow-400">--</div>
                                    <div class="text-gray-500 text-xs">Uncertainty tax</div>
                                </div>
                            </div>
                            <p id="summaryAnalysis" class="text-gray-300 text-xs mt-3 pt-3 border-t border-gray-700/50">
                                Loading analysis...
                            </p>
                        </div>
                        
                        <div class="mt-4 text-gray-500 text-xs">
                            <strong>Methodology:</strong> Market-based = observable TIPS/Breakeven rates. Model-based = Kim-Wright model decomposition (Risk-Neutral = Nominal − Term Premium). Inflation expectation (model) uses survey-based estimates (~2.0-2.1%). Gap = market implied risk premium over the "no uncertainty" baseline.
                        </div>
                    </div>

                    <!-- Inflation (CPI & PCE) -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-chart-line mr-2"></i>Inflation: CPI & PCE
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="inflationCpiPceLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Year-over-Year (YoY)</div>
                                <div class="text-gray-300 text-sm mb-1">CPI Overall: <span id="cpiOverall" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">CPI Core: <span id="cpiCore" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">PCE Overall: <span id="pceOverall" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">PCE Core: <span id="pceCore" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">Dallas Trimmed Mean: <span id="dallasTrimmed" class="text-purple-400 font-semibold">--</span></div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Month-over-Month (MoM)</div>
                                <div class="text-gray-300 text-sm mb-1">CPI Overall: <span id="cpiOverallMoM" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">CPI Core: <span id="cpiCoreMoM" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">PCE Overall: <span id="pceOverallMoM" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">PCE Core: <span id="pceCoreMoM" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">Dallas Trimmed Mean: <span id="dallasTrimmedMoM" class="text-purple-400 font-semibold">--</span></div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Latest Data</div>
                                <div class="text-gray-300 text-xs mb-1">CPI Date: <span id="cpiLatestDate" class="text-white">--</span></div>
                                <div class="text-gray-300 text-xs mb-1">PCE Date: <span id="pceLatestDate" class="text-white">--</span></div>
                                <div class="text-gray-400 text-sm mb-2 mt-4">Analysis</div>
                                <div id="inflationCpiPceAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="text-gray-400 text-xs mb-4">
                            <strong>How it works:</strong> Click legend items to show/hide series. CPI (Consumer Price Index) from BLS and PCE (Personal Consumption Expenditures) from FRED are the two main inflation measures. Core excludes food and energy. PCE is the Fed's preferred measure. <strong>Dallas Trimmed Mean</strong> removes extreme price movements for a clearer trend signal. MoM shows monthly changes (annualized).
                        </div>
                        <div class="relative h-64 mb-6">
                            <button id="inflationCpiPceZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="inflationCpiPceChart"></canvas>
                        </div>
                        <div class="border-t border-gray-700/50 pt-4">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="text-gray-400 text-sm uppercase tracking-widest font-semibold">CPI & PCE Components Analysis</h4>
                                <div class="flex items-center gap-2 text-xs text-gray-500">
                                    <label class="flex items-center cursor-pointer">
                                        <input type="checkbox" id="showComponentDetails" class="mr-1 h-3 w-3 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                                        <span>Show Details</span>
                                    </label>
                                </div>
                            </div>
                            <div id="cpiComponentsAnalysis" class="overflow-x-auto">
                                <!-- Component table will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- FOMC Dot Plot vs 2Y Yield -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                <i class="fas fa-dot-circle mr-2"></i>FOMC Dot Plot vs Market Expectations (2Y Yield)
                            </h3>
                            <span class="text-blue-300 text-xs shrink-0 ml-2 whitespace-nowrap">Latest update: <span id="dotPlotLatestDate">--</span></span>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Current Values</div>
                                <div class="text-gray-300 text-sm mb-1">2-Year Yield: <span id="dotPlot2Y" class="text-white font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-1">Fed Funds Rate: <span id="dotPlotFedFunds" class="text-green-400 font-semibold">--</span></div>
                                <div class="text-gray-300 text-sm mb-4">Fed Median: <span id="dotPlotMedian" class="text-blue-400 font-semibold">--</span></div>
                                <div class="text-gray-400 text-xs">
                                    <strong>How it works:</strong> The 2-Year Yield (daily, blue line) represents market-implied expectations for Fed policy. The Fed's Dot Plot shows quarterly projections: the red step line shows the median consensus projection going back historically. Data available from 2012. When 2Y Yield is below the Fed Median, the market expects easier policy than the Fed signals (dovish market). When above, markets expect tighter policy (hawkish market). Alignment = lower volatility.
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-sm mb-2">Analysis</div>
                                <div id="dotPlotAnalysis" class="text-gray-300 text-sm">--</div>
                            </div>
                        </div>
                        <div class="mb-2 flex items-center">
                            <label class="flex items-center text-gray-400 text-xs cursor-pointer">
                                <input type="checkbox" id="dotPlotOneYearFilter" class="mr-1.5 h-3 w-3 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-1">
                                <span>Show last 1 year only</span>
                            </label>
                        </div>
                        <div class="relative h-64">
                            <button id="dotPlotZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="dotPlotChart"></canvas>
                        </div>
                    </div>

                </div>
            </div>
        </div> <!-- End Interest Rates Tab -->

        <!-- TAA Tab -->
        <div id="tab-content-taa" class="tab-content hidden">
            <div id="taaLoading" class="text-center py-20">
                <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                <p class="text-blue-400 mt-4 text-lg font-semibold">Loading TAA framework data...</p>
            </div>
            <div id="taaContent" class="hidden">
                <!-- Current Regime Indicator -->
                <div class="bg-gradient-to-r from-gray-800 to-gray-900 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <h2 class="text-2xl font-bold mb-4 text-white">
                        <i class="fas fa-chart-pie mr-2 text-blue-400"></i>Tactical Asset Allocation Framework
                    </h2>
                    <p class="text-gray-400 mb-6">Growth & Inflation Regime-Based Allocation</p>
                    
                    <!-- Current Regime Card -->
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Current Regime</div>
                            <div id="currentRegime" class="text-2xl font-bold mb-2 text-blue-400">--</div>
                            <div class="text-gray-500 text-xs">Classification</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Composite Growth (IP + PMI + CFNAI-MA3, YoY)</div>
                            <div id="currentGrowth" class="text-2xl font-bold mb-2 text-white">--</div>
                            <div class="text-gray-500 text-xs">Annual Change</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Inflation (YoY)</div>
                            <div id="currentInflation" class="text-2xl font-bold mb-2 text-white">--</div>
                            <div class="text-gray-500 text-xs">Core PCE Annual Change</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Regime Duration</div>
                            <div id="regimeDuration" class="text-2xl font-bold mb-2 text-white">--</div>
                            <div class="text-gray-500 text-xs">Months in Current</div>
                        </div>
                    </div>
                    
                    <!-- Enhanced Regime Analysis -->
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Regime Strength</div>
                            <div id="regimeStrength" class="text-2xl font-bold mb-2 text-white">--</div>
                            <div class="text-gray-500 text-xs">Confidence Score</div>
                            <div id="regimeStrengthBar" class="mt-2 h-2 bg-gray-700 rounded-full overflow-hidden">
                                <div id="regimeStrengthBarFill" class="h-full bg-blue-500 transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Expected Duration</div>
                            <div id="expectedDuration" class="text-2xl font-bold mb-2 text-white">--</div>
                            <div class="text-gray-500 text-xs">Based on Historical</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Transition Risk</div>
                            <div id="transitionRisk" class="text-2xl font-bold mb-2 text-white">--</div>
                            <div class="text-gray-500 text-xs">Distance to Boundary</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 border border-gray-700/50">
                            <div class="text-gray-400 text-xs uppercase mb-2">Most Likely Next</div>
                            <div id="nextRegime" class="text-2xl font-bold mb-2 text-white">--</div>
                            <div id="nextRegimeProb" class="text-gray-500 text-xs">--</div>
                            <div id="nextRegimeTransition" class="text-gray-400 text-xs mt-1 hidden">--</div>
                        </div>
                    </div>
                    
                    <!-- Transition Probabilities & Forward-Looking Allocation -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <!-- Transition Probability Matrix -->
                        <div class="bg-gray-800 rounded-xl shadow-lg p-6 border border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-project-diagram mr-2"></i>Regime Transition Probabilities
                            </h3>
                            <p class="text-gray-400 text-xs mb-4">Historical probability of transitioning from current regime to each possible next regime</p>
                            <div id="transitionMatrix" class="text-sm">
                                <!-- Will be populated by JavaScript -->
                            </div>
                        </div>
                        
                        <!-- Forward-Looking Allocation -->
                        <div class="bg-gray-800 rounded-xl shadow-lg p-6 border border-gray-700/50">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-chart-pie mr-2"></i>Forward-Looking Allocation
                            </h3>
                            <p class="text-gray-400 text-xs mb-4">Recommended allocation for current regime and most likely next regime</p>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <div class="text-gray-400 text-xs uppercase mb-2">Current Regime</div>
                                    <div id="currentAllocation" class="space-y-1">
                                        <!-- Current allocation -->
                                    </div>
                                </div>
                                <div>
                                    <div class="text-gray-400 text-xs uppercase mb-2">Next Regime (Blended)</div>
                                    <div id="forwardAllocation" class="space-y-1 mb-4">
                                        <!-- Forward-looking allocation -->
                                    </div>
                                    <div class="mt-4">
                                        <canvas id="forwardAllocationChart" style="max-height: 200px;"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Complete Transition Matrix -->
                    <div class="bg-gray-800 rounded-xl shadow-lg p-6 border border-gray-700/50 mb-6">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-table mr-2"></i>Complete Transition Matrix
                        </h3>
                        <p class="text-gray-400 text-xs mb-4">Historical transition probabilities from each regime (rows) to each regime (columns)</p>
                        <div id="fullTransitionMatrix" class="text-sm overflow-x-auto">
                            <!-- Will be populated by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Regime Calibration Info -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <h3 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-cog mr-2 text-blue-400"></i>Regime Calibration
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div class="bg-gray-900/50 rounded-lg p-4 border border-gray-700/30">
                            <div class="text-sm font-semibold text-gray-300 mb-2">Growth Proxy</div>
                            <div class="text-2xl font-bold text-blue-400 mb-1">IP + PMI + CFNAI-MA3</div>
                            <div class="text-xs text-gray-400">Composite Growth (YoY)</div>
                            <div class="text-xs text-gray-500 mt-2">Blend of Industrial Production (40%), PMI (30%), and CFNAI-MA3 (30%) growth rates. CFNAI uses 3-month moving average per Chicago Fed "Golden Rule". Classification uses gradient scoring based on z-score magnitude. 60 years of data where available.</div>
                        </div>
                        <div class="bg-gray-900/50 rounded-lg p-4 border border-gray-700/30">
                            <div class="text-sm font-semibold text-gray-300 mb-2">Scoring Method</div>
                            <div class="text-2xl font-bold text-yellow-400 mb-1">Gradient</div>
                            <div class="text-xs text-gray-400">Weighted by Magnitude</div>
                            <div class="text-xs text-gray-500 mt-2">Regime classification uses gradient scoring where higher z-scores have more influence. No hard thresholds - classification is continuous and weighted.</div>
                        </div>
                    </div>
                    <div id="regimeCalibrationStats" class="text-sm text-gray-400">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Regime Quadrant Chart -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="text-xl font-semibold text-white">
                                <i class="fas fa-th mr-2 text-blue-400"></i>Growth-Inflation Regime Quadrant
                            </h3>
                            <p class="text-gray-400 text-xs mt-1">Recent 24 months with clear quadrant divisions. Shows current position and recent regime context.</p>
                        </div>
                        <label class="flex items-center text-xs text-gray-400 cursor-pointer">
                            <input type="checkbox" id="showProgression" class="w-3 h-3 mr-1.5 rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500 focus:ring-1">
                            <span>Show 2Y Progression</span>
                        </label>
                    </div>
                    <div class="relative h-96 mb-4">
                        <canvas id="regimeQuadrantChart"></canvas>
                    </div>
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mt-4">
                        <div class="bg-green-900/30 rounded-lg p-3 border border-green-500/50">
                            <div class="text-green-500 text-sm font-semibold mb-1">Disinflationary Boom</div>
                            <div class="text-gray-300 text-xs">High Growth, Low Inflation</div>
                            <div class="text-gray-400 text-xs mt-2">Favor: Equities, Growth Stocks</div>
                        </div>
                        <div class="bg-yellow-900/30 rounded-lg p-3 border border-yellow-500/50">
                            <div class="text-yellow-500 text-sm font-semibold mb-1">Inflationary Boom</div>
                            <div class="text-gray-300 text-xs">High Growth, High Inflation</div>
                            <div class="text-gray-400 text-xs mt-2">Favor: Commodities, Real Assets</div>
                        </div>
                        <div class="bg-blue-900/30 rounded-lg p-3 border border-blue-500/50">
                            <div class="text-blue-500 text-sm font-semibold mb-1">Disinflationary Bust</div>
                            <div class="text-gray-300 text-xs">Low Growth, Low Inflation</div>
                            <div class="text-gray-400 text-xs mt-2">Favor: Bonds, Defensive Equities</div>
                        </div>
                        <div class="bg-red-900/30 rounded-lg p-3 border border-red-500/50">
                            <div class="text-red-500 text-sm font-semibold mb-1">Inflationary Bust</div>
                            <div class="text-gray-300 text-xs">Low Growth, High Inflation</div>
                            <div class="text-gray-400 text-xs mt-2">Favor: Gold, Commodities, TIPS</div>
                        </div>
                        <div class="bg-gray-900/30 rounded-lg p-3 border border-gray-700/50">
                            <div class="text-gray-400 text-sm font-semibold mb-1">Neutral</div>
                            <div class="text-gray-300 text-xs">Near Average Growth & Inflation</div>
                            <div class="text-gray-400 text-xs mt-2">Favor: Balanced Portfolio</div>
                        </div>
                    </div>
                </div>

                <!-- Recommended Asset Allocation -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <h3 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-balance-scale mr-2 text-blue-400"></i>Recommended Tactical Allocation
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-5 gap-4">
                        <div class="bg-green-900/20 rounded-lg p-3 border border-green-500/30">
                            <div class="text-green-500 text-xs font-semibold mb-2">Disinflationary Boom</div>
                            <div class="text-xs text-gray-300 space-y-0.5">
                                <div>Equities: 60-70%</div>
                                <div>Bonds: 20-30%</div>
                                <div>Commodities: 5-10%</div>
                                <div>Cash: 0-5%</div>
                            </div>
                        </div>
                        <div class="bg-yellow-900/20 rounded-lg p-3 border border-yellow-500/30">
                            <div class="text-yellow-500 text-xs font-semibold mb-2">Inflationary Boom</div>
                            <div class="text-xs text-gray-300 space-y-0.5">
                                <div>Equities: 40-50%</div>
                                <div>Bonds: 20-25%</div>
                                <div>Commodities: 25-35%</div>
                                <div>Cash: 0-5%</div>
                            </div>
                        </div>
                        <div class="bg-blue-900/20 rounded-lg p-3 border border-blue-500/30">
                            <div class="text-blue-500 text-xs font-semibold mb-2">Disinflationary Bust</div>
                            <div class="text-xs text-gray-300 space-y-0.5">
                                <div>Equities: 30-40%</div>
                                <div>Bonds: 50-60%</div>
                                <div>Commodities: 0-5%</div>
                                <div>Cash: 5-10%</div>
                            </div>
                        </div>
                        <div class="bg-red-900/20 rounded-lg p-3 border border-red-500/30">
                            <div class="text-red-500 text-xs font-semibold mb-2">Inflationary Bust</div>
                            <div class="text-xs text-gray-300 space-y-0.5">
                                <div>Equities: 20-30%</div>
                                <div>Bonds: 20-30% (TIPS)</div>
                                <div>Commodities: 35-45%</div>
                                <div>Cash: 5-10%</div>
                            </div>
                        </div>
                        <div class="bg-gray-900/20 rounded-lg p-3 border border-gray-700/30">
                            <div class="text-gray-400 text-xs font-semibold mb-2">Neutral</div>
                            <div class="text-xs text-gray-300 space-y-0.5">
                                <div>Equities: 45-55%</div>
                                <div>Bonds: 35-45%</div>
                                <div>Commodities: 5-10%</div>
                                <div>Cash: 0-5%</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Historical Regime Timeline -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <h3 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-history mr-2 text-blue-400"></i>Historical Regime Transitions
                    </h3>
                    <div class="relative h-64 mb-4">
                        <canvas id="regimeTimelineChart"></canvas>
                    </div>
                    <div class="mt-4 text-sm text-gray-400">
                        <p>Shows the evolution of economic regimes over time. Regime changes are calculated based on 3-month moving averages of composite growth (IP + PMI + CFNAI-MA3) and Core PCE inflation.</p>
                    </div>
                </div>

                <!-- Growth vs Inflation Scatter Over Time -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-semibold text-white">
                            <i class="fas fa-chart-scatter mr-2 text-blue-400"></i>Full Historical Growth vs Inflation
                        </h3>
                        <div class="flex items-center gap-3">
                            <label class="flex items-center text-xs text-gray-400 cursor-pointer">
                                <input type="checkbox" id="showActualValues" class="w-3 h-3 mr-1.5 rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500 focus:ring-1">
                                <span>Show Actual Values</span>
                            </label>
                            <button id="zoom2Years" class="px-3 py-1.5 text-xs bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors">
                                <i class="fas fa-search-plus mr-1"></i>Zoom to 2 Years
                            </button>
                        </div>
                    </div>
                    <p class="text-gray-400 text-sm mb-4">Complete historical view showing all available data points colored by regime. Useful for understanding long-term patterns and the full distribution of economic conditions.</p>
                    <div class="relative h-96">
                        <canvas id="growthInflationChart"></canvas>
                    </div>
                    <div class="mt-4 text-sm text-gray-400">
                        <p><strong>Purpose:</strong> Shows the complete historical relationship between growth and Core PCE inflation across all time periods. Unlike the quadrant chart (which focuses on recent 24 months), this chart displays the full dataset to reveal long-term patterns, regime frequency, and historical context. Uses Core PCE (excludes food and energy) as it's the Fed's preferred inflation measure.</p>
                    </div>
                </div>

                <!-- Regime Statistics -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <h3 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-chart-bar mr-2 text-blue-400"></i>Regime Statistics
                    </h3>
                    <div id="regimeStats" class="grid grid-cols-1 md:grid-cols-5 gap-4">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Historical Regime Statistics -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <h3 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-database mr-2 text-blue-400"></i>Historical Statistics by Regime
                    </h3>
                    <div id="historicalRegimeStats" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Asset Class Performance by Regime -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 border border-gray-700/50">
                    <h3 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-chart-line mr-2 text-blue-400"></i>Asset Class Performance by Regime
                    </h3>
                    <div class="flex justify-between items-center mb-4">
                        <p class="text-gray-400 text-sm">Historical monthly returns and statistics for major asset classes during each economic regime</p>
                        <label class="flex items-center text-xs text-gray-400 cursor-pointer">
                            <input type="checkbox" id="annualizeReturns" class="w-3 h-3 mr-1.5 rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500 focus:ring-1">
                            <span>Annualize</span>
                        </label>
                    </div>
                    
                    <!-- Data Sources Info -->
                    <div class="bg-gray-900/50 rounded-lg p-4 mb-4 border border-gray-700/30">
                        <h4 class="text-sm font-semibold text-gray-300 mb-2">Data Sources:</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs text-gray-400">
                            <div><strong class="text-green-400">Stocks:</strong> VTI ETF (Total Stock Market) - Twelve Data API</div>
                            <div><strong class="text-blue-400">Bonds:</strong> AGG ETF (Aggregate Bond) - Twelve Data API</div>
                            <div><strong class="text-yellow-400">Commodities:</strong> WTI Crude Oil (DCOILWTICO) - FRED API</div>
                            <div><strong class="text-gray-400">Cash:</strong> 3-Month T-Bill Rate (TB3MS) - FRED API</div>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Note: All returns are <strong>total returns</strong> (price + dividends/income). Stocks include dividend yield, bonds include coupon income. Commodities use WTI oil as proxy (price return only).</p>
                        <p class="text-xs text-purple-400 mt-2"><strong>Recommended Portfolio:</strong> Historical performance of the recommended tactical allocation for each regime, calculated using the midpoint of the allocation ranges (e.g., 60-70% stocks = 65% weight). Portfolio returns are the weighted average of individual asset class returns during each regime period.</p>
                    </div>
                    
                    <div id="assetClassPerformance" class="space-y-4">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Stocks-Bonds Rolling Correlation Chart -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-6 border border-gray-700/50">
                    <h3 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-chart-line mr-2 text-blue-400"></i>Rolling Correlation: Stocks vs Bonds
                    </h3>
                    <p class="text-gray-400 text-sm mb-4">12-month rolling correlation between S&P 500 price returns and AGG (Aggregate Bond ETF) price returns. Positive correlation means they move together; negative means they move in opposite directions.</p>
                    <div class="relative h-96 mb-4">
                        <canvas id="stocksBondsCorrelationChart"></canvas>
                    </div>
                    
                    <!-- Explanatory Content -->
                    <div class="bg-gray-900/50 rounded-lg p-4 border border-gray-700/30 mb-4">
                        <h4 class="text-sm font-semibold text-gray-300 mb-3">Understanding Stock-Bond Correlation:</h4>
                        <div class="space-y-3 text-xs text-gray-400">
                            <div>
                                <strong class="text-yellow-400">Negative Correlation (Traditional Relationship):</strong>
                                <ul class="list-disc list-inside ml-2 mt-1 space-y-1 text-gray-500">
                                    <li>Historically, stocks and bonds have often moved in opposite directions (negative correlation)</li>
                                    <li>During economic uncertainty or market stress, investors seek "flight to quality" - selling stocks and buying bonds</li>
                                    <li>Rising bond prices (falling yields) often coincide with falling stock prices during risk-off periods</li>
                                    <li>This creates natural portfolio diversification benefits</li>
                                </ul>
                            </div>
                            <div>
                                <strong class="text-orange-400">Positive Correlation (Changing Dynamics):</strong>
                                <ul class="list-disc list-inside ml-2 mt-1 space-y-1 text-gray-500">
                                    <li>When both assets move together, diversification benefits are reduced</li>
                                    <li>Often occurs during periods of rising inflation expectations or monetary policy shifts</li>
                                    <li>Inflation concerns can hurt both stocks (higher costs, lower margins) and bonds (erodes real returns)</li>
                                    <li>Aggressive monetary tightening can depress both asset classes simultaneously</li>
                                </ul>
                            </div>
                            <div>
                                <strong class="text-blue-400">Why Correlations Change:</strong>
                                <ul class="list-disc list-inside ml-2 mt-1 space-y-1 text-gray-500">
                                    <li><strong>Inflation Regime:</strong> High inflation periods often see positive correlation as both assets suffer</li>
                                    <li><strong>Monetary Policy:</strong> Central bank actions (rate cuts/hikes) can drive correlation in different directions</li>
                                    <li><strong>Economic Growth:</strong> Strong growth with low inflation = negative correlation; stagflation = positive</li>
                                    <li><strong>Market Stress:</strong> During crises, correlation can spike positive as "everything falls together"</li>
                                    <li><strong>Global Factors:</strong> International capital flows and currency movements influence correlation</li>
                                    <li><strong>Regime Shifts:</strong> The transition between different economic regimes (see TAA framework above) affects correlation patterns</li>
                                </ul>
                            </div>
                            <div>
                                <strong class="text-green-400">Investment Implications:</strong>
                                <ul class="list-disc list-inside ml-2 mt-1 space-y-1 text-gray-500">
                                    <li>Negative correlation periods: Traditional 60/40 portfolios work well for diversification</li>
                                    <li>Positive correlation periods: May need alternative assets (commodities, real estate, TIPS) for diversification</li>
                                    <li>Monitoring correlation helps assess portfolio risk and adjust allocation strategies</li>
                                    <li>Correlation can be regime-dependent - align with TAA framework for tactical adjustments</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-900/50 rounded-lg p-4 border border-gray-700/30">
                        <h4 class="text-sm font-semibold text-gray-300 mb-2">Data Sources:</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs text-gray-400">
                            <div><strong class="text-green-400">Stocks:</strong> S&P 500 Index (SP500) - FRED API</div>
                            <div><strong class="text-blue-400">Bonds:</strong> AGG ETF (Aggregate Bond) - Twelve Data API</div>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Correlation calculated using monthly price returns for both stocks and bonds over a 12-month rolling window. Both series use percentage price changes (not yield changes for bonds).</p>
                    </div>
                </div>
            </div>
        </div> <!-- End TAA Tab -->

        <!-- Debt and Fiscal Tab -->
        <div id="tab-content-fiscal" class="tab-content hidden">
            <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-10 border border-gray-700/50">
                <h2 class="text-xl font-semibold mb-4 text-white">
                    <i class="fas fa-file-invoice-dollar mr-2 text-blue-400"></i>Debt & Fiscal Dashboard
                </h2>
                <p class="text-gray-400 text-sm mb-6">U.S. Federal Debt, Deficit, and Government Spending Trends</p>
                
                <div id="fiscalLoading" class="text-center py-8">
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading fiscal data from FRED...</p>
                </div>

                <div id="fiscalContent" class="hidden">
                    <!-- Fiscal Summary Cards -->
                    <div class="grid grid-cols-1 md:grid-cols-6 gap-4 mb-8">
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Total Public Debt</div>
                            <div id="totalDebtValue" class="text-xl font-bold text-white mb-1">--</div>
                            <div id="totalDebtTrend" class="text-[10px]">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Debt / GDP</div>
                            <div id="debtGdpValue" class="text-xl font-bold text-white mb-1">--</div>
                            <div id="debtGdpTrend" class="text-[10px]">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Tax Receipts</div>
                            <div id="taxReceiptsValue" class="text-xl font-bold text-white mb-1">--</div>
                            <div id="taxReceiptsTrend" class="text-[10px]">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Monthly Deficit</div>
                            <div id="annualDeficitValue" class="text-xl font-bold text-white mb-1">--</div>
                            <div id="annualDeficitTrend" class="text-[10px]">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Interest Cost</div>
                            <div id="interestPaymentsValue" class="text-xl font-bold text-white mb-1">--</div>
                            <div id="interestPaymentsTrend" class="text-[10px]">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg border-l-red-500/50">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Interest Squeeze</div>
                            <div id="interestSqueezeValue" class="text-xl font-bold text-red-400 mb-1">--</div>
                            <div class="text-[10px] text-gray-500 uppercase">of Tax Revenue</div>
                        </div>
                    </div>

                    <!-- Debt Trends -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-chart-line mr-2"></i>Federal Debt Trend
                            </h3>
                            <div class="relative h-80">
                                <canvas id="debtTrendChart"></canvas>
                            </div>
                            <div id="debtTrendChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Tracks the total outstanding public debt issued by the U.S. Treasury. Rapid increases in debt can lead to higher interest service costs and potential crowding out of private investment.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-balance-scale mr-2"></i>12-Month Rolling Deficit / Surplus (Treasury MTS)
                            </h3>
                            <div class="relative h-80">
                                <canvas id="deficitChart"></canvas>
                            </div>
                            <div id="deficitChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> 12-month rolling sum of the monthly budget balance from the Treasury’s Monthly Treasury Statement (MTS). This smooths seasonality while still updating as new monthly data arrives.
                            </p>
                        </div>
                    </div>

                    <!-- Spending & Interest -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-money-bill-wave mr-2"></i>Outlays vs Receipts
                            </h3>
                            <div class="relative h-80">
                                <canvas id="spendingChart"></canvas>
                            </div>
                            <div id="spendingChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Receipts (Tax revenue) vs Outlays (Government spending). The widening gap represents the fiscal deficit.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-percentage mr-2"></i>Interest Service Cost
                            </h3>
                            <div class="relative h-80">
                                <canvas id="interestCostChart"></canvas>
                            </div>
                            <div id="interestCostChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Annualized interest payments on the federal debt. As interest rates rise, this cost can become a larger percentage of total government expenditures.
                            </p>
                        </div>
                    </div>

                    <!-- High-Signal Fiscal Metrics -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-hand-holding-usd mr-2"></i>The "Interest Squeeze"
                            </h3>
                            <div class="relative h-80">
                                <canvas id="interestSqueezeChart"></canvas>
                            </div>
                            <div id="interestSqueezeChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Federal Interest Payments as a % of Current Tax Receipts. This shows what percentage of every tax dollar collected is immediately paid to bondholders. A rising ratio implies "fiscal dominance."
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-print mr-2"></i>"Stealth Monetization"
                            </h3>
                            <div class="relative h-80">
                                <canvas id="stealthMonetizationChart"></canvas>
                            </div>
                            <div id="stealthMonetizationChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Fed-held Debt as % of Total Public Debt. A rising ratio suggests the Fed is increasingly the "buyer of last resort," a precursor to long-term inflation.
                            </p>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-balance-scale-right mr-2"></i>The "Sustainability Spread" (r-g)
                            </h3>
                            <div class="relative h-80">
                                <canvas id="sustainabilitySpreadChart"></canvas>
                            </div>
                            <div id="sustainabilitySpreadChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> 10-Year Treasury Yield (r) minus Nominal GDP Growth (g). When r > g, the "fiscal math" becomes dangerous as debt grows faster than the economy's ability to service it.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-twins mr-2"></i>The "Twin Deficits" View
                            </h3>
                            <div class="relative h-80">
                                <canvas id="twinDeficitsChart"></canvas>
                            </div>
                            <div id="twinDeficitsChartLatest" class="text-gray-400 text-[10px] mt-2 mb-2"></div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Federal Budget Balance vs. Current Account Balance (both as % of GDP). When both are deeply negative, the country is borrowing from the world to fund consumption.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div> <!-- End Fiscal Tab -->

        <div id="tab-content-employment" class="tab-content hidden">
            <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-10 border border-gray-700/50">
                <h2 class="text-xl font-semibold mb-4 text-white">
                    <i class="fas fa-users-cog mr-2 text-blue-400"></i>Labor Market & Employment Dashboard
                </h2>
                <p class="text-gray-400 text-sm mb-6">Structural Health, Efficiency, and Wage Dynamics</p>
                
                <div id="employmentLoading" class="text-center py-8">
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading employment data from FRED & BLS...</p>
                </div>

                <div id="employmentContent" class="hidden">
                    <!-- Employment Summary Cards -->
                    <div class="grid grid-cols-1 md:grid-cols-6 gap-4 mb-8">
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Labor Tightness (V/U)</div>
                            <div id="tightnessRatioValue" class="text-2xl font-bold text-white mb-1">--</div>
                            <div id="tightnessRatioTrend" class="text-xs">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Unemployment (U-3)</div>
                            <div id="employmentUnrateValue" class="text-2xl font-bold text-white mb-1">--</div>
                            <div id="employmentUnrateTrend" class="text-xs">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Underemployment (U-6)</div>
                            <div id="u6RateValue" class="text-2xl font-bold text-white mb-1">--</div>
                            <div id="u6RateTrend" class="text-xs">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Participation Rate</div>
                            <div id="participationRateValue" class="text-2xl font-bold text-white mb-1">--</div>
                            <div id="participationRateTrend" class="text-xs">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Real Wage Growth</div>
                            <div id="realWageGrowthValue" class="text-2xl font-bold text-white mb-1">--</div>
                            <div id="realWageGrowthTrend" class="text-xs">--</div>
                        </div>
                        <div class="bg-gray-850 rounded-xl p-5 border border-gray-700/50 shadow-lg">
                            <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Quits Rate</div>
                            <div id="quitsRateValue" class="text-2xl font-bold text-white mb-1">--</div>
                            <div id="quitsRateTrend" class="text-xs">--</div>
                        </div>
                    </div>

                    <!-- Employment Charts -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-exclamation-triangle mr-2"></i>Weekly Initial Claims
                            </h3>
                            <div class="relative h-80">
                                <canvas id="claimsChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Initial weekly jobless claims. A persistent rise above the <span class="text-red-400 font-bold">300k</span> threshold or a sharp break above the <span class="text-yellow-400 font-bold">4-week moving average</span> is often a leading indicator of economic contraction.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                                <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                    <i class="fas fa-hourglass-half mr-2"></i>Continuing Claims
                                </h3>
                                <div class="flex space-x-2">
                                    <button onclick="window.toggleContClaimsZoom('all')" id="btn-contclaims-all" class="px-3 py-1 text-[10px] font-bold rounded bg-gray-800 text-gray-400 border border-gray-700 hover:bg-gray-700 transition-all">ALL DATA</button>
                                    <button onclick="window.toggleContClaimsZoom('postcovid')" id="btn-contclaims-postcovid" class="px-3 py-1 text-[10px] font-bold rounded bg-blue-600 text-white border border-blue-500 transition-all">POST-COVID</button>
                                </div>
                            </div>
                            <div class="relative h-80">
                                <canvas id="contClaimsChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Continued Claims (Insured Unemployment). While Initial Claims track new layoffs, Continuing Claims measure the "stickiness" of unemployment. A rising trend here indicates workers are finding it harder to get rehired.
                            </p>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-thermometer-half mr-2"></i>Labor Market Tightness (V/U)
                            </h3>
                            <div class="relative h-80">
                                <canvas id="tightnessChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Job Openings per Unemployed Person. A ratio > 1.0 indicates a "tight" market favoring workers; < 1.0 indicates a "loose" market favoring employers.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-shopping-cart mr-2"></i>Real Wage Growth
                            </h3>
                            <div class="relative h-80">
                                <canvas id="realWageChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Hourly Earnings adjusted for CPI Inflation. Negative values mean inflation is eroding purchasing power despite nominal wage gains.
                            </p>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-door-open mr-2"></i>Quits vs. Wage Growth
                            </h3>
                            <div class="relative h-80">
                                <canvas id="quitsWageChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> The "Take This Job and Shove It" index. High quit rates usually lead wage growth by ~6 months as workers move to higher-paying roles.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-project-diagram mr-2"></i>The Beveridge Curve
                            </h3>
                            <div class="relative h-80">
                                <canvas id="beveridgeChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Job Openings Rate vs. Unemployment Rate. An outward shift (right) suggests structural mismatch; an inward shift (left) suggests better matching efficiency.
                            </p>
                        </div>
                    </div>

                    <!-- Headline Labor Market Charts -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-chart-line mr-2"></i>Monthly Change in Employment
                            </h3>
                            <div id="employmentMonthlyChangeLatestMeta" class="text-gray-400 text-[10px] -mt-2 mb-3"></div>
                            <div class="relative h-80">
                                <canvas id="employmentMonthlyChangeChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Monthly change in Nonfarm Payrolls (PAYEMS). Bars above/below zero show job gains/losses.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-user-check mr-2"></i>Labor Force Participation Rate
                            </h3>
                            <div id="participationRateLatestMeta" class="text-gray-400 text-[10px] -mt-2 mb-3"></div>
                            <div class="relative h-80">
                                <canvas id="participationRateChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Share of the population that is working or actively looking for work (CIVPART).
                            </p>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-users mr-2"></i>Total Number Employed
                            </h3>
                            <div id="totalEmployedLatestMeta" class="text-gray-400 text-[10px] -mt-2 mb-3"></div>
                            <div class="relative h-80">
                                <canvas id="totalEmployedChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Household Survey employment level (CE16OV). Tracks total employed persons.
                            </p>
                        </div>
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-percent mr-2"></i>Unemployment Rate
                            </h3>
                            <div id="unemploymentRateLatestMeta" class="text-gray-400 text-[10px] -mt-2 mb-3"></div>
                            <div class="relative h-80">
                                <canvas id="unemploymentRateChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Headline unemployment rate (UNRATE). A rising trend typically signals weakening labor demand.
                            </p>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                                <i class="fas fa-tachometer-alt mr-2"></i>Labor Productivity (Output per Hour)
                            </h3>
                            <div id="productivityLatestMeta" class="text-gray-400 text-[10px] -mt-2 mb-3"></div>
                            <div class="relative h-80">
                                <canvas id="productivityChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Nonfarm business sector output per hour (OPHNFB, index 2017=100). Rising productivity allows wage gains without inflation. YoY % change shows acceleration or deceleration.
                            </p>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 gap-6 mb-6">
                        <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                            <div class="flex justify-between items-center mb-4 border-b pb-3 border-gray-700/50">
                                <h3 class="text-blue-400 text-lg uppercase tracking-widest font-semibold">
                                    <i class="fas fa-industry mr-2"></i>Employment by Major Sector
                                </h3>
                                <div class="flex space-x-2">
                                    <button onclick="window.toggleSectorChartMode('cumulative')" id="btn-sector-cumulative" class="px-3 py-1 text-[10px] font-bold rounded bg-blue-600 text-white border border-blue-500 transition-all">CUMULATIVE %</button>
                                    <button onclick="window.toggleSectorChartMode('roc')" id="btn-sector-rate" class="px-3 py-1 text-[10px] font-bold rounded bg-gray-800 text-gray-400 border border-gray-700 hover:bg-gray-700 transition-all">3YR ROC</button>
                                </div>
                            </div>
                            <div class="relative h-96">
                                <canvas id="sectorEmploymentChart"></canvas>
                            </div>
                            <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                                <strong>Context:</strong> Toggle between cumulative percentage change since start of data or the 3-year rolling rate of change. Shows which sectors are leading or lagging in job creation.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div> <!-- End Employment Tab -->

        <div id="tab-content-ai-insights" class="tab-content hidden">
            <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-10 border border-gray-700/50">
                <div class="flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
                    <div>
                        <h2 class="text-2xl font-bold text-white flex items-center">
                            <i class="fas fa-robot mr-3 text-blue-400"></i>AI Market Intelligence
                        </h2>
                        <p class="text-gray-400 text-sm mt-1">Cross-domain synthesis and predictive regime analysis</p>
                    </div>
                    <div class="flex gap-4">
                        <button onclick="generateAIInsights()" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-bold transition-all shadow-lg flex items-center">
                            <i class="fas fa-sync-alt mr-2"></i>Refresh Insights
                        </button>
                    </div>
                </div>

                <!-- Stoplight Framework -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                    <div class="bg-gray-850 rounded-xl p-6 border border-gray-700/50">
                        <h3 class="text-gray-400 text-xs uppercase tracking-widest mb-4 font-bold">Economic Health</h3>
                        <div id="economyStoplight" class="flex items-center gap-4">
                            <div class="w-12 h-12 rounded-full bg-gray-700 animate-pulse"></div>
                            <div class="flex-1 h-4 bg-gray-700 rounded w-1/2 animate-pulse"></div>
                        </div>
                    </div>
                    <div class="bg-gray-850 rounded-xl p-6 border border-gray-700/50">
                        <h3 class="text-gray-400 text-xs uppercase tracking-widest mb-4 font-bold">Market Risk</h3>
                        <div id="marketStoplight" class="flex items-center gap-4">
                            <div class="w-12 h-12 rounded-full bg-gray-700 animate-pulse"></div>
                            <div class="flex-1 h-4 bg-gray-700 rounded w-1/2 animate-pulse"></div>
                        </div>
                    </div>
                </div>

                <!-- Analysis Grid -->
                <div id="aiInsightsLoading" class="text-center py-20 hidden">
                    <div class="inline-block animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mb-4"></div>
                    <p class="text-blue-400 font-semibold text-lg italic">AI is processing cross-domain signals...</p>
                </div>

                <div id="aiInsightsContent" class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <div class="lg:col-span-2 space-y-6">
                        <!-- Summary Section -->
                        <div class="bg-gray-850 rounded-xl p-6 border border-gray-700/50">
                            <h3 class="text-blue-400 font-bold mb-4 flex items-center">
                                <i class="fas fa-file-alt mr-2"></i>Executive Summary
                            </h3>
                            <div id="aiExecutiveSummary" class="text-gray-200 leading-relaxed text-sm space-y-4 italic">
                                Loading insights...
                            </div>
                        </div>

                        <!-- Key Risks & Tailwinds -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="bg-gray-850/50 rounded-xl p-6 border border-red-900/20">
                                <h3 class="text-red-400 font-bold mb-3 text-sm flex items-center">
                                    <i class="fas fa-exclamation-triangle mr-2"></i>Primary Risk Factors
                                </h3>
                                <ul id="aiRisksList" class="text-gray-400 text-xs space-y-2 list-disc list-inside">
                                    <li>Analyzing debt levels...</li>
                                    <li>Scanning liquidity signals...</li>
                                </ul>
                            </div>
                            <div class="bg-gray-850/50 rounded-xl p-6 border border-green-900/20">
                                <h3 class="text-green-400 font-bold mb-3 text-sm flex items-center">
                                    <i class="fas fa-arrow-up mr-2"></i>Primary Tailwinds
                                </h3>
                                <ul id="aiTailwindsList" class="text-gray-400 text-xs space-y-2 list-disc list-inside">
                                    <li>Checking employment strength...</li>
                                    <li>Reviewing growth metrics...</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column: Sector Rotations & Metrics -->
                    <div class="space-y-6">
                        <div class="bg-gray-850 rounded-xl p-6 border border-gray-700/50">
                            <h3 class="text-blue-400 font-bold mb-4 text-sm flex items-center">
                                <i class="fas fa-crosshairs mr-2"></i>Strategic Tilt Recommendations
                            </h3>
                            <div id="aiRecommendations" class="space-y-3">
                                <div class="p-3 bg-gray-900 rounded-lg border border-gray-700">
                                    <div class="flex justify-between mb-1">
                                        <span class="text-xs text-gray-400">Equities</span>
                                        <span class="text-xs font-bold text-gray-200">NEUTRAL</span>
                                    </div>
                                    <div class="w-full bg-gray-700 h-1.5 rounded-full">
                                        <div class="bg-yellow-500 h-1.5 rounded-full" style="width: 50%"></div>
                                    </div>
                                </div>
                                <!-- More recommendations here -->
                            </div>
                        </div>

                        <div class="bg-gray-850 rounded-xl p-6 border border-gray-700/50">
                            <h3 class="text-blue-400 font-bold mb-4 text-sm flex items-center">
                                <i class="fas fa-tachometer-alt mr-2"></i>Cross-Domain Confidence
                            </h3>
                            <div class="flex justify-center mb-3">
                                <div class="relative w-32 h-32">
                                    <svg class="w-full h-full" viewBox="0 0 36 36">
                                        <path class="text-gray-700" stroke-width="3" stroke="currentColor" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                                        <path id="aiConfidencePath" class="text-blue-500" stroke-width="3" stroke-dasharray="0, 100" stroke-linecap="round" stroke="currentColor" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                                        <text x="18" y="20.35" class="text-[8px] font-bold fill-white" text-anchor="middle" id="aiConfidenceText">0%</text>
                                    </svg>
                                </div>
                            </div>
                            <div class="text-xs text-gray-400 text-center px-2">
                                <p class="mb-1"><strong class="text-gray-300">Measures synthesis reliability:</strong></p>
                                <p class="text-[10px] leading-tight">Data completeness, signal alignment, quality, and cross-domain consistency</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div> <!-- End AI Insights Tab -->

        <!-- Warsh v Powell Tab -->
        <div id="tab-content-warsh-powell" class="tab-content hidden">
            <div id="warshLoading" class="text-center py-20">
                <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                <p class="text-blue-400 mt-4 text-lg font-semibold">Loading Warsh Regime Change Dashboard...</p>
            </div>
            <div id="warshContent" class="hidden">
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 mb-10 border border-gray-700/50">
                    <h2 class="text-xl font-semibold mb-4 text-white">
                        <i class="fas fa-balance-scale mr-2 text-blue-400"></i>Warsh Regime Change Dashboard
                    </h2>
                    <p class="text-gray-400 text-sm mb-6">Monitor the shift in Fed policy philosophy: Warsh's AI-disinflationary, balance-sheet-shrinking approach vs. Powell's forward-guidance framework.</p>

                    <!-- 1. Productivity Spread (AI Impact) -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-robot mr-2"></i>1. Productivity Spread (AI Impact)
                        </h3>
                        <p class="text-gray-400 text-xs mb-4">Warsh's primary justification for lower rates: AI is a disinflationary force. If productivity rises while inflation remains stable or falls, Warsh will likely slash rates more aggressively than Powell.</p>
                        <div class="text-gray-300 text-sm mb-2">Latest: Productivity <span id="warshProductivityLatest" class="text-white font-semibold">--</span> | Core CPI YoY <span id="warshCoreCPILatest" class="text-white font-semibold">--</span></div>
                        <div class="relative h-80">
                            <canvas id="warshProductivityChart"></canvas>
                        </div>
                        <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                            <strong>Signal:</strong> Rising productivity + stable/falling inflation = Warsh "green light" for aggressive rate cuts.
                        </p>
                    </div>

                    <!-- 2. Balance Sheet Velocity -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-landmark mr-2"></i>2. Balance Sheet Velocity (H.4.1)
                        </h3>
                        <p class="text-gray-400 text-xs mb-4">Warsh believes a large balance sheet distorts markets. A steepening downward curve while Fed Funds drops = "Warsh Mix" in action.</p>
                        <div class="text-gray-300 text-sm mb-2">Fed Total Assets: <span id="warshBalanceSheetLatest" class="text-white font-semibold">--</span></div>
                        <div class="relative h-80">
                            <canvas id="warshBalanceSheetChart"></canvas>
                        </div>
                        <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                            <strong>Signal:</strong> Balance sheet shrinking faster + Fed Funds dropping = Warsh's preferred QT + rate-cut combination.
                        </p>
                    </div>

                    <!-- 3. Term Premium & Bond Volatility -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-chart-area mr-2"></i>3. Term Premium & Bond Volatility
                        </h3>
                        <p class="text-gray-400 text-xs mb-4">Warsh has criticized "forward guidance." Without Powell's "Dot Plot" hand-holding, bond markets may become more volatile.</p>
                        <div class="text-gray-300 text-sm mb-2">Kim-Wright 10Y Term Prem: <span id="warshTermPremLatest" class="text-white font-semibold">--</span> | KCPRU: <span id="warshKCPRULatest" class="text-white font-semibold">--</span></div>
                        <div class="relative h-80">
                            <button id="warshTermPremZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="warshTermPremiumChart"></canvas>
                        </div>
                        <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                            <strong>Signal:</strong> Rising volatility suggests the market is struggling to predict the Fed without forward guidance.
                        </p>
                    </div>

                    <!-- 3b. 10Y Yield & Equity VIX -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-chart-line mr-2"></i>10Y Treasury Yield & Equity VIX
                        </h3>
                        <p class="text-gray-400 text-xs mb-4">10-year Treasury yield and equity market volatility (VIX).</p>
                        <div class="text-gray-300 text-sm mb-2">10Y Treasury: <span id="warsh10YLatest" class="text-white font-semibold">--</span> | VIX: <span id="warshVIXLatest" class="text-white font-semibold">--</span></div>
                        <div class="relative h-80">
                            <button id="warsh10YVIXZoom24" class="absolute top-2 right-2 z-10 px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 transition-colors" title="Zoom in to last 2 years">Zoom 2Y</button>
                            <canvas id="warsh10YVIXChart"></canvas>
                        </div>
                    </div>

                    <!-- 4. Real Interest Rates vs. Neutral -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 mb-6 border border-gray-700/50 fade-in">
                        <h3 class="text-blue-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-percentage mr-2"></i>4. Real Interest Rates vs. "Neutral"
                        </h3>
                        <p class="text-gray-400 text-xs mb-4">Warsh argues "real" rates (nominal minus inflation expectations) are too high for Main Street. <strong class="text-cyan-400">Warsh views:</strong> (1) Nominal neutral is 2–2.5%, particularly when the balance sheet is shrinking. (2) If productivity is rising, real Fed funds should be near 0.</p>
                        <div class="text-gray-300 text-sm mb-2">Real Rate (Fed Funds - 1Y Inf Exp): <span id="warshRealRateLatest" class="text-white font-semibold">--</span> | Nominal Fed Funds: <span id="warshNominalFedLatest" class="text-white font-semibold">--</span></div>
                        <div class="relative h-80">
                            <canvas id="warshRealRateChart"></canvas>
                        </div>
                        <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                            <strong>Left axis:</strong> Real rate (Fed Funds − inflation exp). Shaded 0–0.5% = real neutral. Zero = Warsh target when productivity rising. <strong>Right axis:</strong> Nominal Fed Funds. Shaded 2–2.5% = Warsh nominal neutral (esp. if BS shrinking). <strong>Signal:</strong> Real above band = restrictive; nominal above 2.5% = restrictive.
                        </p>
                    </div>

                    <!-- 5. M2 Money Supply (Pro Tip) -->
                    <div class="bg-gray-850 rounded-xl shadow-lg p-6 border border-gray-700/50 fade-in">
                        <h3 class="text-yellow-400 text-lg uppercase tracking-widest mb-4 font-semibold border-b pb-3 border-gray-700/50">
                            <i class="fas fa-coins mr-2"></i>Pro Tip: M2 Money Supply
                        </h3>
                        <p class="text-gray-400 text-xs mb-4">Warsh has historically been a "money supply hawk." Any sudden spike in M2 might force him to revert to hawkish instincts despite his current low-rate alignment.</p>
                        <div class="text-gray-300 text-sm mb-2">M2 (Billions): <span id="warshM2Latest" class="text-white font-semibold">--</span></div>
                        <div class="relative h-80">
                            <canvas id="warshM2Chart"></canvas>
                        </div>
                        <p class="text-gray-500 text-[10px] mt-4 leading-relaxed">
                            <strong>Watch:</strong> M2 spike = potential Warsh hawkish reversion.
                        </p>
                    </div>
                </div>
            </div>
        </div> <!-- End Warsh v Powell Tab -->

    </main>

    <script>
        // Tab switching function - define early to ensure it's available for onclick handlers
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active', 'text-blue-400', 'border-blue-500');
                btn.classList.add('text-gray-400', 'border-transparent');
            });
            
            // Show selected tab content
            const selectedTab = document.getElementById(`tab-content-${tabName}`);
            if (selectedTab) {
                selectedTab.classList.remove('hidden');
            }
            
            // Add active class to selected button
            const selectedBtn = document.getElementById(`tab-${tabName}`);
            if (selectedBtn) {
                selectedBtn.classList.add('active', 'text-blue-400', 'border-blue-500');
                selectedBtn.classList.remove('text-gray-400', 'border-transparent');
            }

            // Update footer description based on tab
            updateFooterDescription(tabName);
            
            // Load macro data if switching to macro tab
            if (tabName === 'macro' && !window.macroDataLoaded) {
                loadMacroData();
            }
            
            // Load interest rates data if switching to interest rates tab
            if (tabName === 'interest' && !window.interestDataLoaded) {
                loadInterestRatesData();
            }
            
            // Load TAA data if switching to TAA tab
            if (tabName === 'taa' && !window.taaDataLoaded) {
                loadTAAData();
            }

            // Load Fiscal data if switching to fiscal tab
            if (tabName === 'fiscal' && !window.fiscalDataLoaded) {
                loadFiscalData();
            }

            // Load Employment data if switching to employment tab
            if (tabName === 'employment' && !window.employmentDataLoaded) {
                loadEmploymentData();
            }

            // Load AI Insights if switching to AI Insights tab
            if (tabName === 'ai-insights') {
                generateAIInsights();
            }

            // Load Warsh v Powell data if switching to that tab
            if (tabName === 'warsh-powell') {
                if (!window.warshDataLoaded) {
                    loadWarshPowellData();
                } else {
                    setTimeout(setupWarshZoomButtons, 100);
                }
            }
        }

        // Mapping of tab names to their footer descriptions
        const tabDescriptions = {
            'quantum': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">Multi-Timeframe Dynamic Weight Calibration</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">This system uses <strong class="text-cyan-400 text-xs">machine learning</strong> to determine optimal indicator weights by analyzing historical relationships between technical indicators and future price returns. The system evaluates seven indicators (<strong class="text-white">MACD Monthly</strong>, <strong class="text-white">MACD Daily</strong>, <strong class="text-white">RSI</strong>, <strong class="text-white">ADX/DI</strong>, <strong class="text-white">Bollinger Bands</strong>, <strong class="text-white">Price vs. 200-DMA Distance</strong>, and <strong class="text-white">50-DMA Z-Score</strong>) using a user-selected forecast horizon (10, 30, 60, or 90 days).</span>
                    <br><br>
                    <strong class="text-white text-xs">Model Training Process:</strong>
                    <span class="text-gray-100 text-xs">For each historical day, the system collects raw indicator scores (normalized to -1 to +1 range) and the corresponding forward return for the user-selected forecast horizon (10, 30, 60, or 90 days). A machine learning model is trained to predict forward returns from these indicator scores, learning which indicators are most predictive for that specific time horizon. The model is trained specifically on the selected forecast horizon to optimize performance for the user's chosen investment timeframe.</span>
                    <br><br>
                    <strong class="text-white text-xs">Available Machine Learning Models:</strong>
                    <ul class="list-disc list-inside mt-2 mb-2 space-y-1 text-xs ml-2">
                        <li class="text-gray-100 text-xs"><strong class="text-blue-400 text-xs">Ridge Regression</strong> <span class="text-gray-300 text-xs">(default, faster)</span>: A linear model with L2 regularization that prevents overfitting while maintaining computational efficiency. Extracts weights from model coefficients (absolute values, normalized to sum to 1).</li>
                        <li class="text-gray-100 text-xs"><strong class="text-green-400 text-xs">Gradient Boosting</strong> <span class="text-gray-300 text-xs">(when enabled)</span>: An ensemble of decision trees that captures complex, non-linear relationships. Uses data-driven feature importance with correlation and variance weighting (60% correlation, 40% normalized variance). Weights are determined by predictive power.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-purple-400 text-xs">Elastic Net</strong> <span class="text-gray-300 text-xs">(when enabled)</span>: A linear model combining L1 (Lasso) and L2 (Ridge) regularization, providing a balance between feature selection and coefficient shrinkage. Useful when dealing with correlated indicators.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-yellow-400 text-xs">Regime Switching</strong> <span class="text-gray-300 text-xs">(when enabled)</span>: An ensemble approach that trains separate models for different market regimes (Strong Trend, Weak Trend, Ranging, Transition). The system automatically detects the current regime and uses the appropriate model, with a fallback model for uncertain periods.</li>
                    </ul>
                    <br>
                    <strong class="text-white text-xs">Equal Category Weighting (Optional):</strong>
                    <span class="text-gray-100 text-xs">When the "Equal Category Weighting" option is enabled, the system forces equal total weight distribution across three indicator categories: <strong class="text-cyan-400 text-xs">Trend</strong> (MACD Monthly, MACD Daily), <strong class="text-cyan-400 text-xs">Mean-Reversion</strong> (RSI, Bollinger Bands, 50-DMA Z-Score), and <strong class="text-cyan-400 text-xs">Trend-Following</strong> (ADX/DI, Price vs. 200-DMA). Each category receives 1/3 of total weight, distributed proportionally among its indicators based on their relative importance. When disabled, weights are determined purely by predictive power without category constraints.</span>
                    <br><br>
                    <span class="text-xs"><strong class="text-white text-xs">Weight Extraction and Capping:</strong> <span class="text-gray-100 text-xs">Weights are extracted from the trained model (coefficients for Ridge/Elastic Net, feature importance for Gradient Boosting, consensus weights for Regime Switching). All indicator weights are then capped at 25% maximum (10% for Price vs. 200-DMA) to prevent any single indicator from dominating the signal. This ensures balanced signal generation across all indicators.</span></span>
                    <br><br>
                    <strong class="text-white text-xs">Category Analysis:</strong>
                    <span class="text-gray-100 text-xs">The Category Analysis section displays the total weighted contribution (raw score × weight) for each indicator category, showing what's actually driving the final signal score. This is calculated the same way as the final signal (sum of weighted contributions), making it directly aligned with the model's output. The analysis includes detailed interpretations that account for category-specific characteristics, such as MACD agreement/conflict analysis for the Trend category. Individual indicator breakdowns show both raw scores and their weighted contributions for full transparency.</span>
                    <br><br>
                    <span class="text-xs"><strong class="text-white text-xs">Walk-Forward Validation:</strong> <span class="text-gray-100 text-xs">Validation uses</span> <strong class="text-red-400 text-xs">walk-forward testing</strong><span class="text-gray-100 text-xs">, ensuring the model generalizes beyond the training data and provides realistic performance metrics including hit rates, Sharpe ratios, and win/loss ratios. This method trains the model on historical data and tests it on future unseen data, simulating real-world trading conditions. When Ridge Regression is the primary model, a reference Ridge Regression validation is also provided for comparison.</span></span>
                </p>
            `,
            'macro': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">Macro-Economic Intelligence Framework</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">The Macro Dashboard provides a comprehensive analysis of 24 distinct economic indicators to gauge the health of the U.S. economy. By aggregating data across multiple sectors—including employment, housing, manufacturing, and financial conditions—the system identifies structural economic shifts before they manifest in asset prices.</span>
                    <br><br>
                    <strong class="text-white text-xs">Composite Macro Score:</strong>
                    <span class="text-gray-100 text-xs">Individual indicators are normalized and aggregated into a single <strong class="text-white">Composite Macro Score</strong> ranging from -1.0 (Severe Contraction) to +1.0 (Robust Expansion). This score is weighted by the historical reliability of each indicator in predicting NBER-defined recessions. Components include the <strong class="text-cyan-400 text-xs">Sahm Rule</strong> for real-time recession detection, the <strong class="text-cyan-400 text-xs">Yield Curve</strong> for forward-looking cyclical outlooks, and <strong class="text-cyan-400 text-xs">Real Wage Growth</strong> for consumer strength.</span>
                    <br><br>
                    <strong class="text-white text-xs">Liquidity & Financial Conditions:</strong>
                    <span class="text-gray-100 text-xs">Modern markets are driven by liquidity as much as fundamentals. The framework tracks <strong class="text-orange-400 text-xs">Net Liquidity</strong>—calculated from the Fed's Balance Sheet (WALCL), Treasury General Account (TGA), and Reverse Repo Facility (RRP)—alongside the Chicago Fed's National Financial Conditions Index (NFCI). Tightening financial conditions often precede market drawdowns, while liquidity injections provide support during downturns.</span>
                    <br><br>
                    <strong class="text-white text-xs">Historical Benchmarking:</strong>
                    <span class="text-gray-100 text-xs">All charts include automated <strong class="text-red-400 text-xs">recession shading</strong> based on official NBER dates dating back to 1967. This allows for immediate visual comparison between current indicator behavior and every major economic cycle of the last 50+ years, providing essential context for "soft landing" vs. "hard landing" scenarios.</span>
                </p>
            `,
            'interest': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">Interest Rate & Monetary Policy Mechanics</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">This tab decomposes the complex fixed-income landscape into actionable components. By separating interest rates into inflation expectations, real yields, and risk premiums, the system identifies whether rising rates are driven by economic growth (bullish) or duration risk and inflation uncertainty (bearish).</span>
                    <br><br>
                    <strong class="text-white text-xs">Kim & Wright Term Premium Model:</strong>
                    <span class="text-gray-100 text-xs">The 10-year yield is more than just a single number. We use the <strong class="text-cyan-400 text-xs">Kim & Wright model</strong> to isolate the <strong class="text-white">Term Premium</strong>—the extra compensation investors demand for holding long-term debt instead of rolling over short-term bills. A spiking term premium often signals fiscal concerns or inflation volatility, acting as a headwind for equities regardless of economic growth.</span>
                    <br><br>
                    <strong class="text-white text-xs">Inflation Convergence:</strong>
                    <span class="text-gray-100 text-xs">The system tracks the delta between <strong class="text-yellow-400 text-xs">Market-Implied Inflation</strong> (Breakevens and 5Y-5Y Forwards) and <strong class="text-green-400 text-xs">Realized Inflation</strong> (CPI, PCE, and Dallas Trimmed Mean). Divergences here often signal upcoming shifts in Fed policy. The <strong class="text-white">Dallas Fed Trimmed Mean PCE</strong> is particularly critical as it strips out "noise" to reveal the true underlying trend in core prices.</span>
                    <br><br>
                    <strong class="text-white text-xs">The Fed vs. The Market:</strong>
                    <span class="text-gray-100 text-xs">The <strong class="text-white">FOMC Dot Plot</strong> visualization compares the Fed's own projections for the future Fed Funds Rate against what the market is actually pricing into the 2-Year Treasury. Large gaps between the "Dots" and market yields indicate significant mispricings that often resolve through volatile market adjustments once the Fed or the data forces a convergence.</span>
                </p>
            `,
            'taa': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">Tactical Asset Allocation (TAA) Framework</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">The TAA framework utilizes an evidence-based approach to shift asset class weights based on the prevailing economic environment. Rather than a static "buy and hold" strategy, this model acknowledges that different assets (<strong class="text-white">Stocks</strong>, <strong class="text-white">Bonds</strong>, <strong class="text-white">Gold</strong>, <strong class="text-white">Cash</strong>) perform best in specific macroeconomic regimes.</span>
                    <br><br>
                    <strong class="text-white text-xs">Economic Regime Quadrants:</strong>
                    <span class="text-gray-100 text-xs">We map the economy into one of four distinct regimes based on the rate of change in <strong class="text-cyan-400 text-xs">Growth</strong> (Industrial Production + PMI) and <strong class="text-red-400 text-xs">Inflation</strong> (Core PCE):
                        <ul class="list-disc list-inside mt-2 space-y-1 ml-4 text-gray-100">
                            <li><strong class="text-green-400">Goldilocks</strong> (Growth Up, Inflation Down): Ideal for Equities and Growth assets.</li>
                            <li><strong class="text-yellow-400">Stagflation</strong> (Growth Down, Inflation Up): Favors Commodities and Gold; difficult for stocks and bonds.</li>
                            <li><strong class="text-blue-400">Reflation</strong> (Growth Up, Inflation Up): Good for cyclical Equities; headwind for long-duration Bonds.</li>
                            <li><strong class="text-purple-400">Deflation</strong> (Growth Down, Inflation Down): Favors safe-haven long-term Bonds and Cash.</li>
                        </ul>
                    </span>
                    <br>
                    <strong class="text-white text-xs">Correlation & Diversification:</strong>
                    <span class="text-gray-100 text-xs">The framework monitors <strong class="text-orange-400 text-xs">Rolling Stock-Bond Correlations</strong>. In many regimes, bonds provide a "hedge" for stocks (negative correlation). However, during periods of high inflation volatility, correlations often flip positive, rendering traditional 60/40 portfolios more vulnerable and increasing the necessity for tactical tilts into Gold or Cash.</span>
                    <br><br>
                    <strong class="text-white text-xs">Signal-Driven Exposure:</strong>
                    <span class="text-gray-100 text-xs">Final portfolio allocations are determined by combining the <strong class="text-white">Economic Regime</strong> with the <strong class="text-white">Composite Macro Score</strong>. The system provides target exposure ranges for total market equities (VTI), aggregate bonds (BND), and defensive anchors (GLD/Cash) to optimize the risk-adjusted return across the full business cycle.</span>
                </p>
            `,
            'fiscal': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">U.S. Fiscal & Debt Dynamics</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">This dashboard tracks the <strong class="text-orange-400 text-xs">U.S. Federal Government's</strong> financial health using primary sources from the U.S. Treasury and BEA via the FRED API. It monitors critical dimensions of fiscal policy:</span>
                    <br><br>
                    <strong class="text-white text-xs">Key Indicators:</strong>
                    <ul class="list-disc list-inside mt-2 mb-2 space-y-1 text-xs ml-2">
                        <li class="text-gray-100 text-xs"><strong class="text-blue-400 text-xs">Total Public Debt</strong>: The nominal sum of all outstanding Treasury securities. As this grows, the economy's "debt overhang" can influence long-term interest rates.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-red-400 text-xs">Monthly Deficit</strong>: High-frequency gap between government spending and revenue.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-yellow-400 text-xs">Interest Service Cost</strong>: Actual cash payments made to bondholders. High sensitivity to rates and maturity.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-cyan-400 text-xs">Debt as % of GDP</strong>: A measure of the nation's leverage. High levels are associated with slower structural growth.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-green-400 text-xs">Interest Squeeze</strong>: What percentage of every tax dollar collected is immediately paid to bondholders.</li>
                    </ul>
                </p>
            `,
            'employment': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">Labor Market & Employment Dynamics</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">This dashboard tracks the <strong class="text-orange-400 text-xs">U.S. Labor Market</strong> using high-signal indicators from the BLS and FRED. It moves beyond headline numbers to reveal structural efficiency and worker purchasing power:</span>
                    <br><br>
                    <strong class="text-white text-xs">Key Indicators:</strong>
                    <ul class="list-disc list-inside mt-2 mb-2 space-y-1 text-xs ml-2">
                        <li class="text-gray-100 text-xs"><strong class="text-blue-400 text-xs">Labor Tightness (V/U)</strong>: Job Openings divided by Unemployment Level. A critical Fed metric for labor market "heat."</li>
                        <li class="text-gray-100 text-xs"><strong class="text-red-400 text-xs">Beveridge Curve</strong>: The relationship between job openings and unemployment. Shifts reveal structural changes in labor matching.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-yellow-400 text-xs">Real Wage Growth</strong>: Wage increases adjusted for CPI inflation. Tells you if workers are actually gaining purchasing power.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-cyan-400 text-xs">Quit Rate vs. Wages</strong>: High-confidence workers quit more often, leading to higher wage demands 6 months later.</li>
                        <li class="text-gray-100 text-xs"><strong class="text-green-400 text-xs">Sector Trends</strong>: Decomposition of job growth across Financials, Healthcare, Tech, and more.</li>
                    </ul>
                </p>
            `,
            'warsh-powell': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">Warsh Regime Change Dashboard</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">Monitor the shift in Fed policy philosophy: <strong class="text-cyan-400 text-xs">Warsh's</strong> AI-disinflationary, balance-sheet-shrinking approach vs. <strong class="text-yellow-400 text-xs">Powell's</strong> forward-guidance framework. Key metrics: <strong class="text-blue-400 text-xs">Productivity Spread</strong> (AI impact), <strong class="text-blue-400 text-xs">Balance Sheet Velocity</strong> (H.4.1), <strong class="text-blue-400 text-xs">Term Premium & Bond Volatility</strong>, <strong class="text-blue-400 text-xs">Real Interest Rates</strong> vs. neutral, and <strong class="text-yellow-400 text-xs">M2 Money Supply</strong> (Warsh hawkish reversion risk).</span>
                </p>
            `,
            'ai-insights': `
                <h3 class="text-blue-400 text-lg font-semibold mb-4">AI Market Intelligence Synthesis</h3>
                <p class="text-gray-100 text-xs leading-relaxed">
                    <span class="text-gray-100 text-xs">The AI Insights dashboard utilizes advanced cross-domain analysis to synthesize signals from Macro, Interest Rate, Fiscal, and Employment domains. By analyzing the non-linear relationships between these disparate datasets, the system identifies structural shifts in the market regime that may not be apparent when viewing indicators in isolation.</span>
                    <br><br>
                    <strong class="text-white text-xs">Cross-Domain Synthesis:</strong>
                    <span class="text-gray-100 text-xs">While traditional analysis treats each economic sector as an independent variable, the AI engine evaluates <strong class="text-cyan-400 text-xs">interdependencies</strong>—such as how rising debt service costs (Fiscal) interact with real wage growth (Employment) to impact financial conditions (Macro). This hollistic approach allows for the identification of "convexity" in economic outcomes.</span>
                    <br><br>
                    <strong class="text-white text-xs">Stoplight Framework:</strong>
                    <span class="text-gray-100 text-xs">We utilize a simplified <strong class="text-red-400 text-xs">Red/Yellow/Green</strong> stoplight framework to provide immediate clarity on risk posture. <strong class="text-green-400 text-xs">Green</strong> signals a high-conviction environment for risk expansion, <strong class="text-yellow-400 text-xs">Yellow</strong> indicates a "wait and see" transitional phase with balanced risks, and <strong class="text-red-400 text-xs">Red</strong> marks high-risk environments where capital preservation is prioritized over growth.</span>
                </p>
            `
        };

        function updateFooterDescription(tabName) {
            const footerEl = document.getElementById('footerDescription');
            if (footerEl && tabDescriptions[tabName]) {
                footerEl.innerHTML = tabDescriptions[tabName];
            }
        }
        
        // Also assign to window for compatibility
        window.switchTab = switchTab;
        
        let priceChartInstance = null;
        let dailyMacdChartInstance = null;
        let monthlyMacdChartInstance = null;
        let scoreTimeSeriesChartInstance = null;
        
        // Global recession periods (NBER official dates, used for shading all macro charts)
        // Using official NBER recession dates for accurate historical shading
        const globalRecessionPeriods = [
            { startDate: '1969-12-01', endDate: '1970-11-30' },  // 1969-1970 recession
            { startDate: '1973-11-01', endDate: '1975-03-31' },  // 1973-1975 recession
            { startDate: '1980-01-01', endDate: '1980-07-31' },  // 1980 recession
            { startDate: '1981-07-01', endDate: '1982-11-30' },  // 1981-1982 recession
            { startDate: '1990-07-01', endDate: '1991-03-31' },  // 1990-1991 recession
            { startDate: '2001-03-01', endDate: '2001-11-30' },  // Early 2000s recession
            { startDate: '2007-12-01', endDate: '2009-06-30' },  // Great Recession
            { startDate: '2020-02-01', endDate: '2020-04-30' }   // COVID-19 recession
        ];
        
        // Reusable recession shading plugin for all macro charts
        function getRecessionShadingPlugin() {
            return {
                id: 'recessionShading',
                beforeDraw: (chart) => {
                    try {
                        if (!chart || !chart.ctx || !chart.chartArea || !chart.scales || !chart.scales.x) return;
                        
                        const { ctx, chartArea, scales } = chart;
                        const { top, bottom, left, right } = chartArea;
                        const x = scales.x;
                        
                        if (!globalRecessionPeriods || globalRecessionPeriods.length === 0) return;
                        
                        ctx.save();
                        ctx.fillStyle = 'rgba(156, 163, 175, 0.08)'; // Light gray (less pronounced)
                        
                        // Get chart labels once
                        const chartLabels = chart.data.labels || [];
                        if (chartLabels.length === 0) return;
                        
                        globalRecessionPeriods.forEach(period => {
                            try {
                                const startDate = new Date(period.startDate + 'T00:00:00');
                                const endDate = new Date(period.endDate + 'T23:59:59');
                                
                                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                                    console.debug('Invalid recession period dates:', period.startDate, period.endDate);
                                    return; // Skip this period
                                }
                                
                                let startIdx = -1;
                                let endIdx = -1;
                                
                                // Find first date >= start date and last date <= end date
                                // Use a more flexible approach: find the closest dates if exact matches don't exist
                                for (let i = 0; i < chartLabels.length; i++) {
                                    try {
                                        const labelDate = new Date(chartLabels[i]);
                                        if (isNaN(labelDate.getTime())) continue; // Skip invalid dates
                                        
                                        // Find start index: first date on or after start date
                                        if (startIdx === -1 && labelDate >= startDate) {
                                            startIdx = i;
                                        }
                                        
                                        // Find end index: last date on or before end date
                                        if (labelDate <= endDate) {
                                            endIdx = i;
                                        }
                                    } catch (e) {
                                        // Skip invalid date strings
                                        continue;
                                    }
                                }
                                
                                // If we didn't find an exact start, use the first date before the start (if chart starts after recession)
                                if (startIdx === -1 && chartLabels.length > 0) {
                                    try {
                                        const firstLabelDate = new Date(chartLabels[0]);
                                        if (!isNaN(firstLabelDate.getTime()) && firstLabelDate > startDate && firstLabelDate <= endDate) {
                                            startIdx = 0; // Chart starts during the recession
                                        }
                                    } catch (e) {
                                        // Skip if date parsing fails
                                    }
                                }
                                
                                // If we didn't find an exact end, use the last date after the end (if chart ends during recession)
                                if (endIdx === -1 && chartLabels.length > 0) {
                                    try {
                                        const lastLabelDate = new Date(chartLabels[chartLabels.length - 1]);
                                        if (!isNaN(lastLabelDate.getTime()) && lastLabelDate < endDate && lastLabelDate >= startDate) {
                                            endIdx = chartLabels.length - 1; // Chart ends during the recession
                                        }
                                    } catch (e) {
                                        // Skip if date parsing fails
                                    }
                                }
                                
                                // If we found valid indices, draw the shading
                                if (startIdx !== -1 && endIdx !== -1 && startIdx <= endIdx) {
                                    try {
                                        const xStart = x.getPixelForValue(chartLabels[startIdx]);
                                        const xEnd = x.getPixelForValue(chartLabels[endIdx]);
                                        
                                        if (!isNaN(xStart) && !isNaN(xEnd)) {
                                            // Only draw if period overlaps with chart area
                                            if (xEnd > left && xStart < right) {
                                                const drawStart = Math.max(xStart, left);
                                                const drawEnd = Math.min(xEnd, right);
                                                ctx.fillRect(drawStart, top, drawEnd - drawStart, bottom - top);
                                            }
                                        }
                                    } catch (error) {
                                        // Silently skip if there's an error getting pixel values
                                        console.debug('Error drawing recession shading for period:', period.startDate, '-', period.endDate, error);
                                    }
                                }
                            } catch (error) {
                                console.debug('Error processing recession period:', period, error);
                            }
                        });
                        
                        ctx.restore();
                    } catch (error) {
                        console.error('Error in recession shading plugin:', error);
                    }
                }
            };
        }

        // Draw a label for the latest non-null datapoint for any dataset with `showLatestLabel: true`.
        // Optional per-dataset formatter: `latestLabelFormatter(value, ctx)` where ctx = { datasetLabel, index }.
        function getLatestValueLabelPlugin() {
            return {
                id: 'latestValueLabel',
                afterDatasetsDraw: (chart) => {
                    try {
                        if (!chart || !chart.ctx || !chart.data || !chart.data.datasets) return;
                        const ctx = chart.ctx;
                        const datasets = chart.data.datasets;

                        ctx.save();
                        ctx.font = 'bold 10px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
                        ctx.fillStyle = 'rgba(229, 231, 235, 0.95)'; // gray-200
                        ctx.strokeStyle = 'rgba(17, 24, 39, 0.9)';   // gray-900
                        ctx.lineWidth = 3;

                        datasets.forEach((ds, di) => {
                            if (!ds || !ds.showLatestLabel) return;
                            const meta = chart.getDatasetMeta(di);
                            if (!meta || meta.hidden || !meta.data || meta.data.length === 0) return;
                            const data = ds.data || [];

                            let latestIdx = -1;
                            for (let i = data.length - 1; i >= 0; i--) {
                                const v = data[i];
                                if (v !== null && v !== undefined && !Number.isNaN(v)) {
                                    latestIdx = i;
                                    break;
                                }
                            }
                            if (latestIdx === -1) return;

                            const el = meta.data[latestIdx];
                            if (!el) return;

                            // Chart.js element has `x` / `y`
                            const x = el.x;
                            const y = el.y;
                            if (x === undefined || y === undefined) return;

                            const rawVal = data[latestIdx];
                            const formatter = typeof ds.latestLabelFormatter === 'function'
                                ? ds.latestLabelFormatter
                                : (v) => `${v}`;
                            const label = formatter(rawVal, { datasetLabel: ds.label || '', index: latestIdx });
                            if (!label) return;

                            const offsetX = 6;
                            const offsetY = -8;
                            const area = chart.chartArea;
                            const metrics = ctx.measureText(label);
                            const textWidth = metrics && metrics.width ? metrics.width : 0;

                            // Keep label fully inside chart area to avoid clipped text artifacts
                            const pad = 2;
                            const maxX = area ? (area.right - textWidth - pad) : (x + offsetX);
                            const minX = area ? (area.left + pad) : (x + offsetX);
                            const maxY = area ? (area.bottom - pad) : (y + offsetY);
                            const minY = area ? (area.top + 10) : (y + offsetY); // allow for font height

                            const drawX = Math.min(Math.max(x + offsetX, minX), maxX);
                            const drawY = Math.min(Math.max(y + offsetY, minY), maxY);

                            ctx.strokeText(label, drawX, drawY);
                            ctx.fillText(label, drawX, drawY);
                        });

                        ctx.restore();
                    } catch (e) {
                        // Never hard-fail chart rendering
                        console.debug('latestValueLabel plugin error:', e);
                    }
                }
            };
        }
        
        // Macro chart instances
        let sahmChartInstance = null;
        let yieldChartInstance = null;
        let wageChartInstance = null;
        let liquidityChartInstance = null;
        let marshallianKChartInstance = null;
        let excessLiquidityChartInstance = null;
        let hySpreadChartInstance = null;
        let nfciChartInstance = null;
        let cfnaiChartInstance = null;
        let erpChartInstance = null;
        let combinedChartInstance = null;
        let macroScoreChartInstance = null;
        let threeHeadedMonsterChartInstance = null;
        
        // Interest Rates chart instances
        let termPremiumChartInstance = null;
        let forwardPremiumChartInstance = null;
        let termPremiumComparisonChartInstance = null;
        let yieldDecompChartInstance = null;
        let dotPlotChartInstance = null;
        let inflationChartInstance = null;
        let realYieldChartInstance = null;
        let inflationCpiPceChartInstance = null;
        let forwardAllocationChartInstance = null;
        
        // Store full data for zoom functionality (interest rates charts)
        var termPremiumFullData = null;
        var forwardPremiumFullData = null;
        var termPremiumComparisonFullData = null;
        var yieldDecompFullData = null;
        var dotPlotFullDataInterest = null; // Renamed to avoid conflict with TAA dot plot
        var inflationChartFullData = null;
        var realYieldFullData = null;
        var yield10YFullData = null; // Store nominal 10Y yield data for real yield chart
        var inflationCpiPceFullData = null;
        
        // Raw data storage for zoom functionality
        var rawCpiOverallData = null;
        var rawCpiCoreData = null;
        var rawPceOverallData = null;
        var rawPceCoreData = null;
        var rawCpiShelterData = null;
        var rawCpiFoodData = null;
        var rawCpiEnergyData = null;
        var rawCpiTransportData = null;
        var rawCpiMedicalData = null;
        var rawCpiEducationData = null;
        var rawCpiApparelData = null;
        var rawCpiRecreationData = null;
        var rawCpiOtherData = null;
        var rawDallasTrimmedData = null;
        
        var rawYield2YData = null;
        var rawFedFundsData = null;
        var rawDotPlotMedianData = null;
        
        // Zoom state for each chart
        // Default to 24 months (2 years) view for interest rate charts
        var termPremiumZoom24 = false;
        var forwardPremiumZoom24 = false;
        var termPremiumComparisonZoom24 = false;
        var yieldDecompZoom24 = false;
        var dotPlotZoom24 = true;
        var inflationChartZoom24 = true;
        var realYieldZoom24 = false; 
        var inflationCpiPceZoom24 = false;
        var liquidityZoom24 = true; // Start in 2yr zoom mode
        var yieldCurveZoom24 = false;
        var yieldCurveFullData = null;
        
        // Helper function to filter data to last 24 months
        function filterTo5Years(data) {
            if (!data || data.length === 0) return data;
            const fiveYearsAgo = new Date();
            fiveYearsAgo.setFullYear(fiveYearsAgo.getFullYear() - 5);
            return data.filter(d => new Date(d.date) >= fiveYearsAgo);
        }
        
        function filterTo24Months(data) {
            if (!data || data.length === 0) return data;
            const twoYearsAgo = new Date();
            twoYearsAgo.setMonth(twoYearsAgo.getMonth() - 24);
            return data.filter(d => {
                const date = new Date(d.date);
                return date >= twoYearsAgo;
            });
        }
        
        // Format date as MM-DD-YYYY for "Latest update" display (FRED returns YYYY-MM-DD - parse directly to avoid timezone issues)
        function formatLatestDate(dateStr) {
            if (!dateStr) return '--';
            const parts = String(dateStr).split('-');
            if (parts.length >= 3) {
                return `${parts[1]}-${parts[2]}-${parts[0]}`;
            }
            const d = new Date(dateStr);
            if (isNaN(d.getTime())) return '--';
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            const y = d.getFullYear();
            return `${m}-${day}-${y}`;
        }
        
        // Macro score calculation state
        let macroScoreData = {
            sahm: null,
            yieldCurve: null,
            realWage: null,
            liquidity: null,
            hySpread: null,
            nfci: null,
            erp: null,
            combinedSignal: null,
            hope: null
        };
        
        // HOPE model chart instance
        let hopeChartInstance = null;
        
        // Fiscal chart instances
        let debtTrendChartInstance = null;
        let deficitChartInstance = null;
        let spendingChartInstance = null;
        let interestCostChartInstance = null;
        let interestSqueezeChartInstance = null;
        let stealthMonetizationChartInstance = null;
        let sustainabilitySpreadChartInstance = null;
        let twinDeficitsChartInstance = null;
        let tightnessChartInstance = null;
        let beveridgeChartInstance = null;
        let realWageChartInstance = null;
        let quitsWageChartInstance = null;
        let employmentMonthlyChangeChartInstance = null;
        let participationRateChartInstance = null;
        let totalEmployedChartInstance = null;
        let unemploymentRateChartInstance = null;
        let sectorEmploymentChartInstance = null;
        let productivityChartInstance = null;
        let claimsChartInstance = null;
        let contClaimsChartInstance = null;
        
        window.fiscalDataLoaded = false;
        window.employmentDataLoaded = false;
        
        // FRED API key
        const FRED_API_KEY = '322b84f887e09b9fbf30ce3ba3b09740';
        const FRED_BASE_URL = 'https://api.stlouisfed.org/fred/series/observations';
        
        // BLS API key
        const BLS_API_KEY = 'ae6705ba50b64211b7192f2a4a01df1c';
        const BLS_API_URL = 'https://api.bls.gov/publicAPI/v2/timeseries/data/';
        
        // Twelve Data API key
        const TWELVE_DATA_API_KEY = 'ca3dfeb893a041b188ae4648825386d7';
        
        // Tab switching function is already defined above
        
        // Helper to perform safe fetch via Electron IPC or fallback
        async function safeFetch(url, options = {}) {
            const isElectron = typeof window !== 'undefined' && window.electronAPI !== undefined;
            
            if (isElectron && window.electronAPI.fetchAPI) {
                try {
                    const response = await window.electronAPI.fetchAPI(url, options);
                    if (response.ok) {
                        return { ok: true, data: response.data };
                    } else {
                        console.warn(`IPC fetch failed for ${url}:`, response.error || response.status);
                        return { ok: false, status: response.status, error: response.error };
                    }
                } catch (e) {
                    console.error('IPC fetch error:', e);
                    return { ok: false, error: e.message };
                }
            } else {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        const data = await response.json();
                        return { ok: true, data: data };
                    } else {
                        return { ok: false, status: response.status };
                    }
                } catch (e) {
                    return { ok: false, error: e.message };
                }
            }
        }

        // Fetch VTI data from Twelve Data API
        async function fetchVTIData(apiKey, startDate = null, endDate = null) {
            try {
                let outputsize = 5000;
                if (startDate) {
                    const start = new Date(startDate);
                    const end = endDate ? new Date(endDate) : new Date();
                    const daysDiff = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                    outputsize = Math.min(daysDiff, 5000);
                }
                
                const url = `https://api.twelvedata.com/time_series?symbol=VTI&interval=1month&apikey=${apiKey}&outputsize=${outputsize}&format=JSON`;
                console.log('Fetching VTI data...');
                const result = await safeFetch(url);
                
                if (!result.ok) throw new Error(`Fetch failed with status ${result.status}`);
                const json = result.data;
                
                if (json.status === 'error') throw new Error(json.message);
                if (!json.values) throw new Error('No data values found');
                
                const filteredData = json.values
                    .map(item => ({ date: item.datetime, value: parseFloat(item.close) }))
                    .filter(item => !isNaN(item.value) && item.value > 0)
                    .sort((a, b) => new Date(a.date) - new Date(b.date));
                
                return filteredData;
            } catch (error) {
                console.error('Error fetching VTI data:', error);
                return [];
            }
        }
        
        // Fetch AGG data from Twelve Data API
        async function fetchAGGData(apiKey, startDate = null, endDate = null) {
            try {
                let outputsize = 5000;
                if (startDate) {
                    const start = new Date(startDate);
                    const end = endDate ? new Date(endDate) : new Date();
                    const daysDiff = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                    outputsize = Math.min(daysDiff, 5000);
                }
                
                const url = `https://api.twelvedata.com/time_series?symbol=AGG&interval=1month&apikey=${apiKey}&outputsize=${outputsize}&format=JSON`;
                console.log('Fetching AGG data...');
                const result = await safeFetch(url);
                
                if (!result.ok) throw new Error(`Fetch failed with status ${result.status}`);
                const json = result.data;
                
                if (json.status === 'error') throw new Error(json.message);
                if (!json.values) throw new Error('No data values found');
                
                const filteredData = json.values
                    .map(item => ({ date: item.datetime, value: parseFloat(item.close) }))
                    .filter(item => !isNaN(item.value) && item.value > 0)
                    .sort((a, b) => new Date(a.date) - new Date(b.date));
                
                return filteredData;
            } catch (error) {
                console.error('Error fetching AGG data:', error);
                return [];
            }
        }
        
        // Fetch SPY data from Twelve Data API as proxy for S&P 500
        async function fetchSPYData(apiKey, startDate = null, endDate = null) {
            try {
                let outputsize = 5000;
                if (startDate) {
                    const start = new Date(startDate);
                    const end = endDate ? new Date(endDate) : new Date();
                    const daysDiff = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                    outputsize = Math.min(daysDiff, 5000);
                }
                
                const url = `https://api.twelvedata.com/time_series?symbol=SPY&interval=1day&apikey=${apiKey}&outputsize=${outputsize}&format=JSON`;
                console.log('Fetching SPY data...');
                const result = await safeFetch(url);
                
                if (!result.ok) throw new Error(`Fetch failed with status ${result.status}`);
                const json = result.data;
                
                if (json.status === 'error') throw new Error(json.message);
                if (!json.values) throw new Error('No data values found');
                
                const spyData = json.values.map(item => ({
                    date: item.datetime.split(' ')[0],
                    value: parseFloat(item.close)
                })).reverse();
                
                return spyData;
            } catch (error) {
                console.error('Error fetching SPY data:', error);
                return [];
            }
        }
        
        // Throttling and Queuing for FRED API to avoid 429 errors
        let fredRequestQueue = Promise.resolve();
        const FRED_MIN_DELAY = 300; // Faster delay (200 requests/min), relies on queuing and Electron IPC
        const CONCURRENT_FRED_REQUESTS = 2; // Allow small parallelization to speed up loading
        let activeFredRequests = 0;

        const FRED_CACHE_HOURS = 4;  // Cache FRED data for 4 hours - ensures fresh daily data
        const FRED_CACHE_HOURS_LIQUIDITY = 1;  // Shorter cache for M2/GDP - liquidity data benefits from more frequent refresh
        async function fetchFREDData(seriesId, startDate = null, endDate = null, retryCount = 0) {
            const cacheKey = `fred_${seriesId}_${startDate || '20y'}_${endDate || 'now'}`;
            const cachedData = sessionStorage.getItem(cacheKey);
            if (cachedData) {
                try {
                    const parsed = JSON.parse(cachedData);
                    const cachedAt = parsed._cachedAt;
                    const data = parsed._data ?? parsed;  // Support both {_data, _cachedAt} and legacy raw array
                    const liquidityOrFiscal = ['M2SL', 'GDP', 'WALCL', 'GFDEBTN', 'GFDEGDQ188S', 'MTSO133FMS', 'MTSR133FMS', 'MTSDS133FMS', 'MVGFD027MNFRBDAL', 'FYFSD', 'FYONGDA188S', 'A091RC1Q027SBEA', 'W006RC1Q027SBEA', 'FDHBFRBN', 'FYFSGDA188S', 'NETFI'].includes(seriesId);
                    const cacheHours = liquidityOrFiscal ? FRED_CACHE_HOURS_LIQUIDITY : FRED_CACHE_HOURS;
                    if (cachedAt && (Date.now() - cachedAt) < cacheHours * 60 * 60 * 1000) {
                        console.log(`Loaded ${data.length} observations for ${seriesId} from session cache`);
                        return data;
                    }
                    // Cache expired - fall through to fetch
                } catch (e) {
                    sessionStorage.removeItem(cacheKey);
                }
            }

            // Chain to the queue to ensure controlled rate
            const result = await (fredRequestQueue = fredRequestQueue.then(async () => {
                // If too many active requests, wait
                while (activeFredRequests >= CONCURRENT_FRED_REQUESTS) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                activeFredRequests++;
                try {
                    // Wait for the mandatory delay before starting the next request
                    await new Promise(resolve => setTimeout(resolve, FRED_MIN_DELAY));
                    return await executeFredRequest(seriesId, startDate, endDate, retryCount);
                } finally {
                    activeFredRequests--;
                }
            }));

            return result;
        }

        async function executeFredRequest(seriesId, startDate, endDate, retryCount) {
            const cacheKey = `fred_${seriesId}_${startDate || '20y'}_${endDate || 'now'}`;
            
            // Default to 20 years ago if no start date provided
            if (!startDate) {
                const twentyYearsAgo = new Date();
                twentyYearsAgo.setFullYear(twentyYearsAgo.getFullYear() - 20);
                startDate = twentyYearsAgo.toISOString().split('T')[0];
            }
            
            // Detect environment
            const isElectron = typeof window !== 'undefined' && window.electronAPI !== undefined;
            const isLocalFile = window.location.protocol === 'file:';
            
            // In Electron, ALWAYS use the specialized IPC fetcher
            if (isElectron && window.electronAPI && window.electronAPI.fetchFredSeries) {
                try {
                    const extraParams = {
                        observation_start: startDate,
                        observation_end: endDate || new Date().toISOString().split('T')[0]
                    };
                    const data = await window.electronAPI.fetchFredSeries(seriesId, FRED_API_KEY, extraParams);
                    
                    if (data && data.length > 0) {
                        const sorted = data.sort((a, b) => new Date(a.date) - new Date(b.date));
                        try { sessionStorage.setItem(cacheKey, JSON.stringify({ _data: sorted, _cachedAt: Date.now() })); } catch (e) {}
                        return sorted;
                    }
                    
                    if (retryCount < 1) {
                        console.warn(`Empty data for ${seriesId} via IPC, retrying...`);
                        await new Promise(r => setTimeout(r, 2000));
                        return executeFredRequest(seriesId, startDate, endDate, retryCount + 1);
                    }
                } catch (e) {
                    console.error(`Electron IPC FRED fetcher failed for ${seriesId}:`, e.message);
                }
            }
            
            // Construct the FRED URL
            const params = new URLSearchParams({
                series_id: seriesId,
                api_key: FRED_API_KEY,
                file_type: 'json',
                observation_start: startDate,
                observation_end: endDate || new Date().toISOString().split('T')[0]
            });
            const fredUrl = `${FRED_BASE_URL}?${params}`;

            // Proxy options sequentially
            const proxyOptions = [
                { url: 'https://corsproxy.io/?', type: 'direct' },
                { url: 'https://api.allorigins.win/get?url=', type: 'allorigins' },
                { url: 'https://api.codetabs.com/v1/proxy?quest=', type: 'direct' }
            ];
            
            // Try direct fetch first ONLY if not local file
            if (!isLocalFile) {
                try {
                    const directResponse = await fetch(fredUrl);
                    if (directResponse.ok) {
                        const directData = await directResponse.json();
                        if (directData.observations) {
                            const filtered = directData.observations
                                .filter(obs => obs.value !== '.' && obs.value !== null && obs.value !== undefined)
                                .map(obs => ({ date: obs.date, value: parseFloat(obs.value) }))
                                .filter(obs => !isNaN(obs.value))
                                .sort((a, b) => new Date(a.date) - new Date(b.date));
                            try { sessionStorage.setItem(cacheKey, JSON.stringify({ _data: filtered, _cachedAt: Date.now() })); } catch (e) {}
                            return filtered;
                        }
                    } else if (directResponse.status === 429 && retryCount < 2) {
                        const delay = 5000 * (retryCount + 1);
                        console.warn(`FRED API 429 for ${seriesId}. Retrying in ${delay}ms...`);
                        await new Promise(r => setTimeout(r, delay));
                        return executeFredRequest(seriesId, startDate, endDate, retryCount + 1);
                    }
                } catch (e) {}
            }
            
            // Try proxies
            for (const proxy of proxyOptions) {
                try {
                    const targetUrl = proxy.url + encodeURIComponent(fredUrl);
                    const response = await fetch(targetUrl);
                    if (response.ok) {
                        const rawData = await response.json();
                        let jsonData = proxy.type === 'allorigins' ? JSON.parse(rawData.contents) : rawData;
                        
                        if (jsonData && jsonData.observations) {
                            const filtered = jsonData.observations
                                .filter(obs => obs.value !== '.' && obs.value !== null && obs.value !== undefined)
                                .map(obs => ({ date: obs.date, value: parseFloat(obs.value) }))
                                .filter(obs => !isNaN(obs.value))
                                .sort((a, b) => new Date(a.date) - new Date(b.date));
                            try { sessionStorage.setItem(cacheKey, JSON.stringify({ _data: filtered, _cachedAt: Date.now() })); } catch (e) {}
                            return filtered;
                        }
                    } else if (response.status === 429) {
                        console.warn(`Proxy ${proxy.url} rate limited for ${seriesId}`);
                        continue;
                    }
                } catch (e) {
                    console.warn(`Proxy ${proxy.url} failed:`, e.message);
                }
            }
            
            return [];
        }



        
        // BLS API helper function
        async function fetchBLSData(seriesIds, startYear = null, endYear = null) {
            // BLS API requires series IDs as an array
            const seriesArray = Array.isArray(seriesIds) ? seriesIds : [seriesIds];
            
            // Check session cache for all series first
            const currentYear = new Date().getFullYear();
            const defaultStartYear = startYear || (currentYear - 10); // Default to 10 years
            const defaultEndYear = endYear || currentYear;
            const cacheKey = `bls_${seriesArray.sort().join('_')}_${defaultStartYear}_${defaultEndYear}`;
            
            const cachedData = sessionStorage.getItem(cacheKey);
            if (cachedData) {
                try {
                    const parsed = JSON.parse(cachedData);
                    console.log(`Loaded ${seriesArray.length} BLS series from session cache`);
                    return parsed;
                } catch (e) {
                    sessionStorage.removeItem(cacheKey);
                }
            }
            
            const requestBody = {
                seriesid: seriesArray,
                startyear: defaultStartYear.toString(),
                endyear: defaultEndYear.toString(),
                registrationkey: BLS_API_KEY
            };
            
            // Detect if running in Electron
            const isElectron = typeof window !== 'undefined' && window.electronAPI !== undefined;
            
            try {
                let response;
                let data;
                
                // Use Electron API proxy if available (bypasses CORS)
                if (isElectron && window.electronAPI && window.electronAPI.fetchAPI) {
                    try {
                        response = await window.electronAPI.fetchAPI(BLS_API_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestBody)
                        });
                        
                        if (!response.ok) {
                            throw new Error(`BLS API request failed: ${response.status}`);
                        }
                        
                        data = response.data || {};
                    } catch (proxyError) {
                        console.warn(`Electron API proxy failed for BLS:`, proxyError.message);
                        // Fall through to try regular fetch
                        response = await fetch(BLS_API_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestBody)
                        });
                        
                        if (!response.ok) {
                            throw new Error(`BLS API request failed: ${response.status}`);
                        }
                        
                        data = await response.json();
                    }
                } else {
                    // Fallback to regular fetch
                    response = await fetch(BLS_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`BLS API request failed: ${response.status}`);
                    }
                    
                    data = await response.json();
                }
                
                if (data.status === 'REQUEST_SUCCEEDED' && data.Results && data.Results.series) {
                    // Process each series
                    const result = {};
                    
                    data.Results.series.forEach(series => {
                        const seriesId = series.seriesID;
                        const observations = [];
                        
                        if (series.data && series.data.length > 0) {
                            // BLS returns data in reverse chronological order (newest first)
                            // Sort to chronological order
                            const sortedData = [...series.data].sort((a, b) => {
                                const yearA = parseInt(a.year);
                                const yearB = parseInt(b.year);
                                if (yearA !== yearB) return yearA - yearB;
                                return parseInt(a.period.substring(1)) - parseInt(b.period.substring(1));
                            });
                            
                            sortedData.forEach(obs => {
                                // BLS period format: M01 = January, M02 = February, etc.
                                if (obs.period.startsWith('M') && obs.value !== '') {
                                    const month = parseInt(obs.period.substring(1)) - 1; // 0-indexed
                                    const date = new Date(parseInt(obs.year), month, 1);
                                    const value = parseFloat(obs.value);
                                    
                                    if (!isNaN(value)) {
                                        observations.push({
                                            date: date.toISOString().split('T')[0],
                                            value: value,
                                            year: parseInt(obs.year),
                                            month: month + 1
                                        });
                                    }
                                }
                            });
                        }
                        
                        result[seriesId] = observations;
                        console.log(`BLS series ${seriesId}: ${observations.length} observations`);
                    });
                    
                    // Save to session cache
                    try {
                        sessionStorage.setItem(cacheKey, JSON.stringify(result));
                    } catch (e) {
                        console.warn('Failed to save BLS data to session cache');
                    }

                    console.log(`Loaded BLS data for ${seriesArray.length} series`);
                    return result;
                } else {
                    const errorMsg = data.message || data.status || 'Unknown error';
                    const errorDetails = data.Results?.error || data.message || JSON.stringify(data);
                    console.error(`BLS API error: ${errorMsg}`, errorDetails);
                    if (data.Results && data.Results.series) {
                        // Return empty arrays for each series ID
                        const result = {};
                        seriesArray.forEach(id => result[id] = []);
                        return result;
                    }
                    throw new Error(`BLS API error: ${errorMsg} - ${errorDetails}`);
                }
            } catch (error) {
                console.error(`Error fetching BLS data:`, error);
                // Return empty arrays for each series ID
                const result = {};
                seriesArray.forEach(id => result[id] = []);
                return result;
            }
        }
        
        // Calculate 3-month moving average
        function calculateMovingAverage(data, period) {
            const result = [];
            for (let i = period - 1; i < data.length; i++) {
                const sum = data.slice(i - period + 1, i + 1).reduce((acc, item) => acc + item.value, 0);
                result.push({
                    date: data[i].date,
                    value: sum / period
                });
            }
            return result;
        }
        
        // Calculate year-over-year percentage change
        function calculateYoYChange(data) {
            const result = [];
            for (let i = 12; i < data.length; i++) {
                const current = data[i].value;
                const previous = data[i - 12].value;
                if (previous !== 0) {
                    result.push({
                        date: data[i].date,
                        value: ((current / previous) - 1) * 100
                    });
                }
            }
            return result;
        }
        
        // Load and display all macro data
        async function loadMacroData() {
            const loadingEl = document.getElementById('macroLoading');
            const contentEl = document.getElementById('macroContent');
            
            try {
                loadingEl.classList.remove('hidden');
                contentEl.classList.add('hidden');
                loadingEl.innerHTML = `
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading macro data from FRED...</p>
                `;
                
                console.log('Starting to fetch FRED data...');
                
                // Fetch all data in parallel
                // Use SPY from Twelve Data API as proxy for S&P 500 to avoid FRED data limits
                // Optimized list: ensure we are not fetching the same series twice
                let [unrateData, yield10YData, yield2YData, earningsData, cpiData, walclData, tgaData, rrpData, m2Data, gdpData, hySpreadData, nfciData, cfnaiData, sp500EarningsData, vixData, oilData, dollarData,
                        housingStartsData, buildingPermitsData, homeSalesData, durableOrdersData, ismOrdersData, corporateProfitsData, payrollsData, joblessClaimsData, spyData,
                        will5000Data, yieldCurveData, ipmanData, coreCpiData, privateBalanceData] = await Promise.all([
                    fetchFREDData('UNRATE'),
                    fetchFREDData('DGS10'),  // Daily 10Y Treasury (GS10 is monthly avg - use DGS10 for current data)
                    fetchFREDData('DGS2'),   // Daily 2Y Treasury (GS2 is monthly avg - use DGS2 for current data)
                    fetchFREDData('CES0500000003'),
                    fetchFREDData('CPIAUCSL'),
                    fetchFREDData('WALCL'),
                    fetchFREDData('WTREGEN'),
                    fetchFREDData('RRPONTSYD'),
                    fetchFREDData('M2SL'),
                    fetchFREDData('GDP'),
                    fetchFREDData('BAMLH0A0HYM2'),
                    fetchFREDData('NFCI'),
                    fetchFREDData('CFNAIMA3'),
                    fetchFREDData('SP500E'), 
                    fetchFREDData('VIXCLS'), 
                    fetchFREDData('DCOILWTICO'), 
                    fetchFREDData('DTWEXBGS'), 
                    fetchFREDData('HOUST'), 
                    fetchFREDData('PERMIT'), 
                    fetchFREDData('EXHOSLUSM495N'), 
                    fetchFREDData('DGORDER'), 
                    fetchFREDData('NAPMNOI'), 
                    fetchFREDData('A053RC1Q027SBEA'), 
                    fetchFREDData('PAYEMS'), 
                    fetchFREDData('ICSA'), 
                    fetchSPYData(TWELVE_DATA_API_KEY, '2000-01-01'),
                    fetchFREDData('WILL5000IN'), 
                    fetchFREDData('T10Y2Y'), 
                    fetchFREDData('IPMAN'), 
                    fetchFREDData('CPILFESL'), 
                    fetchFREDData('W062RC1Q027SBEA') 
                ]);

                // --- Resilience: Handle missing critical data with proxies ---
                
                // 1. S&P 500 Earnings fallback
                if (sp500EarningsData.length === 0) {
                    console.log('SP500E (Earnings) not available, fetching CP (Corporate Profits) as proxy...');
                    sp500EarningsData = await fetchFREDData('CP'); // Corporate Profits After Tax
                    if (sp500EarningsData.length === 0) {
                        sp500EarningsData = await fetchFREDData('A053RC1Q027SBEA');
                    }
                }

                // 2. ISM New Orders fallback
                if (ismOrdersData.length === 0) {
                    console.log('NAPMNOI (ISM New Orders) not available, using DGORDER (Durable Goods) as proxy...');
                    ismOrdersData = durableOrdersData;
                }

                // 3. Wilshire 5000 fallback
                if (will5000Data.length === 0) {
                    console.log('WILL5000IN (Wilshire 5000) not available, trying WILL5000PR...');
                    will5000Data = await fetchFREDData('WILL5000PR');
                }
                // --- End Resilience ---
                
                // Use SPY data as S&P 500 proxy (scale SPY prices to approximate S&P 500 levels)
                // SPY is typically around 1/10th of S&P 500, but we'll use a scaling factor based on recent data
                let sp500Data = [];
                if (spyData && spyData.length > 0) {
                    // Try to get a recent S&P 500 value from FRED for scaling, or use approximate ratio
                    try {
                        const recentSP500 = await fetchFREDData('SP500', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]);
                        let scaleFactor = 10; // Default approximate ratio
                        
                        if (recentSP500 && recentSP500.length > 0) {
                            const latestSP500 = recentSP500[recentSP500.length - 1];
                            const latestSPY = spyData[spyData.length - 1];
                            if (latestSP500 && latestSPY) {
                                scaleFactor = latestSP500.value / latestSPY.value;
                                console.log(`Using scale factor ${scaleFactor.toFixed(2)} to convert SPY to S&P 500 (SP500: ${latestSP500.value.toFixed(0)}, SPY: ${latestSPY.value.toFixed(2)})`);
                            }
                        }
                        
                        // Scale SPY data to approximate S&P 500 levels
                        sp500Data = spyData.map(item => ({
                            date: item.date,
                            value: item.value * scaleFactor
                        }));
                        
                        console.log(`Converted ${sp500Data.length} SPY data points to S&P 500 proxy using scale factor ${scaleFactor.toFixed(2)}`);
                    } catch (error) {
                        console.warn('Could not fetch recent S&P 500 for scaling, using default 10x multiplier:', error);
                        // Use default 10x multiplier
                        sp500Data = spyData.map(item => ({
                            date: item.date,
                            value: item.value * 10
                        }));
                    }
                } else {
                    console.warn('No SPY data available, falling back to FRED SP500');
                    // Fallback to FRED if SPY fails
                    sp500Data = await fetchFREDData('SP500');
                }
                
                console.log('Data fetched:', {
                    unrate: unrateData.length,
                    yield10Y: yield10YData.length,
                    yield2Y: yield2YData.length,
                    earnings: earningsData.length,
                    cpi: cpiData.length,
                    walcl: walclData.length,
                    tga: tgaData.length,
                    rrp: rrpData.length,
                    m2: m2Data.length,
                    gdp: gdpData.length,
                    hySpread: hySpreadData.length,
                    nfci: nfciData.length,
                    cfnai: cfnaiData.length,
                    sp500: sp500Data.length,
                    spy: spyData ? spyData.length : 0,
                    sp500DataSample: sp500Data.length > 0 ? sp500Data.slice(0, 3) : 'empty',
                    sp500Earnings: sp500EarningsData.length,
                    vix: vixData.length,
                    oil: oilData.length,
                    dollar: dollarData.length,
                    housingStarts: housingStartsData.length,
                    buildingPermits: buildingPermitsData.length,
                    homeSales: homeSalesData.length,
                    durableOrders: durableOrdersData.length,
                    ismOrders: ismOrdersData.length,
                    corporateProfits: corporateProfitsData.length,
                    payrolls: payrollsData.length,
                    joblessClaims: joblessClaimsData.length
                });
                
                let hasData = false;
                
                // Process Sahm Rule
                if (unrateData.length > 0) {
                    processSahmRule(unrateData);
                    hasData = true;
                } else {
                    document.getElementById('sahmCurrentRate').textContent = 'No data available';
                    document.getElementById('sahmStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('sahmStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process Yield Curve
                if (yield10YData.length > 0 && yield2YData.length > 0) {
                    processYieldCurve(yield10YData, yield2YData);
                    hasData = true;
                } else {
                    document.getElementById('yieldSpread').textContent = 'No data available';
                    document.getElementById('yieldStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('yieldStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process Real Wage Growth
                if (earningsData.length > 0 && cpiData.length > 0) {
                    processRealWageGrowth(earningsData, cpiData);
                    hasData = true;
                } else {
                    document.getElementById('realWageGrowth').textContent = 'No data available';
                    document.getElementById('wageStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('wageStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process Fed Net Liquidity
                if (walclData.length > 0 && tgaData.length > 0 && rrpData.length > 0) {
                    window.liquidityFullData = { walclData, tgaData, rrpData };
                    processFedNetLiquidity(walclData, tgaData, rrpData);
                    hasData = true;
                } else {
                    document.getElementById('netLiquidityValue').textContent = 'No data available';
                    document.getElementById('liquidityRocDollar').textContent = '--';
                    document.getElementById('liquidityRocPercent').textContent = '--';
                    document.getElementById('liquidityStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('liquidityStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }

                // Process Excess Liquidity (Marshallian K) - pass walclData for weekly Fed balance sheet proxy (more current than M2 monthly)
                if (m2Data.length > 0 && gdpData.length > 0) {
                    processExcessLiquidity(m2Data, gdpData, walclData);
                    hasData = true;
                } else {
                    document.getElementById('excessLiquidityValue').textContent = 'No data available';
                    document.getElementById('excessLiquidityStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('excessLiquidityStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }

                // Process High-Yield Spread
                if (hySpreadData.length > 0) {
                    processHighYieldSpread(hySpreadData);
                    hasData = true;
                } else {
                    document.getElementById('hySpread').textContent = 'No data available';
                    document.getElementById('hyStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('hyStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process NFCI
                if (nfciData.length > 0) {
                    processNFCI(nfciData);
                    hasData = true;
                } else {
                    document.getElementById('nfciValue').textContent = 'No data available';
                    document.getElementById('nfciStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('nfciStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process CFNAI
                if (cfnaiData.length > 0) {
                    processCFNAI(cfnaiData);
                    hasData = true;
                } else {
                    document.getElementById('cfnaiValue').textContent = 'No data available';
                    document.getElementById('cfnaiStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('cfnaiStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process Equity Risk Premium
                if (yield10YData.length > 0 && sp500Data.length > 0) {
                    processEquityRiskPremium(sp500Data, sp500EarningsData, yield10YData);
                    hasData = true;
                } else {
                    document.getElementById('erpValue').textContent = 'No data available';
                    document.getElementById('erpStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('erpStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process Combined Signals (VIX + High-Yield + NFCI)
                if (vixData.length > 0 && hySpreadData.length > 0 && nfciData.length > 0) {
                    processCombinedSignals(vixData, hySpreadData, nfciData);
                    hasData = true;
                } else {
                    document.getElementById('vixCurrent').textContent = 'No data available';
                    document.getElementById('combinedSignal').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('combinedSignal').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process 3 Headed Monster (Oil, 10Y Yield, Dollar)
                if (oilData.length > 0 && yield10YData.length > 0 && dollarData.length > 0) {
                    processThreeHeadedMonster(oilData, yield10YData, dollarData);
                    hasData = true;
                } else {
                    document.getElementById('monsterOil').textContent = 'No data available';
                    document.getElementById('monsterStatus').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('monsterStatus').className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Process HOPE Model
                if (housingStartsData.length > 0 || buildingPermitsData.length > 0 || homeSalesData.length > 0 ||
                    durableOrdersData.length > 0 || ismOrdersData.length > 0 || 
                    corporateProfitsData.length > 0 || sp500EarningsData.length > 0 ||
                    unrateData.length > 0 || payrollsData.length > 0 || joblessClaimsData.length > 0) {
                    console.log('Calling processHOPEModel with sp500Data length:', sp500Data ? sp500Data.length : 0);
                    processHOPEModel(housingStartsData, buildingPermitsData, homeSalesData,
                                    durableOrdersData, ismOrdersData, corporateProfitsData, sp500EarningsData,
                                    unrateData, payrollsData, joblessClaimsData, sp500Data);
                    hasData = true;
                } else {
                    document.getElementById('hopeStageIndicator').textContent = 'DATA UNAVAILABLE';
                    document.getElementById('hopeStageIndicator').className = 'inline-block px-6 py-3 rounded-lg text-lg font-bold mb-3 bg-gray-900/30 text-gray-400 border border-gray-700';
                }
                
                // Calculate Composite Macro Score
                if (hasData) {
                    calculateCompositeMacroScore();
                    // Set Composite Macro Score latest date (max across all macro datasets)
                    const allMacroDates = [unrateData, yield10YData, yield2YData, earningsData, cpiData,
                        walclData, tgaData, rrpData, m2Data, gdpData, hySpreadData, nfciData, cfnaiData,
                        housingStartsData, durableOrdersData, corporateProfitsData, payrollsData, joblessClaimsData]
                        .filter(arr => arr && arr.length > 0)
                        .map(arr => arr[arr.length - 1].date);
                    const macroScoreLatest = allMacroDates.length > 0 ? allMacroDates.reduce((a, b) => a > b ? a : b) : null;
                    const macroScoreDateEl = document.getElementById('macroScoreLatestDate');
                    if (macroScoreDateEl) macroScoreDateEl.textContent = formatLatestDate(macroScoreLatest);
                }
                
                // Update summary
                if (hasData) {
                    updateMacroSummary();
                }
                
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                window.macroDataLoaded = true;
                
                if (!hasData) {
                    loadingEl.classList.remove('hidden');
                    const isFileProtocol = window.location.protocol === 'file:';
                    
                    loadingEl.innerHTML = `
                        <div class="text-center">
                            <i class="fas fa-exclamation-circle text-red-400 text-4xl mb-4"></i>
                            <p class="text-red-400 text-lg font-semibold mb-2">Unable to load macro data</p>
                            <p class="text-gray-400 text-sm mb-4">${isFileProtocol ? 
                                'CORS restrictions prevent loading data from file:// protocol. This is a browser security feature that blocks cross-origin requests when opening files directly.' : 
                                'This may be due to CORS restrictions or network issues. Please check the browser console for details.'}</p>
                            ${isFileProtocol ? `
                                <div class="bg-gray-800 rounded-lg p-4 mb-4 border border-gray-700 text-left max-w-2xl mx-auto">
                                    <p class="text-yellow-400 font-semibold mb-3">📋 Quick Fix Instructions:</p>
                                    <ol class="list-decimal list-inside space-y-2 text-sm text-gray-300">
                                        <li>Open Terminal (Mac/Linux) or Command Prompt (Windows)</li>
                                        <li>Navigate to this file's directory:
                                            <code class="bg-gray-900 px-2 py-1 rounded text-yellow-400 ml-2">cd "$(dirname "$(pwd)")"</code>
                                        </li>
                                        <li>Start a local web server:
                                            <code class="bg-gray-900 px-2 py-1 rounded text-yellow-400 ml-2">python -m http.server 8000</code>
                                        </li>
                                        <li>Open in browser:
                                            <code class="bg-gray-900 px-2 py-1 rounded text-yellow-400 ml-2">http://localhost:8000/macroQuantum.html</code>
                                        </li>
                                    </ol>
                                </div>
                            ` : ''}
                            <button onclick="loadMacroData()" class="mt-4 px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold">
                                <i class="fas fa-redo mr-2"></i>Retry
                            </button>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Error loading macro data:', error);
                loadingEl.innerHTML = `
                    <p class="text-red-400 text-lg font-semibold mb-2">Error loading macro data</p>
                    <p class="text-gray-400 text-sm mb-4">${error.message}</p>
                    <button onclick="loadMacroData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Retry</button>
                `;
            }
        }
        
        // Process Sahm Rule indicator
        function processSahmRule(unrateData) {
            // Calculate 3-month moving average
            const ma3 = calculateMovingAverage(unrateData, 3);
            
            if (ma3.length < 12) {
                document.getElementById('sahmCurrentRate').textContent = 'Insufficient data';
                return;
            }
            
            // Get last 12 months of 3-month MA
            const last12Months = ma3.slice(-12);
            const minRate = Math.min(...last12Months.map(d => d.value));
            const currentRate = ma3[ma3.length - 1].value;
            const change = currentRate - minRate;
            
            // Update display
            document.getElementById('sahmCurrentRate').textContent = currentRate.toFixed(2) + '%';
            document.getElementById('sahmMinRate').textContent = minRate.toFixed(2) + '%';
            const changeEl = document.getElementById('sahmChange');
            changeEl.textContent = (change >= 0 ? '+' : '') + change.toFixed(2) + ' pp';
            
            // Set color based on change value
            if (change >= 0.50) {
                changeEl.className = 'text-3xl font-extrabold mb-2 text-red-400';
            } else if (change >= 0.30) {
                changeEl.className = 'text-3xl font-extrabold mb-2 text-yellow-400';
            } else {
                changeEl.className = 'text-3xl font-extrabold mb-2 text-green-400';
            }
            
            // Status
            const statusEl = document.getElementById('sahmStatus');
            if (change >= 0.50) {
                statusEl.textContent = '⚠️ RECESSION WARNING';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
            } else if (change >= 0.30) {
                statusEl.textContent = '⚠️ WATCH';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
            } else {
                statusEl.textContent = '✓ NORMAL';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
            }
            
            const sahmLatestDate = unrateData.length > 0 ? unrateData[unrateData.length - 1].date : null;
            const sahmDateEl = document.getElementById('sahmLatestDate');
            if (sahmDateEl) sahmDateEl.textContent = formatLatestDate(sahmLatestDate);
            
            // Create chart
            const ctx = document.getElementById('sahmChart');
            if (sahmChartInstance) {
                sahmChartInstance.destroy();
            }
            
            const labels = ma3.map(d => d.date);
            const values = ma3.map(d => d.value);
            const thresholdLine = new Array(ma3.length).fill(minRate + 0.50);
            
            // Note: Recession periods for shading are now defined globally using NBER official dates
            // This provides accurate historical recession shading across all charts
            
            sahmChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '3-Month MA Unemployment Rate',
                        data: values,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Recession Threshold (Min + 0.50pp)',
                        data: thresholdLine,
                        borderColor: '#ef4444',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
            
        }
        
        // Process Yield Curve Spread
        function processYieldCurve(yield10YData, yield2YData) {
            // Align dates and calculate spread
            const spreadData = [];
            const dateMap = new Map();
            
            yield10YData.forEach(item => dateMap.set(item.date, { tenY: item.value }));
            yield2YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).twoY = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.tenY !== undefined && values.twoY !== undefined) {
                    spreadData.push({
                        date: date,
                        value: values.tenY - values.twoY,
                        tenY: values.tenY,
                        twoY: values.twoY
                    });
                }
            });
            
            if (spreadData.length === 0) {
                document.getElementById('yieldSpread').textContent = 'Insufficient data';
                return;
            }
            
            yieldCurveFullData = spreadData;
            const latest = spreadData[spreadData.length - 1];
            
            // Update display
            document.getElementById('yieldSpread').textContent = latest.value.toFixed(2) + '%';
            document.getElementById('yield10Y').textContent = latest.tenY.toFixed(2) + '%';
            document.getElementById('yield2Y').textContent = latest.twoY.toFixed(2) + '%';
            
            const yieldDateEl = document.getElementById('yieldLatestDate');
            if (yieldDateEl) yieldDateEl.textContent = formatLatestDate(latest.date);
            
            // Status
            const statusEl = document.getElementById('yieldStatus');
            const analysisEl = document.getElementById('yieldAnalysis');
            
            if (latest.value < 0) {
                statusEl.textContent = '⚠️ INVERTED';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisEl.textContent = 'The yield curve is inverted (short-term rates higher than long-term). Historically, this predicts a recession within 6-18 months.';
            } else if (latest.value < 0.5) {
                statusEl.textContent = '⚠️ FLATTENING';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                analysisEl.textContent = 'The yield curve is flattening. Monitor for potential inversion.';
            } else {
                statusEl.textContent = '✓ NORMAL';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                analysisEl.textContent = 'The yield curve is in a normal, upward-sloping state.';
            }
            
            renderYieldCurveChart();
            setupYieldCurveZoomButton();
        }
        
        function renderYieldCurveChart() {
            if (!yieldCurveFullData || yieldCurveFullData.length === 0) return;
            const chartData = yieldCurveZoom24 ? filterTo24Months(yieldCurveFullData) : yieldCurveFullData;
            
            const ctx = document.getElementById('yieldChart');
            if (yieldChartInstance) yieldChartInstance.destroy();
            
            const labels = chartData.map(d => d.date);
            const spreads = chartData.map(d => d.value);
            const zeroLine = new Array(chartData.length).fill(0);
            
            // Median and quartiles (from full historical data)
            const sortedSpreads = [...yieldCurveFullData.map(d => d.value)].sort((a, b) => a - b);
            const medianSpread = sortedSpreads[Math.floor(sortedSpreads.length * 0.50)];
            const q1Spread = sortedSpreads[Math.floor(sortedSpreads.length * 0.25)];
            const q3Spread = sortedSpreads[Math.floor(sortedSpreads.length * 0.75)];
            
            yieldChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '10Y-2Y Spread',
                        data: spreads,
                        borderColor: '#60a5fa',
                        backgroundColor: spreads.map(v => v < 0 ? 'rgba(239, 68, 68, 0.2)' : 'rgba(96, 165, 250, 0.1)'),
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Median',
                        data: new Array(chartData.length).fill(medianSpread),
                        borderColor: 'rgba(148, 163, 184, 0.7)',
                        borderWidth: 1.5,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '25th Pctl',
                        data: new Array(chartData.length).fill(q1Spread),
                        borderColor: 'rgba(239, 68, 68, 0.6)',
                        borderWidth: 1,
                        borderDash: [2, 2],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '75th Pctl',
                        data: new Array(chartData.length).fill(q3Spread),
                        borderColor: 'rgba(16, 185, 129, 0.6)',
                        borderWidth: 1,
                        borderDash: [2, 2],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#9ca3af', font: { size: 9 } },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { color: '#9ca3af', font: { size: 9 }, callback: function(v) { return v.toFixed(2) + '%'; } },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
        }
        
        function setupYieldCurveZoomButton() {
            const btn = document.getElementById('yieldCurveZoom24');
            if (!btn || btn.hasAttribute('data-listener-added')) return;
            btn.setAttribute('data-listener-added', 'true');
            btn.addEventListener('click', function() {
                yieldCurveZoom24 = !yieldCurveZoom24;
                this.textContent = yieldCurveZoom24 ? 'Show Full' : 'Zoom 2Y';
                this.classList.toggle('bg-blue-600', yieldCurveZoom24);
                this.classList.toggle('hover:bg-blue-700', yieldCurveZoom24);
                this.classList.toggle('text-white', yieldCurveZoom24);
                this.classList.toggle('border-blue-500', yieldCurveZoom24);
                this.classList.toggle('bg-gray-700', !yieldCurveZoom24);
                this.classList.toggle('hover:bg-gray-600', !yieldCurveZoom24);
                this.classList.toggle('text-gray-300', !yieldCurveZoom24);
                this.classList.toggle('border-gray-600', !yieldCurveZoom24);
                renderYieldCurveChart();
            });
        }
        
        // Process Real Wage Growth
        function processRealWageGrowth(earningsData, cpiData) {
            // Align dates and calculate real wage (earnings / CPI * 100)
            const realWageData = [];
            const dateMap = new Map();
            
            earningsData.forEach(item => dateMap.set(item.date, { earnings: item.value }));
            cpiData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).cpi = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.earnings !== undefined && values.cpi !== undefined) {
                    realWageData.push({
                        date: date,
                        value: (values.earnings / values.cpi) * 100,
                        earnings: values.earnings,
                        cpi: values.cpi
                    });
                }
            });
            
            if (realWageData.length < 12) {
                document.getElementById('realWageGrowth').textContent = 'Insufficient data';
                return;
            }
            
            // Calculate YoY change
            const latest = realWageData[realWageData.length - 1];
            const yearAgo = realWageData[realWageData.length - 13];
            const yoyChange = ((latest.value / yearAgo.value) - 1) * 100;
            
            // Update display
            document.getElementById('realWageGrowth').textContent = (yoyChange >= 0 ? '+' : '') + yoyChange.toFixed(2) + '%';
            document.getElementById('avgEarnings').textContent = '$' + latest.earnings.toFixed(2);
            document.getElementById('cpiValue').textContent = latest.cpi.toFixed(2);
            
            const wageDateEl = document.getElementById('wageLatestDate');
            if (wageDateEl) wageDateEl.textContent = formatLatestDate(latest.date);
            
            // Status
            const statusEl = document.getElementById('wageStatus');
            const analysisEl = document.getElementById('wageAnalysis');
            
            if (yoyChange < 0) {
                statusEl.textContent = '⚠️ DECLINING';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisEl.textContent = 'Real wages are declining. Consumer purchasing power is decreasing, which may eventually impact consumer spending (70% of US GDP).';
            } else if (yoyChange < 1) {
                statusEl.textContent = '⚠️ WEAK GROWTH';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                analysisEl.textContent = 'Real wage growth is weak. Consumer spending power is growing slowly.';
            } else {
                statusEl.textContent = '✓ HEALTHY';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                analysisEl.textContent = 'Real wages are growing, indicating healthy consumer purchasing power and supporting consumer spending.';
            }
            
            // Create chart
            const ctx = document.getElementById('wageChart');
            if (wageChartInstance) {
                wageChartInstance.destroy();
            }
            
            // Calculate YoY changes for chart
            const yoyData = [];
            for (let i = 12; i < realWageData.length; i++) {
                const current = realWageData[i].value;
                const previous = realWageData[i - 12].value;
                if (previous !== 0) {
                    yoyData.push({
                        date: realWageData[i].date,
                        value: ((current / previous) - 1) * 100
                    });
                }
            }
            
            const labels = yoyData.map(d => d.date);
            const values = yoyData.map(d => d.value);
            const zeroLine = new Array(yoyData.length).fill(0);
            
            wageChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Real Wage Growth (YoY %)',
                        data: values,
                        borderColor: '#60a5fa',
                        backgroundColor: values.map(v => v < 0 ? 'rgba(239, 68, 68, 0.2)' : 'rgba(96, 165, 250, 0.1)'),
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
        }
        
        // Process Fed Net Liquidity
        function processFedNetLiquidity(walclData, tgaData, rrpData) {
            // Align dates and calculate net liquidity: (WALCL - WTREGEN - RRPONTSYD) / 1000
            const liquidityData = [];
            const dateMap = new Map();
            
            walclData.forEach(item => dateMap.set(item.date, { walcl: item.value }));
            tgaData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).tga = item.value;
                }
            });
            rrpData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).rrp = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.walcl !== undefined && values.tga !== undefined && values.rrp !== undefined) {
                    // Formula: (WALCL - WTREGEN - RRPONTSYD) / 1000
                    const netLiquidity = (values.walcl - values.tga - values.rrp) / 1000;
                    liquidityData.push({
                        date: date,
                        value: netLiquidity,
                        walcl: values.walcl,
                        tga: values.tga,
                        rrp: values.rrp
                    });
                }
            });
            
            if (liquidityData.length === 0) {
                document.getElementById('netLiquidityValue').textContent = 'Insufficient data';
                document.getElementById('liquidityRocDollar').textContent = '--';
                document.getElementById('liquidityRocPercent').textContent = '--';
                return;
            }
            
            const latest = liquidityData[liquidityData.length - 1];
            const previous = liquidityData.length > 1 ? liquidityData[liquidityData.length - 2] : latest;
            const trend = latest.value - previous.value;
            
            // Calculate 4-week ROC (data is weekly, so 4 weeks = 4 data points back)
            const fourWeeksAgo = liquidityData.length > 4 ? liquidityData[liquidityData.length - 5] : null;
            const rocDollar = fourWeeksAgo ? latest.value - fourWeeksAgo.value : null;
            const rocPercent = fourWeeksAgo && fourWeeksAgo.value !== 0 
                ? ((latest.value - fourWeeksAgo.value) / Math.abs(fourWeeksAgo.value)) * 100 
                : null;
            // 4-week ROC for each component ($ change in B, percent)
            const rocPct = (curr, prev) => (prev !== undefined && prev !== 0) ? ((curr - prev) / Math.abs(prev)) * 100 : null;
            const walclChg = fourWeeksAgo ? (latest.walcl - fourWeeksAgo.walcl) / 1000 : null;
            const tgaChg = fourWeeksAgo ? (latest.tga - fourWeeksAgo.tga) / 1000 : null;
            const rrpChg = fourWeeksAgo ? (latest.rrp - fourWeeksAgo.rrp) / 1000 : null;
            const walclRoc = fourWeeksAgo ? rocPct(latest.walcl, fourWeeksAgo.walcl) : null;
            const tgaRoc = fourWeeksAgo ? rocPct(latest.tga, fourWeeksAgo.tga) : null;
            const rrpRoc = fourWeeksAgo ? rocPct(latest.rrp, fourWeeksAgo.rrp) : null;
            const fmtRocParens = (chgB, pct) => {
                if (chgB === null && pct === null) return '';
                const $ = chgB !== null ? (chgB >= 0 ? '+' : '') + chgB.toFixed(2) + 'B' : '';
                const p = pct !== null ? (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%' : '';
                return ($ && p) ? `${$}, ${p} 4wk` : ($ || p ? ($ || p) + ' 4wk' : '');
            };
            const rocSpan = (chgB, pct) => {
                const s = fmtRocParens(chgB, pct);
                return s ? ` <span class="text-xs text-gray-400">(${s})</span>` : '';
            };
            
            // Calculate trend over last 3 months (13 weeks, same as segment coloring)
            const threeMonthLookback = 13;
            const threeMonthsAgo = liquidityData.length > threeMonthLookback ? liquidityData[liquidityData.length - 1 - threeMonthLookback] : null;
            const threeMonthTrend = threeMonthsAgo ? latest.value - threeMonthsAgo.value : 0;
            const threeMonthPct = threeMonthsAgo && threeMonthsAgo.value !== 0
                ? (threeMonthTrend / Math.abs(threeMonthsAgo.value)) * 100
                : null;
            
            // Update display (component values with 4-week $ and % in parens, smaller font)
            document.getElementById('netLiquidityValue').textContent = latest.value.toFixed(2) + 'B';
            document.getElementById('walclValue').innerHTML = (latest.walcl / 1000).toFixed(2) + 'B' + rocSpan(walclChg, walclRoc);
            document.getElementById('tgaValue').innerHTML = (latest.tga / 1000).toFixed(2) + 'B' + rocSpan(tgaChg, tgaRoc);
            document.getElementById('rrpValue').innerHTML = (latest.rrp / 1000).toFixed(2) + 'B' + rocSpan(rrpChg, rrpRoc);
            document.getElementById('liquidityRocDollar').textContent = rocDollar !== null 
                ? (rocDollar >= 0 ? '+' : '') + rocDollar.toFixed(2) + 'B' 
                : '--';
            document.getElementById('liquidityRocPercent').textContent = rocPercent !== null 
                ? (rocPercent >= 0 ? '+' : '') + rocPercent.toFixed(2) + '%' 
                : '--';
            
            const liquidityDateEl = document.getElementById('liquidityLatestDate');
            if (liquidityDateEl) liquidityDateEl.textContent = formatLatestDate(latest.date);
            
            // Status and trend analysis
            const statusEl = document.getElementById('liquidityStatus');
            const trendEl = document.getElementById('liquidityTrend');
            
            let statusText = '';
            let statusClass = '';
            let trendText = '';
            let chartColor = '#60a5fa';
            let chartFillColor = 'rgba(96, 165, 250, 0.05)';
            
            // Use same 1% 3-month threshold as segment coloring
            if (threeMonthPct != null && threeMonthPct > 1) {
                statusText = '✓ EXPANDING';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                trendText = `Net Liquidity is expanding (+${threeMonthPct.toFixed(2)}% over 3 months, +${threeMonthTrend.toFixed(2)}B). This provides tailwinds for risk assets like stocks and crypto. High liquidity supports market rallies.`;
                chartColor = '#10b981'; // Green
                chartFillColor = 'rgba(16, 185, 129, 0.05)';
            } else if (threeMonthPct != null && threeMonthPct < -1) {
                statusText = '⚠️ CONTRACTING';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                trendText = `Net Liquidity is contracting (${threeMonthPct.toFixed(2)}% over 3 months, ${threeMonthTrend.toFixed(2)}B). This creates headwinds for risk assets. Falling liquidity while stocks rise suggests a "Liquidity Divergence" - historically associated with volatility events or 5-10% corrections.`;
                chartColor = '#ef4444'; // Red
                chartFillColor = 'rgba(239, 68, 68, 0.05)';
            } else {
                statusText = '⚠️ STABLE';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                const pctStr = threeMonthPct != null ? (threeMonthPct >= 0 ? '+' : '') + threeMonthPct.toFixed(2) + '%' : '--';
                trendText = `Net Liquidity is relatively stable (${pctStr} over 3 months, ${threeMonthTrend >= 0 ? '+' : ''}${threeMonthTrend.toFixed(2)}B). Markets should continue to function normally, but watch for changes in trend.`;
                chartColor = '#fbbf24'; // Yellow
                chartFillColor = 'rgba(251, 191, 36, 0.05)';
            }
            
            statusEl.textContent = statusText;
            statusEl.className = statusClass;
            trendEl.textContent = trendText;
            
            // Create chart
            const ctx = document.getElementById('liquidityChart');
            if (liquidityChartInstance) {
                liquidityChartInstance.destroy();
            }
            
            // Apply 2-year zoom filter if active
            const chartData = liquidityZoom24 ? filterTo24Months(liquidityData) : liquidityData;
            const labels = chartData.map(d => d.date);
            const values = chartData.map(d => d.value);
            
            // Calculate 3-month % change for each point for segmented coloring (1% threshold)
            // Data is typically weekly, so ~13 weeks = 3 months
            const lookback = 13;
            const segmentTrendPct = values.map((v, i) => {
                if (i < lookback) return null;
                const prev = values[i - lookback];
                if (prev === 0) return null;
                return ((v - prev) / Math.abs(prev)) * 100;
            });
            
            liquidityChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Fed Net Liquidity (Billions)',
                        data: values,
                        borderColor: chartColor,
                        backgroundColor: chartFillColor,
                        borderWidth: 4,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        segment: {
                            borderColor: ctx => {
                                const i = ctx.p1DataIndex;
                                const pct = segmentTrendPct[i];
                                if (i < lookback || pct == null) return '#60a5fa'; // Blue for initial period
                                if (pct > 1) return '#10b981';  // Green: >1% 3mo change
                                if (pct < -1) return '#ef4444'; // Red: <-1% 3mo change
                                return '#fbbf24'; // Yellow: -1% to +1%
                            }
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': $' + context.parsed.y.toFixed(2) + 'B';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { 
                                    return '$' + value.toFixed(0) + 'B';
                                }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
            
            // Setup 2-year zoom button for liquidity chart
            const liquidityZoomBtn = document.getElementById('liquidityZoom24');
            if (liquidityZoomBtn && !liquidityZoomBtn.hasAttribute('data-listener-added')) {
                liquidityZoomBtn.setAttribute('data-listener-added', 'true');
                liquidityZoomBtn.addEventListener('click', function() {
                    liquidityZoom24 = !liquidityZoom24;
                    this.textContent = liquidityZoom24 ? 'Show Full' : 'Zoom 2Y';
                    if (liquidityZoom24) {
                        this.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                        this.classList.remove('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                    } else {
                        this.classList.add('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                        this.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                    }
                    const fd = window.liquidityFullData;
                    if (fd) processFedNetLiquidity(fd.walclData, fd.tgaData, fd.rrpData);
                });
            }
            if (liquidityZoomBtn) {
                liquidityZoomBtn.textContent = liquidityZoom24 ? 'Show Full' : 'Zoom 2Y';
                if (liquidityZoom24) {
                    liquidityZoomBtn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                    liquidityZoomBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                } else {
                    liquidityZoomBtn.classList.add('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                    liquidityZoomBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                }
            }
        }

        // Process Marshallian K (Ratio) and Excess Liquidity (Spread)
        // MONTHLY frequency: M2 is monthly; GDP is carried forward from prior quarter until new one is released
        // walclData (optional): Fed balance sheet weekly - shown on secondary axis
        function processExcessLiquidity(m2Data, gdpData, walclData = []) {
            if (!m2Data || m2Data.length === 0 || !gdpData || gdpData.length === 0) return;
            
            const m2Sorted = [...m2Data].sort((a, b) => new Date(a.date) - new Date(b.date));
            const gdpSorted = [...gdpData].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Build GDP carry-forward: for each month, use most recent GDP with gdp.date <= month.date
            const gdpByDate = new Map();
            gdpSorted.forEach(d => gdpByDate.set(d.date, d.value));
            const gdpDates = [...gdpByDate.keys()].sort();
            
            // GDP YoY: (quarter / same quarter 4 quarters ago - 1) * 100
            const gdpYoYByQuarter = new Map();
            for (let i = 4; i < gdpSorted.length; i++) {
                const curr = gdpSorted[i].value;
                const prev = gdpSorted[i - 4].value;
                gdpYoYByQuarter.set(gdpSorted[i].date, ((curr / prev) - 1) * 100);
            }
            
            // 1. Marshallian K (monthly): M2 monthly / GDP (carried forward from prior quarter)
            const kRatioData = [];
            for (let mi = 0; mi < m2Sorted.length; mi++) {
                const m2Date = m2Sorted[mi].date;
                const m2Val = m2Sorted[mi].value;
                // Find most recent GDP on or before this month
                let gdpVal = null;
                let gdpDate = null;
                for (let gi = gdpDates.length - 1; gi >= 0; gi--) {
                    if (gdpDates[gi] <= m2Date) {
                        gdpDate = gdpDates[gi];
                        gdpVal = gdpByDate.get(gdpDate);
                        break;
                    }
                }
                if (gdpVal && gdpVal > 0) {
                    kRatioData.push({
                        date: m2Date,
                        value: m2Val / gdpVal,
                        m2: m2Val,
                        gdp: gdpVal
                    });
                }
            }

            // 2. Excess Liquidity Spread (monthly): M2 YoY - GDP YoY (GDP YoY carried forward)
            const spreadData = [];
            for (let i = 12; i < m2Sorted.length; i++) {
                const m2Date = m2Sorted[i].date;
                const m2YoY = ((m2Sorted[i].value / m2Sorted[i - 12].value) - 1) * 100;
                // GDP YoY: use most recent quarter's YoY for this month
                let gdpYoY = null;
                for (let gi = gdpDates.length - 1; gi >= 0; gi--) {
                    if (gdpDates[gi] <= m2Date && gdpYoYByQuarter.has(gdpDates[gi])) {
                        gdpYoY = gdpYoYByQuarter.get(gdpDates[gi]);
                        break;
                    }
                }
                if (gdpYoY !== null) {
                    spreadData.push({
                        date: m2Date,
                        value: m2YoY - gdpYoY,
                        m2YoY: m2YoY,
                        gdpYoY: gdpYoY
                    });
                }
            }

            // Update Marshallian K Display
            if (kRatioData.length > 0) {
                const latestK = kRatioData[kRatioData.length - 1];
                document.getElementById('marshallianKValue').textContent = latestK.value.toFixed(4);
                document.getElementById('m2Value').textContent = '$' + (latestK.m2 / 1000).toFixed(2) + 'T';
                document.getElementById('gdpValue').textContent = '$' + (latestK.gdp / 1000).toFixed(2) + 'T';
                
                const statusEl = document.getElementById('marshallianKStatus');
                const analysisEl = document.getElementById('marshallianKAnalysis');
                
                const kValues = kRatioData.map(d => d.value);
                const kAvg = kValues.slice(-12).reduce((a, b) => a + b, 0) / Math.min(12, kValues.length);
                
                if (latestK.value > kAvg * 1.02) {
                    statusEl.textContent = '📈 RISING DEMAND';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                    analysisEl.textContent = `Marshallian K is rising above its recent average. This suggests liquidity is expanding faster than economic transactions, typically a precursor to asset price inflation.`;
                } else if (latestK.value < kAvg * 0.98) {
                    statusEl.textContent = '📉 FALLING DEMAND';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                    analysisEl.textContent = `Marshallian K is declining. This indicates the economy is "using up" its cash balances, which often leads to tighter financial conditions and lower asset multiples.`;
                } else {
                    statusEl.textContent = '➡️ NEUTRAL';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-blue-900/30 text-blue-400 border border-blue-700';
                    analysisEl.textContent = `Marshallian K is stable. Money demand is growing in line with the economy.`;
                }

                const mkDateEl = document.getElementById('marshallianKLatestDate');
                if (mkDateEl) mkDateEl.textContent = formatLatestDate(latestK.date);

                const ctxK = document.getElementById('marshallianKChart');
                if (marshallianKChartInstance) marshallianKChartInstance.destroy();
                
                // Calculate historical quartiles
                const sortedK = [...kValues].sort((a, b) => a - b);
                const q1K = sortedK[Math.floor(sortedK.length * 0.25)];
                const medianK = sortedK[Math.floor(sortedK.length * 0.50)];
                const q3K = sortedK[Math.floor(sortedK.length * 0.75)];
                
                // Calculate 5-year moving average (60 months)
                const ma5Y = kValues.map((v, i, arr) => {
                    if (i < 59) return null;
                    const slice = arr.slice(i - 59, i + 1);
                    return slice.reduce((a, b) => a + b, 0) / 60;
                });

                marshallianKChartInstance = new Chart(ctxK, {
                    type: 'line',
                    data: {
                        labels: kRatioData.map(d => d.date),
                        datasets: [{
                            label: 'Marshallian K (M2/GDP)',
                            data: kRatioData.map(d => d.value),
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            pointRadius: 0
                        }, {
                            label: '5Y Moving Avg',
                            data: ma5Y,
                            borderColor: 'rgba(255, 255, 255, 0.3)',
                            borderWidth: 1,
                            fill: false,
                            pointRadius: 0
                        }, {
                            label: '75th Pctl',
                            data: new Array(kRatioData.length).fill(q3K),
                            borderColor: 'rgba(16, 185, 129, 0.7)',
                            borderWidth: 1.5,
                            borderDash: [2, 2],
                            fill: false,
                            pointRadius: 0
                        }, {
                            label: 'Median',
                            data: new Array(kRatioData.length).fill(medianK),
                            borderColor: 'rgba(148, 163, 184, 0.7)',
                            borderWidth: 1.5,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0
                        }, {
                            label: '25th Pctl',
                            data: new Array(kRatioData.length).fill(q1K),
                            borderColor: 'rgba(239, 68, 68, 0.7)',
                            borderWidth: 1.5,
                            borderDash: [2, 2],
                            fill: false,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { 
                                labels: { 
                                    color: '#9ca3af', 
                                    font: { size: 10 },
                                    boxWidth: 12
                                } 
                            } 
                        },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } }
                        }
                    },
                    plugins: [getRecessionShadingPlugin()]
                });
            }
            
            // Compute WALCL YoY (weekly) for real-time liquidity proxy - extends chart beyond quarterly M2-GDP
            let walclYoYData = [];
            if (walclData && walclData.length >= 53) {
                const sortedWalcl = [...walclData].sort((a, b) => new Date(a.date) - new Date(b.date));
                for (let i = 52; i < sortedWalcl.length; i++) {
                    const current = sortedWalcl[i].value;
                    const yearAgo = sortedWalcl[i - 52].value;
                    if (yearAgo > 0) {
                        walclYoYData.push({
                            date: sortedWalcl[i].date,
                            value: ((current / yearAgo) - 1) * 100
                        });
                    }
                }
            }

            // Update Excess Liquidity Display
            if (spreadData.length > 0) {
                const latest = spreadData[spreadData.length - 1];
                const elDateEl = document.getElementById('excessLiquidityLatestDate');
                if (elDateEl) elDateEl.textContent = formatLatestDate(latest.date);
                document.getElementById('excessLiquidityValue').textContent = (latest.value >= 0 ? '+' : '') + latest.value.toFixed(2) + '%';
                document.getElementById('m2GrowthValue').textContent = latest.m2YoY.toFixed(2) + '%';
                document.getElementById('gdpGrowthValue').textContent = latest.gdpYoY.toFixed(2) + '%';
                
                const statusEl = document.getElementById('excessLiquidityStatus');
                const analysisEl = document.getElementById('excessLiquidityAnalysis');
                
                if (latest.value > 0) {
                    statusEl.textContent = '🚀 POSITIVE EXCESS LIQUIDITY';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                    analysisEl.textContent = `M2 is growing faster than the economy (+${latest.value.toFixed(2)}% spread). Per Mike Wilson, this "excess" money leaks into financial assets, supporting multiple expansion.`;
                } else if (latest.value > -2) {
                    statusEl.textContent = '⚠️ NEUTRAL/NEGATIVE';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                    analysisEl.textContent = `Economic growth is consuming available cash (${latest.value.toFixed(2)}% spread). Stocks often face "Multiple Contraction" in this regime.`;
                } else {
                    statusEl.textContent = '🛑 LIQUIDITY CLIFF';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                    analysisEl.textContent = `Severe liquidity deficit (${latest.value.toFixed(2)}% spread). Warning: This regime typically precedes major market corrections (10-20%).`;
                }
                
                const ctxEL = document.getElementById('excessLiquidityChart');
                if (excessLiquidityChartInstance) excessLiquidityChartInstance.destroy();
                // Primary axis fits excess liquidity spread only; WALCL on secondary axis (right)
                const spreadMap = new Map(spreadData.map(d => [d.date, d.value]));
                const walclMap = new Map(walclYoYData.map(d => [d.date, d.value]));
                const allDates = [...new Set([...spreadMap.keys(), ...walclMap.keys()])].sort();
                const spreadValues = allDates.map(d => spreadMap.get(d) ?? null);
                const walclValues = allDates.map(d => walclMap.get(d) ?? null);
                excessLiquidityChartInstance = new Chart(ctxEL, {
                    type: 'line',
                    data: {
                        labels: allDates,
                        datasets: [{
                            label: 'Excess Liquidity Spread (M2 YoY - GDP YoY)',
                            data: spreadValues,
                            borderColor: '#60a5fa',
                            backgroundColor: 'rgba(96, 165, 250, 0.15)',
                            borderWidth: 2,
                            fill: true,
                            pointRadius: 0,
                            spanGaps: true,
                            yAxisID: 'y'
                        }, {
                            label: 'Fed Balance Sheet YoY (weekly, right axis)',
                            data: walclValues,
                            borderColor: '#a78bfa',
                            borderWidth: 1.5,
                            borderDash: [4, 4],
                            fill: false,
                            pointRadius: 0,
                            spanGaps: true,
                            yAxisID: 'y1'
                        }, {
                            label: 'Zero Line',
                            data: allDates.map(() => 0),
                            borderColor: '#9ca3af',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#9ca3af', font: { size: 10 } } },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: {
                                type: 'linear',
                                position: 'left',
                                ticks: { color: '#9ca3af', font: { size: 9 }, callback: v => (v >= 0 ? '+' : '') + v.toFixed(1) + '%' },
                                grid: { color: 'rgba(156, 163, 175, 0.1)' },
                                title: { display: false }
                            },
                            y1: {
                                type: 'linear',
                                position: 'right',
                                ticks: { color: '#a78bfa', font: { size: 8 }, callback: v => (v >= 0 ? '+' : '') + v.toFixed(0) + '%' },
                                grid: { drawOnChartArea: false },
                                title: { display: false }
                            }
                        }
                    },
                    plugins: [getRecessionShadingPlugin()]
                });
            }
        }

        // Process High-Yield Spread
        function processHighYieldSpread(hySpreadData) {
            if (hySpreadData.length === 0) {
                document.getElementById('hySpread').textContent = 'Insufficient data';
                return;
            }
            
            const latest = hySpreadData[hySpreadData.length - 1];
            const previous = hySpreadData.length > 1 ? hySpreadData[hySpreadData.length - 2] : latest;
            const trend = latest.value - previous.value;
            
            // Update display
            document.getElementById('hySpread').textContent = latest.value.toFixed(2) + '%';
            
            const hyDateEl = document.getElementById('hySpreadLatestDate');
            if (hyDateEl) hyDateEl.textContent = formatLatestDate(latest.date);
            
            // Status and analysis
            const statusEl = document.getElementById('hyStatus');
            const analysisEl = document.getElementById('hyAnalysis');
            
            let statusText = '';
            let statusClass = '';
            let analysisText = '';
            
            if (latest.value >= 7 && trend < 0) {
                statusText = '✓ BUY SIGNAL';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                analysisText = `Spread spiked above 7% and is now declining. This historically marks generational buying opportunities (2009, 2016, 2020). Credit markets are stabilizing after stress.`;
            } else if (latest.value >= 7) {
                statusText = '⚠️ HIGH STRESS';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisText = `Spread is above 7% - credit markets are under severe stress. Wait for spread to start declining before buying.`;
            } else if (latest.value < 3.5) {
                statusText = '⚠️ PRICED FOR PERFECTION';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                analysisText = `Spread below 3.5% - markets are "priced for perfection." S&P 500 is most vulnerable to sharp corrections. Credit risk is being ignored.`;
            } else {
                statusText = '✓ NORMAL';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-blue-900/30 text-blue-400 border border-blue-700';
                analysisText = `Spread is in normal range (3.5-7%). Credit markets are functioning normally.`;
            }
            
            statusEl.textContent = statusText;
            statusEl.className = statusClass;
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('hySpreadChart');
            if (hySpreadChartInstance) {
                hySpreadChartInstance.destroy();
            }
            
            const labels = hySpreadData.map(d => d.date);
            const values = hySpreadData.map(d => d.value);
            const buyThreshold = new Array(hySpreadData.length).fill(7);
            const cautionThreshold = new Array(hySpreadData.length).fill(3.5);
            
            hySpreadChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'High-Yield Spread (%)',
                        data: values,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Buy Signal Threshold (7%)',
                        data: buyThreshold,
                        borderColor: '#10b981',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Caution Threshold (3.5%)',
                        data: cautionThreshold,
                        borderColor: '#f59e0b',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
            
        }
        
        // Process NFCI
        function processNFCI(nfciData) {
            if (nfciData.length === 0) {
                document.getElementById('nfciValue').textContent = 'Insufficient data';
                return;
            }
            
            const latest = nfciData[nfciData.length - 1];
            const previous = nfciData.length > 1 ? nfciData[nfciData.length - 2] : latest;
            const trend = latest.value - previous.value;
            
            // Update display
            document.getElementById('nfciValue').textContent = latest.value.toFixed(3);
            
            const nfciDateEl = document.getElementById('nfciLatestDate');
            if (nfciDateEl) nfciDateEl.textContent = formatLatestDate(latest.date);
            
            // Status and analysis
            const statusEl = document.getElementById('nfciStatus');
            const analysisEl = document.getElementById('nfciAnalysis');
            
            let statusText = '';
            let statusClass = '';
            let analysisText = '';
            
            if (latest.value < -0.5) {
                statusText = '⚠️ EXTREMELY LOOSE';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                analysisText = `NFCI is deeply negative (below -0.5). Financial conditions are extremely loose. Markets often peak when conditions can't get any looser. Be cautious of potential tops.`;
            } else if (latest.value > 0.5 && trend < 0) {
                statusText = '✓ BOTTOMING';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                analysisText = `NFCI peaked above 0.5 and is now retreating. This indicates the liquidity crunch is easing. S&P 500 usually bottoms when NFCI starts declining from high positive levels.`;
            } else if (latest.value > 0.5) {
                statusText = '⚠️ LIQUIDITY CRUNCH';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisText = `NFCI is above 0.5 - indicates severe liquidity crunch. Financial system plumbing is stressed. S&P 500 cannot sustain rallies under these conditions.`;
            } else if (latest.value > 0) {
                statusText = '⚠️ TIGHTENING';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-orange-900/30 text-orange-400 border border-orange-700';
                analysisText = `NFCI is positive - financial conditions are tighter than average. Watch for further tightening which could pressure markets.`;
            } else {
                statusText = '✓ NEUTRAL/LOOSE';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-blue-900/30 text-blue-400 border border-blue-700';
                analysisText = `NFCI is negative (loose conditions) but not extreme. Financial conditions are accommodative, supporting risk assets.`;
            }
            
            statusEl.textContent = statusText;
            statusEl.className = statusClass;
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('nfciChart');
            if (nfciChartInstance) {
                nfciChartInstance.destroy();
            }
            
            const labels = nfciData.map(d => d.date);
            const values = nfciData.map(d => d.value);
            const zeroLine = new Array(nfciData.length).fill(0);
            const looseThreshold = new Array(nfciData.length).fill(-0.5);
            const tightThreshold = new Array(nfciData.length).fill(0.5);
            
            nfciChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'NFCI',
                        data: values,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Zero (Average)',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Extremely Loose (-0.5)',
                        data: looseThreshold,
                        borderColor: '#f59e0b',
                        borderWidth: 1,
                        borderDash: [3, 3],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Liquidity Crunch (0.5)',
                        data: tightThreshold,
                        borderColor: '#ef4444',
                        borderWidth: 1,
                        borderDash: [3, 3],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
        }

        // Process CFNAI indicator (Chicago Fed National Activity Index)
        function processCFNAI(cfnaiData) {
            if (!cfnaiData || cfnaiData.length === 0) {
                document.getElementById('cfnaiValue').textContent = 'No data';
                return;
            }

            // Current value (most recent)
            const latest = cfnaiData[cfnaiData.length - 1];
            const latestValue = latest.value;
            
            // Update display
            document.getElementById('cfnaiValue').textContent = latestValue.toFixed(2);
            
            const cfnaiDateEl = document.getElementById('cfnaiLatestDate');
            if (cfnaiDateEl) cfnaiDateEl.textContent = formatLatestDate(latest.date);
            
            // Implement Rule of Thumb Logic
            const statusEl = document.getElementById('cfnaiStatus');
            const analysisEl = document.getElementById('cfnaiAnalysis');
            
            // To determine "following expansion/contraction", we need to look at historical state
            let isCurrentlyContraction = false;
            let everBelowThreshold = false;
            
            // Simple state machine to find current regime based on thresholds
            // Start assuming expansion (standard state)
            for (let i = 0; i < cfnaiData.length; i++) {
                const val = cfnaiData[i].value;
                if (!isCurrentlyContraction && val < -0.70) {
                    isCurrentlyContraction = true;
                    everBelowThreshold = true;
                } else if (isCurrentlyContraction && val > 0.20) {
                    isCurrentlyContraction = false;
                }
            }
            
            // Determine signal for the LATEST value
            if (latestValue < -0.70) {
                statusEl.textContent = '⚠️ RECESSION SIGNAL';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisEl.textContent = 'CFNAI-MA3 is below -0.70, indicating a significant likelihood that a recession has begun.';
            } else if (isCurrentlyContraction && latestValue > -0.70 && latestValue <= 0.20) {
                statusEl.textContent = '📈 EXPANSION LIKELY';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                analysisEl.textContent = 'CFNAI-MA3 has moved back above -0.70 after a dip, indicating an increasing likelihood that the recession has ended (though not yet confirmed by the +0.20 threshold).';
            } else if (latestValue > 0.20) {
                if (latestValue > 0.70) {
                    statusEl.textContent = '🔥 INFLATION RISK';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-orange-900/30 text-orange-400 border border-orange-700';
                    analysisEl.textContent = 'CFNAI-MA3 is above +0.70. If sustained, this indicates an increasing likelihood of rising inflation.';
                } else {
                    statusEl.textContent = '✓ EXPANSION';
                    statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                    analysisEl.textContent = 'CFNAI-MA3 is above +0.20, indicating a significant likelihood that the economy is in an expansionary phase.';
                }
            } else {
                // Between -0.70 and 0.20 but not currently in a "contraction recovery" state
                statusEl.textContent = '✓ NEUTRAL';
                statusEl.className = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-blue-900/30 text-blue-400 border border-blue-700';
                analysisEl.textContent = 'The economy is growing near its historical trend. No immediate recession or inflation signals.';
            }
            
            // Create chart
            const ctx = document.getElementById('cfnaiChart');
            if (cfnaiChartInstance) {
                cfnaiChartInstance.destroy();
            }
            
            const labels = cfnaiData.map(d => d.date);
            const values = cfnaiData.map(d => d.value);
            const zeroLine = new Array(cfnaiData.length).fill(0);
            const recessionThreshold = new Array(cfnaiData.length).fill(-0.70);
            const expansionThreshold = new Array(cfnaiData.length).fill(0.20);
            
            cfnaiChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'CFNAI-MA3',
                        data: values,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }, {
                        label: 'Recession Threshold (-0.70)',
                        data: recessionThreshold,
                        borderColor: '#ef4444',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }, {
                        label: 'Expansion Threshold (+0.20)',
                        data: expansionThreshold,
                        borderColor: '#10b981',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#9ca3af', font: { size: 10 }, boxWidth: 12 }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#9ca3af', font: { size: 9 } },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            min: -2,
                            max: 2,
                            ticks: { color: '#9ca3af', font: { size: 9 } },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
        }

        // Process Equity Risk Premium
        function processEquityRiskPremium(sp500Data, sp500EarningsData, yield10YData) {
            // Align dates and calculate ERP
            const erpData = [];
            const dateMap = new Map();
            
            sp500Data.forEach(item => dateMap.set(item.date, { sp500: item.value }));
            yield10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).yield10Y = item.value;
                }
            });
            
            // Try to use earnings data if available, otherwise estimate from historical P/E
            let useEarningsData = sp500EarningsData.length > 0;
            if (useEarningsData) {
                sp500EarningsData.forEach(item => {
                    if (dateMap.has(item.date)) {
                        dateMap.get(item.date).earnings = item.value;
                    }
                });
            }
            
            // Default P/E ratio to use if earnings data not available (historical average ~20)
            const defaultPE = 20;
            
            dateMap.forEach((values, date) => {
                if (values.sp500 !== undefined && values.yield10Y !== undefined) {
                    let earningsYield;
                    
                    if (useEarningsData && values.earnings !== undefined) {
                        // Earnings Yield = Earnings / Price
                        earningsYield = (values.earnings / values.sp500) * 100;
                        
                        // Resilience: Detect if earnings data is likely economy-wide profits (billions) 
                        // instead of S&P 500 per-share earnings.
                        // Normal S&P 500 earnings yield is 3% to 10%. If it's > 20%, it's likely a unit mismatch.
                        if (earningsYield > 20) {
                            console.warn(`ERP Calculation: Detected likely unit mismatch in earnings data (${values.earnings.toFixed(2)} vs price ${values.sp500.toFixed(2)}). Using historical average yield instead.`);
                            earningsYield = (1 / defaultPE) * 100;
                        }
                    } else {
                        // Estimate: Earnings Yield ≈ 1 / P/E Ratio
                        earningsYield = (1 / defaultPE) * 100;
                    }
                    
                    const erp = earningsYield - values.yield10Y;
                    erpData.push({
                        date: date,
                        value: erp,
                        earningsYield: earningsYield,
                        treasuryYield: values.yield10Y
                    });
                }
            });
            
            if (erpData.length === 0) {
                document.getElementById('erpValue').textContent = 'Insufficient data';
                return;
            }
            
            const latest = erpData[erpData.length - 1];
            
            // Update display
            document.getElementById('erpValue').textContent = (latest.value >= 0 ? '+' : '') + latest.value.toFixed(2) + '%';
            document.getElementById('earningsYield').textContent = latest.earningsYield.toFixed(2) + '%';
            document.getElementById('treasury10Y').textContent = latest.treasuryYield.toFixed(2) + '%';
            
            // Status and analysis
            const statusEl = document.getElementById('erpStatus');
            const analysisEl = document.getElementById('erpAnalysis');
            
            let statusText = '';
            let statusClass = '';
            let analysisText = '';
            
            if (latest.value > 3) {
                statusText = '✓ UNDERVALUED';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                analysisText = `High ERP (${latest.value.toFixed(2)}%) - stocks are undervalued relative to bonds. Large gap means investors are being well-compensated for equity risk.`;
            } else if (latest.value < 0) {
                statusText = '⚠️ EXPENSIVE';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisText = `Negative ERP - stocks are expensive. Treasury yield (${latest.treasuryYield.toFixed(2)}%) exceeds earnings yield (${latest.earningsYield.toFixed(2)}%). S&P 500 can crash even with good earnings if bond yields rise too fast.`;
            } else if (latest.value < 1) {
                statusText = '⚠️ LOW PREMIUM';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                analysisText = `Low ERP (${latest.value.toFixed(2)}%) - stocks offer minimal premium over bonds. Not being paid enough for equity risk.`;
            } else {
                statusText = '✓ FAIR VALUE';
                statusClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-blue-900/30 text-blue-400 border border-blue-700';
                analysisText = `ERP in normal range (${latest.value.toFixed(2)}%). Stocks are fairly valued relative to bonds.`;
            }
            
            statusEl.textContent = statusText;
            statusEl.className = statusClass;
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('erpChart');
            if (erpChartInstance) {
                erpChartInstance.destroy();
            }
            
            const labels = erpData.map(d => d.date);
            const erpValues = erpData.map(d => d.value);
            
            // Calculate historical quartiles
            const sortedValues = [...erpValues].sort((a, b) => a - b);
            const q1 = sortedValues[Math.floor(sortedValues.length * 0.25)];
            const median = sortedValues[Math.floor(sortedValues.length * 0.50)];
            const q3 = sortedValues[Math.floor(sortedValues.length * 0.75)];
            
            const q1Line = new Array(erpData.length).fill(q1);
            const medianLine = new Array(erpData.length).fill(median);
            const q3Line = new Array(erpData.length).fill(q3);
            const zeroLine = new Array(erpData.length).fill(0);
            
            erpChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Equity Risk Premium (%)',
                        data: erpValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '75th Pctl (Cheap)',
                        data: q3Line,
                        borderColor: 'rgba(16, 185, 129, 0.7)',
                        borderWidth: 1.5,
                        borderDash: [2, 2],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Median',
                        data: medianLine,
                        borderColor: 'rgba(148, 163, 184, 0.7)',
                        borderWidth: 1.5,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '25th Pctl (Expensive)',
                        data: q1Line,
                        borderColor: 'rgba(239, 68, 68, 0.7)',
                        borderWidth: 1.5,
                        borderDash: [2, 2],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: 'rgba(156, 163, 175, 0.8)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
        }
        
        // Process Combined Signals (VIX + High-Yield Spread + NFCI)
        function processCombinedSignals(vixData, hySpreadData, nfciData) {
            // Align dates across all three datasets
            const combinedData = [];
            const dateMap = new Map();
            
            vixData.forEach(item => dateMap.set(item.date, { vix: item.value }));
            hySpreadData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).hySpread = item.value;
                }
            });
            nfciData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).nfci = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.vix !== undefined && values.hySpread !== undefined && values.nfci !== undefined) {
                    combinedData.push({
                        date: date,
                        vix: values.vix,
                        hySpread: values.hySpread,
                        nfci: values.nfci
                    });
                }
            });
            
            if (combinedData.length < 2) {
                document.getElementById('vixCurrent').textContent = 'Insufficient data';
                return;
            }
            
            // Sort by date
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData[combinedData.length - 2];
            const twoWeeksAgo = combinedData.length > 10 ? combinedData[combinedData.length - 11] : previous;
            const oneMonthAgo = combinedData.length > 20 ? combinedData[combinedData.length - 21] : twoWeeksAgo;
            
            // Calculate trends (1-day, 2-week, 1-month)
            const vixTrend = latest.vix - previous.vix;
            const hyTrend = latest.hySpread - previous.hySpread;
            const nfciTrend = latest.nfci - previous.nfci;
            const vixTwoWeekTrend = latest.vix - twoWeeksAgo.vix;
            const hyTwoWeekTrend = latest.hySpread - twoWeeksAgo.hySpread;
            const nfciTwoWeekTrend = latest.nfci - twoWeeksAgo.nfci;
            const vixOneMonthTrend = latest.vix - oneMonthAgo.vix;
            const hyOneMonthTrend = latest.hySpread - oneMonthAgo.hySpread;
            const nfciOneMonthTrend = latest.nfci - oneMonthAgo.nfci;
            
            // Calculate momentum (rate of change)
            const vixMomentum = vixTwoWeekTrend / Math.max(Math.abs(twoWeeksAgo.vix), 1) * 100;
            const hyMomentum = hyTwoWeekTrend / Math.max(Math.abs(twoWeeksAgo.hySpread), 0.1) * 100;
            const nfciMomentum = nfciTwoWeekTrend / Math.max(Math.abs(twoWeeksAgo.nfci), 0.01) * 100;
            
            // Update current values display
            document.getElementById('vixCurrent').textContent = latest.vix.toFixed(2);
            document.getElementById('hyCurrent').textContent = latest.hySpread.toFixed(2) + '%';
            document.getElementById('nfciCurrent').textContent = latest.nfci.toFixed(3);
            
            // Detect patterns
            const statusEl = document.getElementById('combinedSignal');
            const analysisEl = document.getElementById('combinedAnalysis');
            
            let signalText = '';
            let signalClass = '';
            let analysisText = '';
            
            // ENTRY SIGNALS (Buy Opportunities)
            
            // Pattern 1: Triple Confirmation Bottom (STRONGEST BUY)
            // VIX > 35, Spread > 7%, NFCI > 0.5 AND all three declining together
            if (latest.vix > 35 && latest.hySpread > 7 && latest.nfci > 0.5 && 
                vixTrend < 0 && hyTrend < 0 && nfciTrend < 0 &&
                vixTwoWeekTrend < -2 && hyTwoWeekTrend < -0.5 && nfciTwoWeekTrend < -0.1) {
                signalText = '🚀 TRIPLE CONFIRMATION BOTTOM - STRONG BUY';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border-2 border-green-500';
                analysisText = `POWERFUL ENTRY SIGNAL: VIX (${latest.vix.toFixed(2)}), High-Yield Spread (${latest.hySpread.toFixed(2)}%), and NFCI (${latest.nfci.toFixed(3)}) all spiked and are declining together. This is the strongest buy signal - all three risk indicators are stabilizing simultaneously. Historical examples: 2009, 2016, 2020 bottoms. Momentum: VIX ${vixMomentum.toFixed(1)}%, Spread ${hyMomentum.toFixed(1)}%, NFCI ${nfciMomentum.toFixed(1)}%.`;
            }
            // Pattern 2: Double Confirmation Bottom (STRONG BUY)
            // VIX > 35 AND Spread > 7% AND both declining (with momentum)
            else if (latest.vix > 35 && latest.hySpread > 7 && 
                     vixTrend < 0 && hyTrend < 0 && 
                     (vixTwoWeekTrend < -2 || hyTwoWeekTrend < -0.5)) {
                const nfciConfirmation = latest.nfci > 0.3 && nfciTrend < 0 ? 'NFCI also declining' : 
                                        latest.nfci < 0 ? 'NFCI already normalized' : 'NFCI still elevated';
                signalText = '✓ DOUBLE CONFIRMATION BOTTOM - BUY';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                analysisText = `STRONG BUY SIGNAL: VIX (${latest.vix.toFixed(2)}) and High-Yield Spread (${latest.hySpread.toFixed(2)}%) both spiked and are declining together. ${nfciConfirmation} (${latest.nfci.toFixed(3)}). This historically marks major S&P 500 bottoms. Both credit and volatility markets are stabilizing. Momentum: VIX ${vixMomentum.toFixed(1)}%, Spread ${hyMomentum.toFixed(1)}%.`;
            }
            // Pattern 3: Panic Peak with Credit Stability (OPPORTUNISTIC BUY)
            // VIX > 40 with flat/declining Spread and NFCI not spiking
            else if (latest.vix > 40 && Math.abs(hyTrend) < 0.5 && latest.hySpread < 8 && latest.nfci < 0.5) {
                signalText = '⚠️ PANIC PEAK - OPPORTUNISTIC BUY';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-orange-900/30 text-orange-400 border border-orange-700';
                analysisText = `OPPORTUNISTIC ENTRY: VIX spike (${latest.vix.toFixed(2)}) with stable High-Yield Spread (${latest.hySpread.toFixed(2)}%) and NFCI (${latest.nfci.toFixed(3)}). This indicates emotional selling/flash crash rather than a deep recessionary bear market. Credit markets remain stable. Consider buying if fundamentals remain intact.`;
            }
            // Pattern 4: NFCI Divergence Buy (EARLY ENTRY)
            // NFCI declining while VIX/Spread still elevated but stabilizing
            else if (latest.nfci > 0.3 && nfciTrend < -0.05 && nfciTwoWeekTrend < -0.15 &&
                     latest.vix > 25 && vixTrend < 1 && latest.hySpread > 5 && hyTrend < 0.3) {
                signalText = '📈 NFCI DIVERGENCE - EARLY BUY';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-emerald-900/30 text-emerald-400 border border-emerald-700';
                analysisText = `EARLY ENTRY SIGNAL: NFCI (${latest.nfci.toFixed(3)}) is declining rapidly (${nfciMomentum.toFixed(1)}%) while VIX (${latest.vix.toFixed(2)}) and Spread (${latest.hySpread.toFixed(2)}%) are elevated but stabilizing. Financial conditions improving ahead of credit/volatility markets. Early indicator of risk normalization.`;
            }
            
            // EXIT SIGNALS (Sell/Trim Warnings)
            
            // Pattern 5: Quiet Risk Divergence (EXIT WARNING)
            // Low VIX but Spread and/or NFCI rising
            else if (latest.vix < 20 && (hyTrend > 0.2 || (latest.hySpread > 5 && hyTwoWeekTrend > 0.5))) {
                const nfciWarning = latest.nfci > 0.2 && nfciTrend > 0 ? `NFCI also rising (${latest.nfci.toFixed(3)})` : '';
                signalText = '⚠️ QUIET RISK DIVERGENCE - EXIT WARNING';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                analysisText = `EXIT SIGNAL: VIX is low (${latest.vix.toFixed(2)}) but High-Yield Spread is rising (${latest.hySpread.toFixed(2)}%, +${hyTrend.toFixed(2)}% change, ${hyMomentum.toFixed(1)}% momentum). ${nfciWarning}. Bond markets are sensing trouble that equity traders haven't noticed yet. This is a major warning to trim S&P 500 positions.`;
            }
            // Pattern 6: Triple Risk Escalation (STRONG EXIT)
            // All three indicators rising together from elevated levels
            else if (latest.vix > 25 && latest.hySpread > 5 && latest.nfci > 0.2 &&
                     vixTrend > 0 && hyTrend > 0 && nfciTrend > 0 &&
                     (vixTwoWeekTrend > 2 || hyTwoWeekTrend > 0.5 || nfciTwoWeekTrend > 0.1)) {
                signalText = '🔴 TRIPLE RISK ESCALATION - STRONG EXIT';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border-2 border-red-500';
                analysisText = `STRONG EXIT SIGNAL: VIX (${latest.vix.toFixed(2)}), High-Yield Spread (${latest.hySpread.toFixed(2)}%), and NFCI (${latest.nfci.toFixed(3)}) are all elevated and rising together. All three risk indicators deteriorating simultaneously. This suggests systemic stress building. Consider significant position reduction. Momentum: VIX ${vixMomentum.toFixed(1)}%, Spread ${hyMomentum.toFixed(1)}%, NFCI ${nfciMomentum.toFixed(1)}%.`;
            }
            // Pattern 7: NFCI Spike Warning (EARLY EXIT)
            // NFCI spiking while VIX/Spread still low
            else if (latest.nfci > 0.3 && nfciTrend > 0.05 && nfciTwoWeekTrend > 0.15 &&
                     latest.vix < 25 && latest.hySpread < 6) {
                signalText = '⚠️ NFCI SPIKE - EARLY EXIT WARNING';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-amber-900/30 text-amber-400 border border-amber-700';
                analysisText = `EARLY EXIT WARNING: NFCI (${latest.nfci.toFixed(3)}) is spiking (${nfciMomentum.toFixed(1)}%) while VIX (${latest.vix.toFixed(2)}) and Spread (${latest.hySpread.toFixed(2)}%) are still low. Financial conditions deteriorating ahead of credit/volatility markets. Early indicator of stress building. Consider defensive positioning.`;
            }
            // Pattern 8: Both elevated but not declining together (WAIT)
            else if (latest.vix > 35 && latest.hySpread > 7) {
                const nfciStatus = latest.nfci > 0.5 ? `NFCI also very elevated (${latest.nfci.toFixed(3)})` : 
                                   latest.nfci > 0.3 ? `NFCI elevated (${latest.nfci.toFixed(3)})` : 
                                   `NFCI normalized (${latest.nfci.toFixed(3)})`;
                signalText = '⚠️ ELEVATED RISK - WAIT FOR CONFIRMATION';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisText = `CAUTION: Both VIX (${latest.vix.toFixed(2)}) and Spread (${latest.hySpread.toFixed(2)}%) are elevated. ${nfciStatus}. Wait for all indicators to decline together for confirmation of a bottom. Currently: VIX ${vixTrend >= 0 ? 'rising' : 'declining'} (${vixMomentum.toFixed(1)}%), Spread ${hyTrend >= 0 ? 'rising' : 'declining'} (${hyMomentum.toFixed(1)}%), NFCI ${nfciTrend >= 0 ? 'rising' : 'declining'} (${nfciMomentum.toFixed(1)}%).`;
            }
            // Pattern 9: Normal conditions (HOLD)
            else {
                const allLow = latest.vix < 20 && latest.hySpread < 5 && latest.nfci < 0.2;
                const allDeclining = vixTrend < 0 && hyTrend < 0 && nfciTrend < 0;
                const status = allLow && allDeclining ? 'Favorable conditions, slight bullish bias' : 
                              allLow ? 'Normal range, monitor for changes' : 
                              'Normal range, no extreme signals';
                signalText = '✓ NORMAL CONDITIONS - HOLD';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-blue-900/30 text-blue-400 border border-blue-700';
                analysisText = `${status}. VIX: ${latest.vix.toFixed(2)} (${vixTrend >= 0 ? '+' : ''}${vixTrend.toFixed(2)}), Spread: ${latest.hySpread.toFixed(2)}% (${hyTrend >= 0 ? '+' : ''}${hyTrend.toFixed(2)}%), NFCI: ${latest.nfci.toFixed(3)} (${nfciTrend >= 0 ? '+' : ''}${nfciTrend.toFixed(3)}). Momentum: VIX ${vixMomentum.toFixed(1)}%, Spread ${hyMomentum.toFixed(1)}%, NFCI ${nfciMomentum.toFixed(1)}%. Monitor for pattern development.`;
            }
            
            statusEl.textContent = signalText;
            statusEl.className = signalClass;
            analysisEl.textContent = analysisText;
            
            // Create combined chart with dual Y-axes
            const ctx = document.getElementById('combinedChart');
            if (combinedChartInstance) {
                combinedChartInstance.destroy();
            }
            
            const labels = combinedData.map(d => d.date);
            const vixValues = combinedData.map(d => d.vix);
            const hyValues = combinedData.map(d => d.hySpread);
            const nfciValues = combinedData.map(d => d.nfci);
            
            // Threshold lines
            const vix35Line = new Array(combinedData.length).fill(35);
            const vix40Line = new Array(combinedData.length).fill(40);
            const hy7Line = new Array(combinedData.length).fill(7);
            
            // Normalize NFCI to a visible scale (multiply by 10 to make it more visible)
            const nfciScaled = nfciValues.map(v => v * 10);
            
            combinedChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'VIX',
                            data: vixValues,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y'
                        },
                        {
                            label: 'High-Yield Spread (%)',
                            data: hyValues,
                            borderColor: '#60a5fa',
                            backgroundColor: 'rgba(96, 165, 250, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'NFCI (×10)',
                            data: nfciScaled,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 1.5,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y1',
                            borderDash: [3, 3]
                        },
                        {
                            label: 'VIX 35 (Buy Signal)',
                            data: vix35Line,
                            borderColor: '#f59e0b',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y'
                        },
                        {
                            label: 'VIX 40 (Panic)',
                            data: vix40Line,
                            borderColor: '#dc2626',
                            borderWidth: 1,
                            borderDash: [3, 3],
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Spread 7% (Buy Signal)',
                            data: hy7Line,
                            borderColor: '#3b82f6',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.datasetIndex === 2) {
                                        // NFCI - show actual value, not scaled
                                        label += (context.parsed.y / 10).toFixed(3);
                                    } else if (context.datasetIndex === 1 || context.datasetIndex === 5) {
                                        // High-Yield Spread
                                        label += context.parsed.y.toFixed(2) + '%';
                                    } else {
                                        // VIX
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: { 
                                color: '#ef4444',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(0); }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            title: {
                                display: true,
                                text: 'VIX',
                                color: '#ef4444'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: { 
                                color: '#60a5fa',
                                font: { size: 9 },
                                callback: function(value) { 
                                    // For NFCI scaled values, show as percentage
                                    if (value < 20) {
                                        return (value / 10).toFixed(1);
                                    }
                                    return value.toFixed(1) + '%'; 
                                }
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Spread (%) / NFCI',
                                color: '#60a5fa'
                            }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
            
        }
        
        // Process 3 Headed Monster (Oil, 10Y Yield, Dollar)
        function processThreeHeadedMonster(oilData, yield10YData, dollarData) {
            // Align dates across all three datasets
            const combinedData = [];
            const dateMap = new Map();
            
            oilData.forEach(item => dateMap.set(item.date, { oil: item.value }));
            yield10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).yield10Y = item.value;
                }
            });
            dollarData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).dollar = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.oil !== undefined && values.yield10Y !== undefined && values.dollar !== undefined) {
                    combinedData.push({
                        date: date,
                        oil: values.oil,
                        yield10Y: values.yield10Y,
                        dollar: values.dollar
                    });
                }
            });
            
            if (combinedData.length < 2) {
                document.getElementById('monsterOil').textContent = 'Insufficient data';
                return;
            }
            
            // Sort by date
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            
            // Calculate 30-day trends for more stability (if we have enough data)
            let oilTrend30 = 0;
            let yieldTrend30 = 0;
            let dollarTrend30 = 0;
            
            if (combinedData.length > 30) {
                const thirtyDaysAgo = combinedData[combinedData.length - 31];
                oilTrend30 = ((latest.oil - thirtyDaysAgo.oil) / thirtyDaysAgo.oil) * 100;
                yieldTrend30 = latest.yield10Y - thirtyDaysAgo.yield10Y;
                dollarTrend30 = ((latest.dollar - thirtyDaysAgo.dollar) / thirtyDaysAgo.dollar) * 100;
            } else {
                // Use shorter period if not enough data
                const period = Math.floor(combinedData.length / 3);
                if (period > 0) {
                    const periodAgo = combinedData[combinedData.length - 1 - period];
                    oilTrend30 = ((latest.oil - periodAgo.oil) / periodAgo.oil) * 100;
                    yieldTrend30 = latest.yield10Y - periodAgo.yield10Y;
                    dollarTrend30 = ((latest.dollar - periodAgo.dollar) / periodAgo.dollar) * 100;
                }
            }
            
            // Update current values display
            document.getElementById('monsterOil').textContent = '$' + latest.oil.toFixed(2);
            document.getElementById('monster10Y').textContent = latest.yield10Y.toFixed(2) + '%';
            document.getElementById('monsterDollar').textContent = latest.dollar.toFixed(2);
            
            // Detect pattern: all three moving in same direction
            const statusEl = document.getElementById('monsterStatus');
            const analysisEl = document.getElementById('monsterAnalysis');
            
            let signalText = '';
            let signalClass = '';
            let analysisText = '';
            
            // Check if all three are moving in the same direction (using 30-day trends for stability)
            const allRising = oilTrend30 > 0 && yieldTrend30 > 0 && dollarTrend30 > 0;
            const allFalling = oilTrend30 < 0 && yieldTrend30 < 0 && dollarTrend30 < 0;
            
            if (allFalling) {
                // All falling = tailwind for S&P 500
                signalText = '✓ TAILWIND FOR S&P 500';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-green-900/30 text-green-400 border border-green-700';
                analysisText = `All three indicators are declining together (Oil: ${oilTrend30.toFixed(1)}%, 10Y Yield: ${yieldTrend30.toFixed(2)}pp, Dollar: ${dollarTrend30.toFixed(1)}%). Lower oil prices, declining yields, and a weaker dollar create favorable conditions for stocks - lower costs, easier financial conditions, and improved competitiveness.`;
            } else if (allRising) {
                // All rising = headwind for S&P 500
                signalText = '⚠️ HEADWIND FOR S&P 500';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-red-900/30 text-red-400 border border-red-700';
                analysisText = `All three indicators are rising together (Oil: +${oilTrend30.toFixed(1)}%, 10Y Yield: +${yieldTrend30.toFixed(2)}pp, Dollar: +${dollarTrend30.toFixed(1)}%). Higher oil prices, rising yields, and a stronger dollar create headwinds for stocks - increased costs, tighter financial conditions, and reduced export competitiveness.`;
            } else {
                // Mixed signals
                signalText = '⚠️ MIXED SIGNALS';
                signalClass = 'inline-block px-4 py-2 rounded-full text-sm font-bold mb-4 bg-yellow-900/30 text-yellow-400 border border-yellow-700';
                const directions = [];
                if (oilTrend30 > 0) directions.push('Oil rising');
                else if (oilTrend30 < 0) directions.push('Oil falling');
                if (yieldTrend30 > 0) directions.push('Yields rising');
                else if (yieldTrend30 < 0) directions.push('Yields falling');
                if (dollarTrend30 > 0) directions.push('Dollar rising');
                else if (dollarTrend30 < 0) directions.push('Dollar falling');
                analysisText = `Indicators are moving in different directions (${directions.join(', ')}). Mixed signals create uncertainty - monitor for when all three align in the same direction for a clearer signal.`;
            }
            
            statusEl.textContent = signalText;
            statusEl.className = signalClass;
            analysisEl.textContent = analysisText;
            
            // Create chart with normalized percentage changes for visibility
            const ctx = document.getElementById('threeHeadedMonsterChart');
            if (threeHeadedMonsterChartInstance) {
                threeHeadedMonsterChartInstance.destroy();
            }
            
            const labels = combinedData.map(d => d.date);
            
            // Calculate percentage changes from a baseline (first value in dataset) for better visualization
            const baseline = combinedData[0];
            const oilPct = combinedData.map(d => ((d.oil - baseline.oil) / baseline.oil) * 100);
            const yieldPct = combinedData.map(d => ((d.yield10Y - baseline.yield10Y) / baseline.yield10Y) * 100);
            const dollarPct = combinedData.map(d => ((d.dollar - baseline.dollar) / baseline.dollar) * 100);
            
            threeHeadedMonsterChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Oil (WTI) % Change',
                        data: oilPct,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y'
                    }, {
                        label: '10Y Treasury Yield % Change',
                        data: yieldPct,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y'
                    }, {
                        label: 'US Dollar Index % Change',
                        data: dollarPct,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y'
                    }, {
                        label: 'Zero Line',
                        data: new Array(combinedData.length).fill(0),
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: {
                                    size: 10
                                },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.datasetIndex === 3) {
                                        return label + '0%';
                                    }
                                    return label + (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return (value >= 0 ? '+' : '') + value.toFixed(1) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                },
                plugins: [getRecessionShadingPlugin()]
            });
        }
        
        // Process HOPE Model (Housing, Orders, Profits, Employment)
        function processHOPEModel(housingStartsData, buildingPermitsData, homeSalesData,
                                  durableOrdersData, ismOrdersData, corporateProfitsData, sp500EarningsData,
                                  unrateData, payrollsData, joblessClaimsData, sp500Data) {
            
            // Helper function to get latest value and trend
            function getLatestAndTrend(data, monthsBack = 3) {
                if (!data || data.length === 0) return { latest: null, trend: null, trendPct: null };
                const sorted = [...data].sort((a, b) => new Date(a.date) - new Date(b.date));
                const latest = sorted[sorted.length - 1];
                const index = sorted.length - 1;
                const monthsAgoIndex = Math.max(0, index - monthsBack);
                const monthsAgo = sorted[monthsAgoIndex];
                const trend = latest.value - monthsAgo.value;
                const trendPct = monthsAgo.value !== 0 ? ((latest.value - monthsAgo.value) / Math.abs(monthsAgo.value)) * 100 : 0;
                return { latest: latest.value, trend, trendPct, date: latest.date };
            }
            
            // Get data for each component
            const housing = {
                starts: getLatestAndTrend(housingStartsData, 3),
                permits: getLatestAndTrend(buildingPermitsData, 3),
                sales: getLatestAndTrend(homeSalesData, 3)
            };
            
            const orders = {
                durable: getLatestAndTrend(durableOrdersData, 3),
                ism: getLatestAndTrend(ismOrdersData, 1) // ISM is monthly, use 1 month
            };
            
            const profits = {
                corporate: getLatestAndTrend(corporateProfitsData, 4), // Quarterly data
                sp500: getLatestAndTrend(sp500EarningsData, 4)
            };
            
            const employment = {
                unrate: getLatestAndTrend(unrateData, 3),
                payrolls: getLatestAndTrend(payrollsData, 3),
                claims: getLatestAndTrend(joblessClaimsData, 1) // Weekly data, use 1 month
            };
            
            // Determine status for each HOPE component
            // Housing: Weak if starts/permits declining significantly
            let housingStatus = 'HEALTHY';
            let housingWeak = false;
            if (housing.starts.latest !== null && housing.permits.latest !== null) {
                const housingDeclining = (housing.starts.trendPct < -5 || housing.permits.trendPct < -5);
                const housingStrongDecline = (housing.starts.trendPct < -10 || housing.permits.trendPct < -10);
                if (housingStrongDecline) {
                    housingStatus = 'WEAK';
                    housingWeak = true;
                } else if (housingDeclining) {
                    housingStatus = 'WEAKENING';
                    housingWeak = true;
                }
            }
            
            // Orders: Weak if durable goods orders declining and ISM below 50
            let ordersStatus = 'HEALTHY';
            let ordersWeak = false;
            if (orders.durable.latest !== null) {
                const ordersDeclining = orders.durable.trendPct < -3;
                const ismWeak = orders.ism.latest !== null && orders.ism.latest < 50;
                if (ordersDeclining && ismWeak) {
                    ordersStatus = 'WEAK';
                    ordersWeak = true;
                } else if (ordersDeclining || ismWeak) {
                    ordersStatus = 'WEAKENING';
                    ordersWeak = true;
                }
            }
            
            // Profits: Weak if declining
            let profitsStatus = 'HEALTHY';
            let profitsWeak = false;
            if (profits.corporate.latest !== null || profits.sp500.latest !== null) {
                const corporateDeclining = profits.corporate.latest !== null && profits.corporate.trendPct < -5;
                const sp500Declining = profits.sp500.latest !== null && profits.sp500.trendPct < -5;
                if (corporateDeclining || sp500Declining) {
                    profitsStatus = 'WEAK';
                    profitsWeak = true;
                } else if (profits.corporate.trendPct < -2 || profits.sp500.trendPct < -2) {
                    profitsStatus = 'WEAKENING';
                    profitsWeak = true;
                }
            }
            
            // Employment: Weak if unemployment rising and payrolls declining
            let employmentStatus = 'HEALTHY';
            let employmentWeak = false;
            if (employment.unrate.latest !== null) {
                const unrateRising = employment.unrate.trend > 0.3; // 0.3pp increase
                const payrollsDeclining = employment.payrolls.latest !== null && employment.payrolls.trend < -100000; // 100k job loss
                const claimsRising = employment.claims.latest !== null && employment.claims.trend > 20000; // 20k increase
                if ((unrateRising && payrollsDeclining) || claimsRising) {
                    employmentStatus = 'WEAK';
                    employmentWeak = true;
                } else if (unrateRising || payrollsDeclining) {
                    employmentStatus = 'WEAKENING';
                    employmentWeak = true;
                }
            }
            
            // Determine HOPE stage (0 = Healthy, 1 = Housing, 2 = Orders, 3 = Profits, 4 = Employment)
            let hopeStage = 0;
            let stageText = 'HEALTHY';
            let stageClass = 'bg-green-900/30 text-green-400 border border-green-700';
            let progressPercent = 0;
            
            if (employmentWeak) {
                hopeStage = 4;
                stageText = 'STAGE 4: EMPLOYMENT WEAKNESS';
                stageClass = 'bg-red-900/30 text-red-400 border-2 border-red-500';
                progressPercent = 100;
            } else if (profitsWeak) {
                hopeStage = 3;
                stageText = 'STAGE 3: PROFITS DECLINING';
                stageClass = 'bg-orange-900/30 text-orange-400 border-2 border-orange-500';
                progressPercent = 75;
            } else if (ordersWeak) {
                hopeStage = 2;
                stageText = 'STAGE 2: ORDERS WEAKENING';
                stageClass = 'bg-yellow-900/30 text-yellow-400 border-2 border-yellow-500';
                progressPercent = 50;
            } else if (housingWeak) {
                hopeStage = 1;
                stageText = 'STAGE 1: HOUSING WEAKNESS';
                stageClass = 'bg-amber-900/30 text-amber-400 border border-amber-700';
                progressPercent = 25;
            } else {
                stageText = 'HEALTHY - NO RECESSION SIGNALS';
                progressPercent = 0;
            }
            
            // Update UI elements
            document.getElementById('hopeHousingStatus').textContent = housingStatus;
            document.getElementById('hopeHousingStatus').className = `text-2xl font-bold mb-2 ${housingWeak ? 'text-red-400' : housingStatus === 'WEAKENING' ? 'text-yellow-400' : 'text-green-400'}`;
            document.getElementById('hopeHousingValue').textContent = housing.starts.latest !== null ? 
                `Starts: ${(housing.starts.latest / 1000).toFixed(1)}K` : 'No data';
            
            document.getElementById('hopeOrdersStatus').textContent = ordersStatus;
            document.getElementById('hopeOrdersStatus').className = `text-2xl font-bold mb-2 ${ordersWeak ? 'text-red-400' : ordersStatus === 'WEAKENING' ? 'text-yellow-400' : 'text-green-400'}`;
            document.getElementById('hopeOrdersValue').textContent = orders.durable.latest !== null ? 
                `Orders: $${(orders.durable.latest / 1000).toFixed(0)}B` : 'No data';
            
            document.getElementById('hopeProfitsStatus').textContent = profitsStatus;
            document.getElementById('hopeProfitsStatus').className = `text-2xl font-bold mb-2 ${profitsWeak ? 'text-red-400' : profitsStatus === 'WEAKENING' ? 'text-yellow-400' : 'text-green-400'}`;
            document.getElementById('hopeProfitsValue').textContent = profits.corporate.latest !== null ? 
                `Profits: $${(profits.corporate.latest / 1000).toFixed(1)}T` : 'No data';
            
            document.getElementById('hopeEmploymentStatus').textContent = employmentStatus;
            document.getElementById('hopeEmploymentStatus').className = `text-2xl font-bold mb-2 ${employmentWeak ? 'text-red-400' : employmentStatus === 'WEAKENING' ? 'text-yellow-400' : 'text-green-400'}`;
            document.getElementById('hopeEmploymentValue').textContent = employment.unrate.latest !== null ? 
                `Unemployment: ${employment.unrate.latest.toFixed(1)}%` : 'No data';
            
            // Update stage indicator
            document.getElementById('hopeStageIndicator').textContent = stageText;
            document.getElementById('hopeStageIndicator').className = `inline-block px-6 py-3 rounded-lg text-lg font-bold mb-3 ${stageClass}`;
            
            // Update progress bar
            document.getElementById('hopeProgressBar').style.width = `${progressPercent}%`;
            document.getElementById('hopeProgressText').textContent = stageText;
            
            // Generate analysis text based on Kantrowitz's sequential HOPE model methodology
            // The model tracks sequential weakening during Fed tightening cycles (12-18 month lag)
            // Key insight: Sequential progression is more concerning than isolated later-stage weakness
            let analysisText = '';
            const healthyCount = [housingWeak, ordersWeak, profitsWeak, employmentWeak].filter(w => !w).length;
            const weakCount = 4 - healthyCount;
            
            // Check if the progression is sequential (earlier stages weak before later ones)
            // This is the typical Fed tightening cycle pattern
            const isSequential = (housingWeak && ordersWeak) || 
                                (housingWeak && ordersWeak && profitsWeak) ||
                                (housingWeak && ordersWeak && profitsWeak && employmentWeak);
            
            // Check for "skipped stages" - later stages weak while earlier ones healthy (atypical)
            const hasSkippedStages = (!housingWeak && (ordersWeak || profitsWeak || employmentWeak)) ||
                                    (!housingWeak && !ordersWeak && (profitsWeak || employmentWeak)) ||
                                    (!housingWeak && !ordersWeak && !profitsWeak && employmentWeak);
            
            if (hopeStage === 0) {
                analysisText = 'All HOPE components are healthy. No recession signals detected. Housing, orders, profits, and employment are all in good shape. The economy shows no signs of the typical Fed tightening cycle impact sequence.';
            } else if (hopeStage === 1) {
                // Only Housing weak - earliest stage, least concerning if isolated
                analysisText = `Early warning (Stage 1): Housing market showing weakness - the first indicator to respond to Fed tightening (typically 3-6 months). This is expected during rate hikes. Monitor orders, profits, and employment for sequential progression. ${healthyCount} of 4 components remain healthy.`;
            } else if (hopeStage === 2) {
                // Housing + Orders weak - shows sequential progression
                if (isSequential) {
                    analysisText = `Recession risk increasing (Stage 2): Sequential progression detected - Housing and Orders weakening as expected in Fed tightening cycles (6-9 month lag). This follows Kantrowitz's HOPE model pattern. Watch for profit compression (Stage 3) and eventual employment impacts (Stage 4). ${healthyCount} of 4 components remain healthy.`;
                } else {
                    analysisText = `Recession risk increasing (Stage 2): Housing and Orders weakening, but progression is not fully sequential. This suggests demand is declining. Watch for profit compression and eventual employment impacts. ${healthyCount} of 4 components remain healthy.`;
                }
            } else if (hopeStage === 3) {
                // Housing + Orders + Profits weak - strong sequential signal
                if (isSequential) {
                    analysisText = `High recession risk (Stage 3): Classic sequential progression - Housing → Orders → Profits weakening as per Kantrowitz's HOPE model (9-12 month Fed policy lag). This is the typical recession progression pattern. Employment (Stage 4) typically weakens next. ${healthyCount} of 4 components remain healthy.`;
                } else {
                    analysisText = `High recession risk (Stage 3): Housing, Orders, and Profits weakening, but progression shows some atypical patterns. This is a classic recession progression, though not fully sequential. Employment typically weakens next. ${healthyCount} of 4 components remain healthy.`;
                }
            } else {
                // Stage 4 - Employment weak
                if (healthyCount === 3) {
                    // Only Employment weak - atypical, less concerning
                    analysisText = `Atypical pattern (Stage 4): Employment showing weakness while Housing, Orders, and Profits remain healthy. This does NOT follow Kantrowitz's typical sequential HOPE model pattern (where Employment weakens last, after earlier stages). This may indicate non-Fed-related employment dynamics or data anomalies. ${healthyCount} of 4 components remain healthy.`;
                } else if (healthyCount === 2 && !housingWeak && !ordersWeak) {
                    // Profits and Employment weak, but Housing and Orders healthy - very atypical
                    analysisText = `Atypical pattern (Stage 4): Employment and Profits weak, but Housing and Orders remain healthy. This contradicts Kantrowitz's sequential HOPE model (should progress Housing → Orders → Profits → Employment). May indicate different economic dynamics than typical Fed tightening cycle. ${healthyCount} of 4 components remain healthy.`;
                } else if (isSequential && healthyCount === 0) {
                    // Full sequential progression - most concerning
                    analysisText = `Full recessionary environment (Stage 4): Complete sequential HOPE progression - Housing → Orders → Profits → Employment all weakening. This matches Kantrowitz's model of Fed tightening cycle impacts (12-18 month full cycle). All four components deteriorating indicates a full recessionary environment.`;
                } else if (isSequential) {
                    // Sequential but not all weak
                    analysisText = `Critical stage (Stage 4): Employment weakening with sequential progression from earlier stages. This follows Kantrowitz's HOPE model pattern showing Fed policy impacts cascading through the economy (12-18 month cycle). ${healthyCount} of 4 components remain healthy, but the sequential pattern is concerning.`;
                } else {
                    // Mixed pattern
                    analysisText = `Critical stage (Stage 4): Employment showing weakness. ${healthyCount} of 4 components remain healthy, but the pattern does not fully match Kantrowitz's sequential HOPE model progression. Mixed signals suggest complex economic dynamics beyond typical Fed tightening cycle impacts.`;
                }
            }
            
            document.getElementById('hopeStageAnalysis').textContent = analysisText;
            
            // Latest update date (most recent across all HOPE data sources)
            const hopeDates = [housing.starts.date, housing.permits.date, housing.sales.date,
                orders.durable.date, orders.ism.date, profits.corporate.date, profits.sp500.date,
                employment.unrate.date, employment.payrolls.date, employment.claims.date]
                .filter(d => d).map(d => new Date(d));
            const hopeLatestDate = hopeDates.length > 0 ? new Date(Math.max(...hopeDates)).toISOString().split('T')[0] : null;
            const hopeDateEl = document.getElementById('hopeLatestDate');
            if (hopeDateEl) hopeDateEl.textContent = formatLatestDate(hopeLatestDate);
            
            // Update detailed indicators
            document.getElementById('hopeHousingStarts').textContent = housing.starts.latest !== null ? 
                `${(housing.starts.latest / 1000).toFixed(1)}K (${housing.starts.trendPct >= 0 ? '+' : ''}${housing.starts.trendPct.toFixed(1)}%)` : '--';
            document.getElementById('hopeBuildingPermits').textContent = housing.permits.latest !== null ? 
                `${(housing.permits.latest / 1000).toFixed(1)}K (${housing.permits.trendPct >= 0 ? '+' : ''}${housing.permits.trendPct.toFixed(1)}%)` : '--';
            document.getElementById('hopeHomeSales').textContent = housing.sales.latest !== null ? 
                `${(housing.sales.latest / 1000).toFixed(1)}K (${housing.sales.trendPct >= 0 ? '+' : ''}${housing.sales.trendPct.toFixed(1)}%)` : '--';
            document.getElementById('hopeHousingAnalysis').textContent = housingWeak ? 
                'Housing indicators showing weakness - first stage of recession progression' : 
                'Housing indicators healthy';
            
            document.getElementById('hopeDurableOrders').textContent = orders.durable.latest !== null ? 
                `$${(orders.durable.latest / 1000).toFixed(0)}B (${orders.durable.trendPct >= 0 ? '+' : ''}${orders.durable.trendPct.toFixed(1)}%)` : '--';
            document.getElementById('hopeISMOrders').textContent = orders.ism.latest !== null ? 
                `${orders.ism.latest.toFixed(1)} (${orders.ism.trend >= 0 ? '+' : ''}${orders.ism.trend.toFixed(1)})` : '--';
            document.getElementById('hopeOrdersTrend').textContent = ordersWeak ? 'Declining' : 'Stable/Increasing';
            document.getElementById('hopeOrdersAnalysis').textContent = ordersWeak ? 
                'Orders weakening - demand declining' : 
                'Orders healthy';
            
            document.getElementById('hopeCorporateProfits').textContent = profits.corporate.latest !== null ? 
                `$${(profits.corporate.latest / 1000).toFixed(1)}T (${profits.corporate.trendPct >= 0 ? '+' : ''}${profits.corporate.trendPct.toFixed(1)}%)` : '--';
            document.getElementById('hopeSP500Earnings').textContent = profits.sp500.latest !== null ? 
                `$${profits.sp500.latest.toFixed(2)} (${profits.sp500.trendPct >= 0 ? '+' : ''}${profits.sp500.trendPct.toFixed(1)}%)` : '--';
            document.getElementById('hopeProfitsTrend').textContent = profitsWeak ? 'Declining' : 'Stable/Increasing';
            document.getElementById('hopeProfitsAnalysis').textContent = profitsWeak ? 
                'Profits declining - business impact visible' : 
                'Profits healthy';
            
            document.getElementById('hopeUnemployment').textContent = employment.unrate.latest !== null ? 
                `${employment.unrate.latest.toFixed(2)}% (${employment.unrate.trend >= 0 ? '+' : ''}${employment.unrate.trend.toFixed(2)}pp)` : '--';
            document.getElementById('hopePayrolls').textContent = employment.payrolls.latest !== null ? 
                `${(employment.payrolls.trend / 1000).toFixed(0)}K change (${employment.payrolls.trendPct >= 0 ? '+' : ''}${employment.payrolls.trendPct.toFixed(1)}%)` : '--';
            document.getElementById('hopeJoblessClaims').textContent = employment.claims.latest !== null ? 
                `${(employment.claims.latest / 1000).toFixed(1)}K (${employment.claims.trend >= 0 ? '+' : ''}${(employment.claims.trend / 1000).toFixed(1)}K)` : '--';
            document.getElementById('hopeEmploymentAnalysis').textContent = employmentWeak ? 
                'Employment weakening - final stage of recession' : 
                'Employment healthy';
            
            // Create HOPE chart
            const ctx = document.getElementById('hopeChart');
            if (hopeChartInstance) {
                hopeChartInstance.destroy();
            }
            
            // Prepare chart data - normalize all series to percentage changes from baseline
            // Corporate profits are quarterly, so we need to handle date alignment differently
            const allDates = new Set();
            [housingStartsData, buildingPermitsData, durableOrdersData, unrateData].forEach(data => {
                if (data && data.length > 0) data.forEach(item => allDates.add(item.date));
            });
            
            // Add corporate profits dates (quarterly data)
            if (corporateProfitsData && corporateProfitsData.length > 0) {
                corporateProfitsData.forEach(item => allDates.add(item.date));
            }
            
            const sortedDates = Array.from(allDates).sort((a, b) => new Date(a) - new Date(b));
            const chartData = sortedDates.map(date => {
                const h = housingStartsData.find(d => d.date === date);
                const o = durableOrdersData.find(d => d.date === date);
                
                // For corporate profits (quarterly), find closest date within 45 days
                let p = corporateProfitsData.find(d => d.date === date);
                if (!p && corporateProfitsData && corporateProfitsData.length > 0) {
                    const targetDate = new Date(date);
                    let closestProfit = null;
                    let minDiff = Infinity;
                    corporateProfitsData.forEach(d => {
                        const profitDate = new Date(d.date);
                        const diff = Math.abs(profitDate - targetDate);
                        // Allow up to 45 days difference for quarterly data
                        if (diff < 45 * 24 * 60 * 60 * 1000 && diff < minDiff) {
                            minDiff = diff;
                            closestProfit = d;
                        }
                    });
                    p = closestProfit;
                }
                
                const e = unrateData.find(d => d.date === date);
                return {
                    date,
                    housing: h ? h.value : null,
                    orders: o ? o.value : null,
                    profits: p ? p.value : null,
                    employment: e ? e.value : null
                };
            }).filter(d => d.housing !== null || d.orders !== null || d.profits !== null || d.employment !== null);
            
            if (chartData.length > 0) {
                // Find first non-null value for each series to use as baseline
                const housingBaseline = chartData.find(d => d.housing !== null)?.housing;
                const ordersBaseline = chartData.find(d => d.orders !== null)?.orders;
                const profitsBaseline = chartData.find(d => d.profits !== null)?.profits;
                const employmentBaseline = chartData.find(d => d.employment !== null)?.employment;
                
                // Normalize to percentage change from first non-null value
                const housingNorm = chartData.map(d => {
                    if (d.housing === null || housingBaseline === null || housingBaseline === 0) return null;
                    return ((d.housing - housingBaseline) / housingBaseline) * 100;
                });
                const ordersNorm = chartData.map(d => {
                    if (d.orders === null || ordersBaseline === null || ordersBaseline === 0) return null;
                    return ((d.orders - ordersBaseline) / ordersBaseline) * 100;
                });
                const profitsNorm = chartData.map(d => {
                    if (d.profits === null || profitsBaseline === null || profitsBaseline === 0) return null;
                    return ((d.profits - profitsBaseline) / profitsBaseline) * 100;
                });
                const employmentNorm = chartData.map(d => {
                    if (d.employment === null || employmentBaseline === null) return null;
                    return (d.employment - employmentBaseline) * 10; // Scale unemployment for visibility
                });
                
                console.log('HOPE Chart Data:', {
                    totalPoints: chartData.length,
                    housingPoints: housingNorm.filter(v => v !== null).length,
                    ordersPoints: ordersNorm.filter(v => v !== null).length,
                    profitsPoints: profitsNorm.filter(v => v !== null).length,
                    employmentPoints: employmentNorm.filter(v => v !== null).length,
                    profitsBaseline: profitsBaseline,
                    sampleProfits: chartData.filter(d => d.profits !== null).slice(0, 5).map(d => ({ date: d.date, value: d.profits }))
                });
                
                hopeChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartData.map(d => d.date),
                        datasets: [
                            {
                                label: 'Housing Starts % Change',
                                data: housingNorm,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Durable Orders % Change',
                                data: ordersNorm,
                                borderColor: '#60a5fa',
                                backgroundColor: 'rgba(96, 165, 250, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Corporate Profits % Change',
                                data: profitsNorm,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Unemployment Rate (×10)',
                                data: employmentNorm,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 3,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                labels: { 
                                    color: '#9ca3af',
                                    font: { size: 10 },
                                    boxWidth: 12,
                                    padding: 8
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#9ca3af', maxRotation: 45, minRotation: 45 },
                                grid: { color: 'rgba(156, 163, 175, 0.1)' }
                            },
                            y: {
                                type: 'linear',
                                position: 'left',
                                ticks: { color: '#9ca3af', callback: function(value) { return value.toFixed(0) + '%'; } },
                                grid: { color: 'rgba(156, 163, 175, 0.1)' },
                                title: { display: true, text: '% Change', color: '#9ca3af' }
                            },
                            y1: {
                                type: 'linear',
                                position: 'right',
                                ticks: { color: '#9ca3af' },
                                grid: { display: false },
                                title: { display: true, text: 'Unemployment (×10)', color: '#9ca3af' }
                            }
                        }
                    }
                });
            }
            
            // Store in macro score data
            macroScoreData.hope = {
                stage: hopeStage,
                housing: housingWeak,
                orders: ordersWeak,
                profits: profitsWeak,
                employment: employmentWeak
            };
            
        }
        
        // Process Forward Term Premium
        function processForwardTermPremium(forwardPremium5YData, forwardPremium10YData) {
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            forwardPremium5YData.forEach(item => dateMap.set(item.date, { fp5Y: item.value }));
            forwardPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).fp10Y = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.fp5Y !== undefined && values.fp10Y !== undefined) {
                    combinedData.push({
                        date: date,
                        fp5Y: values.fp5Y,
                        fp10Y: values.fp10Y
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            const fp10YChange = latest.fp10Y - previous.fp10Y;
            
            // Update display
            document.getElementById('forwardPremium5Y').textContent = (latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3) + '%';
            document.getElementById('forwardPremium10Y').textContent = (latest.fp10Y >= 0 ? '+' : '') + latest.fp10Y.toFixed(3) + '%';
            
            const forwardPremiumDateEl = document.getElementById('forwardPremiumLatestDate');
            if (forwardPremiumDateEl) forwardPremiumDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('forwardPremiumAnalysis');
            let analysisText = '';
            if (fp10YChange > 0.2) {
                analysisText = `Forward term premium is spiking (10Y forward: ${latest.fp10Y.toFixed(3)}%, up ${fp10YChange.toFixed(3)}pp). This suggests the market is worried about long-term fiscal stability or inflation. The Fed uses this to gauge "long-run inflation uncertainty." 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%.`;
            } else if (latest.fp10Y > 0.5) {
                analysisText = `Forward term premium is elevated (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect higher long-term risk compensation, indicating concerns about future policy or fiscal sustainability.`;
            } else if (latest.fp10Y < 0) {
                analysisText = `Forward term premium is negative (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect minimal long-term risk, suggesting confidence in future policy stability.`;
            } else {
                analysisText = `Forward term premiums are moderate (5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%, 10Y forward: ${latest.fp10Y.toFixed(3)}%). Markets expect normal long-term risk compensation.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('forwardPremiumChart');
            if (forwardPremiumChartInstance) {
                forwardPremiumChartInstance.destroy();
            }
            
            const labels = combinedData.map(d => d.date);
            const fp5YValues = combinedData.map(d => d.fp5Y);
            const fp10YValues = combinedData.map(d => d.fp10Y);
            const fpDiffValues = combinedData.map(d => d.fp10Y - d.fp5Y);
            const zeroLine = new Array(combinedData.length).fill(0);
            
            forwardPremiumChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '5Y Forward Term Premium',
                        data: fp5YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y Forward Term Premium',
                        data: fp10YValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y - 5Y Forward Term Premium Spread',
                        data: fpDiffValues,
                        borderColor: '#6b7280',
                        backgroundColor: 'rgba(107, 114, 128, 0.1)',
                        borderWidth: 1.5,
                        borderDash: [4, 4],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        hidden: true
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af', 
                                maxRotation: 45, 
                                minRotation: 45,
                                maxTicksLimit: 12
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            title: {
                                display: true,
                                text: 'Date',
                                color: '#9ca3af',
                                font: { size: 11 }
                            }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af', 
                                callback: function(value) { return value.toFixed(3) + '%'; } 
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            title: { 
                                display: true, 
                                text: 'Forward Term Premium (%)', 
                                color: '#9ca3af',
                                font: { size: 11 }
                            }
                        }
                    }
                }
            });
        }
        
        // Process 10Y Term Premium vs Forward Term Premium Comparison
        function processTermPremiumComparison(termPremium10YData, forwardPremium10YData) {
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            termPremium10YData.forEach(item => dateMap.set(item.date, { tp10Y: item.value }));
            forwardPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).fp10Y = item.value;
                } else {
                    dateMap.set(item.date, { fp10Y: item.value });
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.tp10Y !== undefined && values.fp10Y !== undefined) {
                    combinedData.push({
                        date: date,
                        tp10Y: values.tp10Y,
                        fp10Y: values.fp10Y,
                        difference: values.fp10Y - values.tp10Y
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Store full data for zoom
            termPremiumComparisonFullData = combinedData;
            
            // Apply zoom filter if active
            let chartData = termPremiumComparisonZoom24 ? filterTo24Months(combinedData) : combinedData;
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            
            // Update display
            document.getElementById('termPremium10YCurrent').textContent = (latest.tp10Y >= 0 ? '+' : '') + latest.tp10Y.toFixed(3) + '%';
            document.getElementById('forwardPremium10YCurrent').textContent = (latest.fp10Y >= 0 ? '+' : '') + latest.fp10Y.toFixed(3) + '%';
            const diff = latest.fp10Y - latest.tp10Y;
            document.getElementById('termPremiumDiff').textContent = (diff >= 0 ? '+' : '') + diff.toFixed(3) + '%';
            
            // Analysis
            const analysisEl = document.getElementById('termPremiumComparisonAnalysis');
            let analysisText = '';
            const diffChange = diff - (previous.fp10Y - previous.tp10Y);
            
            if (diff > 0.5) {
                analysisText = `Forward term premium (${latest.fp10Y.toFixed(3)}%) is significantly higher than current term premium (${latest.tp10Y.toFixed(3)}%), suggesting markets expect risk premiums to rise over the next decade. This indicates concerns about long-term fiscal or policy risks.`;
            } else if (diff < -0.5) {
                analysisText = `Current term premium (${latest.tp10Y.toFixed(3)}%) is significantly higher than forward term premium (${latest.fp10Y.toFixed(3)}%), suggesting markets expect risk premiums to decline over the next decade. This may indicate near-term uncertainty but long-term confidence.`;
            } else if (diff > 0) {
                analysisText = `Forward term premium (${latest.fp10Y.toFixed(3)}%) is slightly higher than current term premium (${latest.tp10Y.toFixed(3)}%), suggesting markets expect a modest rise in risk premiums over time.`;
            } else if (diff < 0) {
                analysisText = `Current term premium (${latest.tp10Y.toFixed(3)}%) is slightly higher than forward term premium (${latest.fp10Y.toFixed(3)}%), suggesting markets expect a modest decline in risk premiums over time.`;
            } else {
                analysisText = `Current and forward term premiums are closely aligned (${latest.tp10Y.toFixed(3)}% vs ${latest.fp10Y.toFixed(3)}%), suggesting markets expect stable risk premiums over the next decade.`;
            }
            
            if (Math.abs(diffChange) > 0.2) {
                analysisText += ` The difference has changed by ${(diffChange >= 0 ? '+' : '') + diffChange.toFixed(3)}pp recently.`;
            }
            
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('termPremiumComparisonChart');
            if (termPremiumComparisonChartInstance) {
                termPremiumComparisonChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            const tp10YValues = chartData.map(d => d.tp10Y);
            const fp10YValues = chartData.map(d => d.fp10Y);
            const diffValues = chartData.map(d => d.difference);
            const zeroLine = new Array(chartData.length).fill(0);
            
            termPremiumComparisonChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '10Y Term Premium',
                        data: tp10YValues,
                        borderColor: '#6b7280',
                        backgroundColor: 'rgba(107, 114, 128, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        hidden: true
                    }, {
                        label: '10Y Forward Term Premium',
                        data: fp10YValues,
                        borderColor: '#6b7280',
                        backgroundColor: 'rgba(107, 114, 128, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        hidden: true
                    }, {
                        label: 'Difference (Forward - Current)',
                        data: diffValues,
                        borderColor: '#fbbf24',
                        backgroundColor: 'rgba(251, 191, 36, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y1'
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(3) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(3) + '%'; } 
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            title: { 
                                display: true, 
                                text: 'Term Premium (%)', 
                                color: '#9ca3af',
                                font: { size: 11 }
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: { 
                                color: '#fbbf24',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(3) + '%'; } 
                            },
                            grid: { 
                                drawOnChartArea: false,
                                color: 'rgba(251, 191, 36, 0.1)' 
                            },
                            title: { 
                                display: true, 
                                text: 'Difference (%)', 
                                color: '#fbbf24',
                                font: { size: 11 }
                            }
                        }
                    }
                }
            });
        }
        
        // Process Forward Term Premium
        function processForwardTermPremium(forwardPremium5YData, forwardPremium10YData) {
            
            // Get latest values
            const latestSP500 = sp500Sorted[sp500Sorted.length - 1];
            const latestVIX = vixSorted.length > 0 ? vixSorted[vixSorted.length - 1] : null;
            const latestUnrate = unrateSorted.length > 0 ? unrateSorted[unrateSorted.length - 1] : null;
            const latestYield10Y = yield10YSorted.length > 0 ? yield10YSorted[yield10YSorted.length - 1] : null;
            const latestYield2Y = yield2YSorted.length > 0 ? yield2YSorted[yield2YSorted.length - 1] : null;
            
            // Calculate key metrics
            // 1. Drawdown from recent peak (12-month lookback)
            const lookbackMonths = 12;
            const lookbackDate = new Date(latestSP500.date);
            lookbackDate.setMonth(lookbackDate.getMonth() - lookbackMonths);
            
            let peakValue = latestSP500.value;
            let peakDate = latestSP500.date;
            sp500Sorted.forEach(d => {
                const date = new Date(d.date);
                if (date >= lookbackDate && d.value > peakValue) {
                    peakValue = d.value;
                    peakDate = d.date;
                }
            });
            
            const drawdown = ((latestSP500.value - peakValue) / peakValue) * 100;
            
            // 2. 6-month return
            const sixMonthsAgo = new Date(latestSP500.date);
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
            let sixMonthAgoValue = latestSP500.value;
            let minSixMonthDiff = Infinity;
            sp500Sorted.forEach(d => {
                const date = new Date(d.date);
                const diff = Math.abs(date - sixMonthsAgo);
                if (diff < minSixMonthDiff) {
                    minSixMonthDiff = diff;
                    sixMonthAgoValue = d.value;
                }
            });
            const sixMonthReturn = ((latestSP500.value - sixMonthAgoValue) / sixMonthAgoValue) * 100;
            
            // 3. 12-month return
            const twelveMonthsAgo = new Date(latestSP500.date);
            twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 12);
            let twelveMonthAgoValue = latestSP500.value;
            let minTwelveMonthDiff = Infinity;
            sp500Sorted.forEach(d => {
                const date = new Date(d.date);
                const diff = Math.abs(date - twelveMonthsAgo);
                if (diff < minTwelveMonthDiff) {
                    minTwelveMonthDiff = diff;
                    twelveMonthAgoValue = d.value;
                }
            });
            const twelveMonthReturn = ((latestSP500.value - twelveMonthAgoValue) / twelveMonthAgoValue) * 100;
            
            // 4. Calculate P/E ratio, Price change, Earnings change, and P/E change (GS methodology)
            // GS model identifies phases by comparing Price (P) vs Earnings (E) changes
            // P/E = Price / Earnings
            // Phase transitions are "inflection points" in these relationships
            let earningsGrowth = null;
            let priceChange = null; // YoY price change (%)
            let peRatio = null;
            let peChange = null; // YoY P/E change (%)
            
            if (sp500EarningsSorted.length > 0) {
                const latestEarnings = sp500EarningsSorted[sp500EarningsSorted.length - 1];
                
                // Find S&P 500 price closest to latest earnings date (within 30 days)
                const earningsDate = new Date(latestEarnings.date);
                let closestPrice = null;
                let closestPriceDate = null;
                let minDateDiff = Infinity;
                const maxPriceDiff = 30 * 24 * 60 * 60 * 1000; // 30 days
                
                sp500Sorted.forEach(d => {
                    const date = new Date(d.date);
                    const diff = Math.abs(date - earningsDate);
                    if (diff < maxPriceDiff && diff < minDateDiff) {
                        minDateDiff = diff;
                        closestPrice = d.value;
                        closestPriceDate = d.date;
                    }
                });
                
                if (closestPrice && latestEarnings.value > 0) {
                    peRatio = closestPrice / latestEarnings.value;
                    
                    // Calculate earnings growth and price change YoY
                    const yearAgoDate = new Date(latestEarnings.date);
                    yearAgoDate.setFullYear(yearAgoDate.getFullYear() - 1);
                    const maxDateDiff = 4 * 30 * 24 * 60 * 60 * 1000; // 4 months for quarterly data
                    const maxPriceDiffForAlignment = 30 * 24 * 60 * 60 * 1000; // 30 days for price alignment
                    
                    let yearAgoEarnings = null;
                    let yearAgoPrice = null;
                    let minYearDiff = Infinity;
                    
                    // Find earnings from 1 year ago
                    sp500EarningsSorted.forEach(d => {
                        const date = new Date(d.date);
                        const diff = Math.abs(date - yearAgoDate);
                        if (diff < maxDateDiff && diff < minYearDiff) {
                            minYearDiff = diff;
                            yearAgoEarnings = d.value;
                            
                            // Find price closest to this earnings date
                            let priceAtEarningsDate = null;
                            let minPriceDiff = Infinity;
                            sp500Sorted.forEach(p => {
                                const pDate = new Date(p.date);
                                const pDiff = Math.abs(pDate - date);
                                if (pDiff < maxPriceDiffForAlignment && pDiff < minPriceDiff) {
                                    minPriceDiff = pDiff;
                                    priceAtEarningsDate = p.value;
                                }
                            });
                            if (priceAtEarningsDate) {
                                yearAgoPrice = priceAtEarningsDate;
                            }
                        }
                    });
                    
                    if (yearAgoEarnings && yearAgoEarnings > 0 && yearAgoPrice && yearAgoPrice > 0) {
                        // Calculate earnings growth YoY (%)
                        earningsGrowth = ((latestEarnings.value - yearAgoEarnings) / yearAgoEarnings) * 100;
                        
                        // Calculate price change YoY (%)
                        priceChange = ((closestPrice - yearAgoPrice) / yearAgoPrice) * 100;
                        
                        // Calculate P/E change YoY (%)
                        const yearAgoPE = yearAgoPrice / yearAgoEarnings;
                        if (yearAgoPE > 0) {
                            peChange = ((peRatio - yearAgoPE) / yearAgoPE) * 100;
                        }
                    }
                }
            }
            
            // Fallback: Use average hourly earnings if S&P 500 earnings not available
            if (earningsGrowth === null && earningsSorted.length > 0) {
                const latestEarnings = earningsSorted[earningsSorted.length - 1];
                const yearAgoDate = new Date(latestEarnings.date);
                yearAgoDate.setFullYear(yearAgoDate.getFullYear() - 1);
                const maxDateDiff = 2 * 30 * 24 * 60 * 60 * 1000; // 2 months for monthly data
                let yearAgoEarnings = null;
                let minYearDiff = Infinity;
                earningsSorted.forEach(d => {
                    const date = new Date(d.date);
                    const diff = Math.abs(date - yearAgoDate);
                    if (diff < maxDateDiff && diff < minYearDiff) {
                        minYearDiff = diff;
                        yearAgoEarnings = d;
                    }
                });
                if (yearAgoEarnings && yearAgoEarnings.value > 0 && latestEarnings.value > 0) {
                    earningsGrowth = ((latestEarnings.value - yearAgoEarnings.value) / yearAgoEarnings.value) * 100;
                }
            }
            
            // 5. Yield curve (10Y - 2Y)
            const yieldCurve = (latestYield10Y && latestYield2Y) ? (latestYield10Y.value - latestYield2Y.value) : null;
            
            // Determine current cycle phase based on Oppenheimer's framework
            // GS methodology: Phases are identified by inflection points in Price (P) vs Earnings (E) relationship
            let currentPhase = 'UNKNOWN';
            let phaseNumber = 0; // 0=Despair, 1=Hope, 2=Growth, 3=Optimism
            let phaseClass = 'bg-gray-900/30 text-gray-400 border border-gray-700';
            let phaseAnalysis = '';
            
            // Phase detection based on P/E, Price, and Earnings changes
            // Priority: Use P/E and price/earnings data if available, otherwise fallback to proxies
            
            if (peChange !== null && priceChange !== null && earningsGrowth !== null) {
                // We have all the data needed for precise phase detection
                
                // Despair: Prices fall faster than earnings (P/E falls)
                // P/E change < 0 (P/E contracting)
                if (peChange < 0) {
                    currentPhase = 'DESPAIR';
                    phaseNumber = 0;
                    phaseClass = 'bg-red-900/30 text-red-400 border-2 border-red-500';
                    phaseAnalysis = `Despair phase: Prices falling faster than earnings. P/E change: ${peChange.toFixed(1)}% (P/E contracting). Price: ${priceChange.toFixed(1)}%, Earnings: ${earningsGrowth.toFixed(1)}%. Markets pricing in a coming recession.`;
                }
                // Hope: Prices rise while earnings are still falling or flat (P/E skyrockets)
                // Price change > 0 AND (earnings growth <= 0 or very small) AND P/E change > 0
                else if (priceChange > 0 && earningsGrowth <= 2 && peChange > 0) {
                    currentPhase = 'HOPE';
                    phaseNumber = 1;
                    phaseClass = 'bg-green-900/30 text-green-400 border-2 border-green-500';
                    const annualizedReturn = sixMonthReturn > 0 ? (Math.pow(1 + sixMonthReturn/100, 2) - 1) * 100 : twelveMonthReturn;
                    phaseAnalysis = `Hope phase: Prices rising while earnings flat/falling. P/E expansion: ${peChange.toFixed(1)}% (valuations skyrocket). Price: ${priceChange.toFixed(1)}%, Earnings: ${earningsGrowth.toFixed(1)}%. This is the "multiple expansion" phase - markets anticipate recovery. Best returns phase (~10 months, 60%+ annualized). Current 6M: ${sixMonthReturn.toFixed(1)}% (${annualizedReturn.toFixed(1)}% annualized).`;
                }
                // Growth: Earnings grow faster than Price (P/E moderates/falls even as market rises)
                // Earnings growth > price change (earnings growing faster than prices)
                else if (earningsGrowth > priceChange && earningsGrowth > 0) {
                    currentPhase = 'GROWTH';
                    phaseNumber = 2;
                    phaseClass = 'bg-blue-900/30 text-blue-400 border-2 border-blue-500';
                    phaseAnalysis = `Growth phase: Earnings growing faster than prices. Earnings: ${earningsGrowth.toFixed(1)}% > Price: ${priceChange.toFixed(1)}%. P/E change: ${peChange.toFixed(1)}% (moderating/falling). The "baton" passes from valuation to actual profits. P/E ratios moderate even as market rises. This phase typically lasts ~43 months.`;
                }
                // Optimism: Both Price and P/E rise together
                // Price change > 0 AND P/E change > 0 (both rising)
                else if (priceChange > 0 && peChange > 0) {
                    currentPhase = 'OPTIMISM';
                    phaseNumber = 3;
                    phaseClass = 'bg-yellow-900/30 text-yellow-400 border-2 border-yellow-500';
                    phaseAnalysis = `Optimism phase: Both prices and valuations rising together. Price: ${priceChange.toFixed(1)}%, P/E: ${peChange.toFixed(1)}% (both rising). Earnings: ${earningsGrowth.toFixed(1)}%. Investors become overconfident; they pay high prices despite rising interest rates. Peak risk phase.`;
                }
                // Default fallback: Classify based on available data
                else {
                    if (priceChange < 0) {
                        currentPhase = 'DESPAIR';
                        phaseNumber = 0;
                        phaseClass = 'bg-red-900/30 text-red-400 border-2 border-red-500';
                        phaseAnalysis = `Despair phase: Prices declining. Price: ${priceChange.toFixed(1)}%, Earnings: ${earningsGrowth.toFixed(1)}%, P/E: ${peChange.toFixed(1)}%.`;
                    } else if (earningsGrowth > priceChange && earningsGrowth > 0) {
                        currentPhase = 'GROWTH';
                        phaseNumber = 2;
                        phaseClass = 'bg-blue-900/30 text-blue-400 border-2 border-blue-500';
                        phaseAnalysis = `Growth phase: Earnings driving returns. Earnings: ${earningsGrowth.toFixed(1)}% > Price: ${priceChange.toFixed(1)}%.`;
                    } else {
                        currentPhase = 'HOPE';
                        phaseNumber = 1;
                        phaseClass = 'bg-green-900/30 text-green-400 border-2 border-green-500';
                        phaseAnalysis = `Hope phase: Multiple expansion. Price: ${priceChange.toFixed(1)}%, P/E: ${peChange.toFixed(1)}%.`;
                    }
                }
            }
            // Fallback: Use proxy indicators if P/E data not available
            else {
                // Despair: Bear market conditions
                if (drawdown < -20 || (latestVIX && latestVIX.value > 25) || twelveMonthReturn < -15) {
                    currentPhase = 'DESPAIR';
                    phaseNumber = 0;
                    phaseClass = 'bg-red-900/30 text-red-400 border-2 border-red-500';
                    phaseAnalysis = `Despair phase: Bear market conditions. Drawdown: ${drawdown.toFixed(1)}%, VIX: ${latestVIX ? latestVIX.value.toFixed(1) : 'N/A'}, 12M Return: ${twelveMonthReturn.toFixed(1)}%. Markets pricing in economic weakness.`;
                }
                // Hope: Strong recovery with weak earnings
                else if ((sixMonthReturn > 15 || twelveMonthReturn > 30) && (earningsGrowth === null || earningsGrowth <= 2)) {
                    currentPhase = 'HOPE';
                    phaseNumber = 1;
                    phaseClass = 'bg-green-900/30 text-green-400 border-2 border-green-500';
                    const annualizedReturn = sixMonthReturn > 0 ? (Math.pow(1 + sixMonthReturn/100, 2) - 1) * 100 : twelveMonthReturn;
                    phaseAnalysis = `Hope phase: Strong returns with weak earnings. 6M: ${sixMonthReturn.toFixed(1)}%, 12M: ${twelveMonthReturn.toFixed(1)}% (${annualizedReturn.toFixed(1)}% annualized). Earnings: ${earningsGrowth !== null ? earningsGrowth.toFixed(1) + '%' : 'N/A'}. Multiple expansion phase.`;
                }
                // Growth: Earnings driving returns
                else if (earningsGrowth !== null && earningsGrowth > 5 && sixMonthReturn > 0) {
                    currentPhase = 'GROWTH';
                    phaseNumber = 2;
                    phaseClass = 'bg-blue-900/30 text-blue-400 border-2 border-blue-500';
                    phaseAnalysis = `Growth phase: Earnings growth driving returns. Earnings: ${earningsGrowth.toFixed(1)}% YoY, 6M return: ${sixMonthReturn.toFixed(1)}%. Earnings are the primary driver.`;
                }
                // Optimism: High valuations, rising rates
                else if ((yieldCurve !== null && yieldCurve < 0.5) || (latestYield10Y && latestYield10Y.value > 4) || (sixMonthReturn > 0 && sixMonthReturn < 10 && drawdown > -5)) {
                    currentPhase = 'OPTIMISM';
                    phaseNumber = 3;
                    phaseClass = 'bg-yellow-900/30 text-yellow-400 border-2 border-yellow-500';
                    phaseAnalysis = `Optimism phase: High valuations and rising rates. Yield curve: ${yieldCurve !== null ? yieldCurve.toFixed(2) + '%' : 'N/A'}, 10Y Yield: ${latestYield10Y ? latestYield10Y.value.toFixed(2) + '%' : 'N/A'}. Returns modest (6M: ${sixMonthReturn.toFixed(1)}%), indicating peak risk.`;
                }
                // Default
                else {
                    if (earningsGrowth !== null && earningsGrowth > 0) {
                        currentPhase = 'GROWTH';
                        phaseNumber = 2;
                        phaseClass = 'bg-blue-900/30 text-blue-400 border-2 border-blue-500';
                        phaseAnalysis = `Growth phase. Earnings growth: ${earningsGrowth.toFixed(1)}%, 6M return: ${sixMonthReturn.toFixed(1)}%.`;
                    } else {
                        currentPhase = 'HOPE';
                        phaseNumber = 1;
                        phaseClass = 'bg-green-900/30 text-green-400 border-2 border-green-500';
                        phaseAnalysis = `Hope phase. Markets showing recovery (6M: ${sixMonthReturn.toFixed(1)}%), but earnings still weak.`;
                    }
                }
            }
            
            // Update UI
            document.getElementById('gsCyclePhase').textContent = currentPhase;
            document.getElementById('gsCyclePhase').className = `inline-block px-6 py-3 rounded-lg text-lg font-bold mb-3 ${phaseClass}`;
            document.getElementById('gsCycleAnalysis').textContent = phaseAnalysis;
            
            // Update progress bar (0-25% Despair, 25-50% Hope, 50-75% Growth, 75-100% Optimism)
            const progressPercent = (phaseNumber + 1) * 25;
            const progressColors = {
                0: 'bg-red-500',
                1: 'bg-green-500',
                2: 'bg-blue-500',
                3: 'bg-yellow-500'
            };
            document.getElementById('gsCycleProgressBar').style.width = `${progressPercent}%`;
            document.getElementById('gsCycleProgressBar').className = `h-full transition-all duration-500 ${progressColors[phaseNumber]}`;
            document.getElementById('gsCycleProgressText').textContent = currentPhase;
            
            // Phase returns are already set in HTML, no need to update dynamically
            
            // Update market indicators
            document.getElementById('gsSP500Value').textContent = latestSP500.value.toFixed(0);
            document.getElementById('gsVIXValue').textContent = latestVIX ? latestVIX.value.toFixed(2) : 'N/A';
            document.getElementById('gsDrawdown').textContent = `${drawdown.toFixed(1)}%`;
            document.getElementById('gs6MReturn').textContent = `${sixMonthReturn >= 0 ? '+' : ''}${sixMonthReturn.toFixed(1)}%`;
            
            // Update economic indicators
            document.getElementById('gsEarningsGrowth').textContent = earningsGrowth !== null ? `${earningsGrowth >= 0 ? '+' : ''}${earningsGrowth.toFixed(1)}%` : 'N/A';
            document.getElementById('gsUnemployment').textContent = latestUnrate ? `${latestUnrate.value.toFixed(1)}%` : 'N/A';
            document.getElementById('gs10YYield').textContent = latestYield10Y ? `${latestYield10Y.value.toFixed(2)}%` : 'N/A';
            document.getElementById('gsYieldCurve').textContent = yieldCurve !== null ? `${yieldCurve.toFixed(2)}%` : 'N/A';
            
            // Market analysis
            let marketAnalysis = '';
            if (drawdown < -15) {
                marketAnalysis = `Significant drawdown from peak suggests bear market conditions. VIX at ${latestVIX ? latestVIX.value.toFixed(1) : 'N/A'} indicates ${latestVIX && latestVIX.value > 25 ? 'high' : 'elevated'} fear levels.`;
            } else if (sixMonthReturn > 20) {
                marketAnalysis = `Strong 6-month returns suggest robust market recovery. Current phase (${currentPhase}) aligns with historical patterns of strong performance.`;
            } else {
                marketAnalysis = `Moderate market conditions. Drawdown: ${drawdown.toFixed(1)}%, 6M return: ${sixMonthReturn.toFixed(1)}%. Market showing ${sixMonthReturn > 0 ? 'positive' : 'negative'} momentum.`;
            }
            document.getElementById('gsMarketAnalysis').textContent = marketAnalysis;
            
            // Economic analysis
            let economicAnalysis = '';
            if (earningsGrowth !== null) {
                economicAnalysis = `Earnings ${earningsGrowth > 0 ? 'growing' : 'declining'} at ${Math.abs(earningsGrowth).toFixed(1)}% YoY. `;
            }
            if (yieldCurve !== null) {
                economicAnalysis += `Yield curve is ${yieldCurve < 0 ? 'inverted' : yieldCurve < 0.5 ? 'flat' : 'normal'} (${yieldCurve.toFixed(2)}%). `;
            }
            if (latestUnrate) {
                economicAnalysis += `Unemployment at ${latestUnrate.value.toFixed(1)}% suggests ${latestUnrate.value < 4 ? 'tight' : latestUnrate.value < 6 ? 'moderate' : 'loose'} labor market.`;
            }
            document.getElementById('gsEconomicAnalysis').textContent = economicAnalysis || 'Economic indicators suggest mixed conditions.';
            
            // Create chart
            const ctx = document.getElementById('gsCycleChart');
            if (gsCycleChartInstance) {
                gsCycleChartInstance.destroy();
            }
            
            // Prepare chart data - show S&P 500 colored by current phase
            const chartDates = sp500Sorted.map(d => d.date);
            const sp500Values = sp500Sorted.map(d => d.value);
            
            // Normalize to percentage change from first value
            const baseline = sp500Values[0];
            const sp500Pct = sp500Values.map(v => ((v - baseline) / baseline) * 100);
            
            // Color the S&P 500 line based on current phase
            const phaseLineColors = {
                'DESPAIR': '#ef4444',      // Red
                'HOPE': '#10b981',         // Green
                'GROWTH': '#60a5fa',       // Blue
                'OPTIMISM': '#facc15',     // Yellow
                'UNKNOWN': '#9ca3af'       // Gray
            };
            
            const phaseLabels = {
                'DESPAIR': 'Despair (P/E falls)',
                'HOPE': 'Hope (P/E rises, earnings flat/falling)',
                'GROWTH': 'Growth (Earnings > Price)',
                'OPTIMISM': 'Optimism (P & P/E both rise)',
                'UNKNOWN': 'Unknown'
            };
            
            const lineColor = phaseLineColors[currentPhase] || '#3b82f6';
            
            gsCycleChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartDates,
                    datasets: [
                        {
                            label: `S&P 500 (Current Phase: ${currentPhase})`,
                            data: sp500Pct,
                            borderColor: lineColor,
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 3,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 3,
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 11 },
                                boxWidth: 15,
                                padding: 12,
                                generateLabels: function(chart) {
                                    // Custom legend showing all phases
                                    return [
                                        {
                                            text: `Current: ${currentPhase} - ${phaseLabels[currentPhase]}`,
                                            fillStyle: lineColor,
                                            strokeStyle: lineColor,
                                            lineWidth: 3,
                                            hidden: false,
                                            index: 0
                                        },
                                        {
                                            text: 'Despair: Prices fall faster than earnings (P/E falls)',
                                            fillStyle: '#ef4444',
                                            strokeStyle: '#ef4444',
                                            lineWidth: 2,
                                            hidden: false,
                                            index: 1
                                        },
                                        {
                                            text: 'Hope: Prices rise, earnings flat/falling (P/E rises)',
                                            fillStyle: '#10b981',
                                            strokeStyle: '#10b981',
                                            lineWidth: 2,
                                            hidden: false,
                                            index: 2
                                        },
                                        {
                                            text: 'Growth: Earnings grow faster than prices (P/E moderates)',
                                            fillStyle: '#60a5fa',
                                            strokeStyle: '#60a5fa',
                                            lineWidth: 2,
                                            hidden: false,
                                            index: 3
                                        },
                                        {
                                            text: 'Optimism: Both prices and P/E rise together',
                                            fillStyle: '#facc15',
                                            strokeStyle: '#facc15',
                                            lineWidth: 2,
                                            hidden: false,
                                            index: 4
                                        }
                                    ];
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const value = sp500Values[context.dataIndex];
                                    return `S&P 500: ${value.toFixed(0)} (${context.parsed.y >= 0 ? '+' : ''}${context.parsed.y.toFixed(1)}%)`;
                                },
                                title: function(context) {
                                    return `${context[0].label}`;
                                },
                                afterBody: function(context) {
                                    return [`Current Phase: ${currentPhase}`, phaseLabels[currentPhase]];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af', 
                                maxRotation: 45, 
                                minRotation: 45,
                                maxTicksLimit: 12
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            title: {
                                display: true,
                                text: 'Date',
                                color: '#9ca3af',
                                font: { size: 11 }
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            ticks: { 
                                color: '#9ca3af', 
                                callback: function(value) { return value.toFixed(0) + '%'; } 
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            title: { 
                                display: true, 
                                text: 'S&P 500 % Change from Baseline', 
                                color: '#9ca3af',
                                font: { size: 11 }
                            }
                        }
                    }
                }
            });
        }
        
        // Process Forward Term Premium
        function processForwardTermPremium(forwardPremium5YData, forwardPremium10YData) {
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            forwardPremium5YData.forEach(item => dateMap.set(item.date, { fp5Y: item.value }));
            forwardPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).fp10Y = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.fp5Y !== undefined && values.fp10Y !== undefined) {
                    combinedData.push({
                        date: date,
                        fp5Y: values.fp5Y,
                        fp10Y: values.fp10Y
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            const fp10YChange = latest.fp10Y - previous.fp10Y;
            
            // Update display
            document.getElementById('forwardPremium5Y').textContent = (latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3) + '%';
            document.getElementById('forwardPremium10Y').textContent = (latest.fp10Y >= 0 ? '+' : '') + latest.fp10Y.toFixed(3) + '%';
            
            const forwardPremiumDateEl = document.getElementById('forwardPremiumLatestDate');
            if (forwardPremiumDateEl) forwardPremiumDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('forwardPremiumAnalysis');
            let analysisText = '';
            if (fp10YChange > 0.2) {
                analysisText = `Forward term premium is spiking (10Y forward: ${latest.fp10Y.toFixed(3)}%, up ${fp10YChange.toFixed(3)}pp). This suggests the market is worried about long-term fiscal stability or inflation. The Fed uses this to gauge "long-run inflation uncertainty." 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%.`;
            } else if (latest.fp10Y > 0.5) {
                analysisText = `Forward term premium is elevated (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect higher long-term risk compensation, indicating concerns about future policy or fiscal sustainability.`;
            } else if (latest.fp10Y < 0) {
                analysisText = `Forward term premium is negative (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect minimal long-term risk, suggesting confidence in future policy stability.`;
            } else {
                analysisText = `Forward term premiums are moderate (5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%, 10Y forward: ${latest.fp10Y.toFixed(3)}%). Markets expect normal long-term risk compensation.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('forwardPremiumChart');
            if (forwardPremiumChartInstance) {
                forwardPremiumChartInstance.destroy();
            }
            
            const labels = combinedData.map(d => d.date);
            const fp5YValues = combinedData.map(d => d.fp5Y);
            const fp10YValues = combinedData.map(d => d.fp10Y);
            const fpDiffValues = combinedData.map(d => d.fp10Y - d.fp5Y);
            const zeroLine = new Array(combinedData.length).fill(0);
            
            forwardPremiumChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '5Y Forward Term Premium',
                        data: fp5YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y Forward Term Premium',
                        data: fp10YValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y - 5Y Forward Term Premium Spread',
                        data: fpDiffValues,
                        borderColor: '#6b7280',
                        backgroundColor: 'rgba(107, 114, 128, 0.1)',
                        borderWidth: 1.5,
                        borderDash: [4, 4],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        hidden: true
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#9ca3af', font: { size: 9 } },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af', 
                                callback: function(value) { return value.toFixed(2) + '%'; } 
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                }
            });
        }
        
        // Process Yield Decomposition
        function processYieldDecomposition(yield10YData, termPremium10YData) {
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            yield10YData.forEach(item => dateMap.set(item.date, { yield: item.value }));
            termPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).termPremium = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.yield !== undefined && values.termPremium !== undefined) {
                    combinedData.push({
                        date: date,
                        yield: values.yield,
                        termPremium: values.termPremium,
                        expectations: values.yield - values.termPremium
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const latest = combinedData[combinedData.length - 1];
            
            // Update display
            document.getElementById('yieldDecompositionYield').textContent = latest.yield.toFixed(2) + '%';
            document.getElementById('yieldDecompositionTermPremium').textContent = (latest.termPremium >= 0 ? '+' : '') + latest.termPremium.toFixed(2) + '%';
            document.getElementById('yieldDecompositionExpectations').textContent = latest.expectations.toFixed(2) + '%';
            
            const yieldDecompDateEl = document.getElementById('yieldDecompLatestDate');
            if (yieldDecompDateEl) yieldDecompDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('yieldDecompositionAnalysis');
            let analysisText = '';
            if (latest.termPremium > 1.0) {
                analysisText = `Term premium is elevated (${latest.termPremium.toFixed(2)}%), indicating markets require significant compensation for long-term risk. This suggests concerns about future inflation or fiscal sustainability.`;
            } else if (latest.termPremium < -0.5) {
                analysisText = `Term premium is negative (${latest.termPremium.toFixed(2)}%), indicating markets expect rates to fall over time. This suggests expectations of future monetary easing or economic weakness.`;
            } else {
                analysisText = `Term premium is moderate (${latest.termPremium.toFixed(2)}%), indicating normal risk compensation expectations.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('yieldDecompositionChart');
            if (yieldDecompositionChartInstance) {
                yieldDecompositionChartInstance.destroy();
            }
            
            const labels = combinedData.map(d => d.date);
            const yieldValues = combinedData.map(d => d.yield);
            const termPremiumValues = combinedData.map(d => d.termPremium);
            const expectationsValues = combinedData.map(d => d.expectations);
            
            yieldDecompositionChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '10Y Yield',
                        data: yieldValues,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Term Premium',
                        data: termPremiumValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Expectations Component',
                        data: expectationsValues,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return (value >= 0 ? '+' : '') + value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                }
            });
        }
        
        // Process Forward Term Premium
        function processForwardTermPremium(forwardPremium5YData, forwardPremium10YData) {
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            forwardPremium5YData.forEach(item => dateMap.set(item.date, { fp5Y: item.value }));
            forwardPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).fp10Y = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.fp5Y !== undefined && values.fp10Y !== undefined) {
                    combinedData.push({
                        date: date,
                        fp5Y: values.fp5Y,
                        fp10Y: values.fp10Y
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            const fp10YChange = latest.fp10Y - previous.fp10Y;
            
            // Update display
            document.getElementById('forwardPremium5Y').textContent = (latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3) + '%';
            document.getElementById('forwardPremium10Y').textContent = (latest.fp10Y >= 0 ? '+' : '') + latest.fp10Y.toFixed(3) + '%';
            
            const forwardPremiumDateEl = document.getElementById('forwardPremiumLatestDate');
            if (forwardPremiumDateEl) forwardPremiumDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('forwardPremiumAnalysis');
            let analysisText = '';
            if (fp10YChange > 0.2) {
                analysisText = `Forward term premium is spiking (10Y forward: ${latest.fp10Y.toFixed(3)}%, up ${fp10YChange.toFixed(3)}pp). This suggests the market is worried about long-term fiscal stability or inflation. The Fed uses this to gauge "long-run inflation uncertainty." 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%.`;
            } else if (latest.fp10Y > 0.5) {
                analysisText = `Forward term premium is elevated (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect higher long-term risk compensation, indicating concerns about future policy or fiscal sustainability.`;
            } else if (latest.fp10Y < 0) {
                analysisText = `Forward term premium is negative (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect minimal long-term risk, suggesting confidence in future policy stability.`;
            } else {
                analysisText = `Forward term premiums are moderate (5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%, 10Y forward: ${latest.fp10Y.toFixed(3)}%). Markets expect normal long-term risk compensation.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('forwardPremiumChart');
            if (forwardPremiumChartInstance) {
                forwardPremiumChartInstance.destroy();
            }
            
            const labels = combinedData.map(d => d.date);
            const fp5YValues = combinedData.map(d => d.fp5Y);
            const fp10YValues = combinedData.map(d => d.fp10Y);
            const fpDiffValues = combinedData.map(d => d.fp10Y - d.fp5Y);
            const zeroLine = new Array(combinedData.length).fill(0);
            
            forwardPremiumChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '5Y Forward Term Premium',
                        data: fp5YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y Forward Term Premium',
                        data: fp10YValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y - 5Y Forward Term Premium Spread',
                        data: fpDiffValues,
                        borderColor: '#6b7280',
                        backgroundColor: 'rgba(107, 114, 128, 0.1)',
                        borderWidth: 1.5,
                        borderDash: [4, 4],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        hidden: true
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return (value >= 0 ? '+' : '') + value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                }
            });
        }
        
        // Process FOMC Dot Plot vs 2Y Yield
        function processDotPlotComparison(yield2YData, fedFundsData, dotPlotMedianData) {
            // Handle empty data arrays
            if (!yield2YData || yield2YData.length === 0) {
                console.error('No 2Y yield data available for dot plot comparison');
                return;
            }
            fedFundsData = fedFundsData || [];
            dotPlotMedianData = dotPlotMedianData || [];
            
            // Align dates - Dot Plot data is quarterly, so we need to align carefully
            const combinedData = [];
            const dateMap = new Map();
            
            // Add 2Y yield data
            yield2YData.forEach(item => {
                if (item.value !== null && item.value !== undefined && !isNaN(item.value)) {
                    dateMap.set(item.date, { yield2Y: item.value });
                }
            });
            
            // Sort yield data dates for forward-filling
            const sortedYieldDates = Array.from(dateMap.keys()).sort((a, b) => new Date(a) - new Date(b));
            
            // Add Fed Funds Rate data - align with daily 2Y yield data and forward-fill
            let lastFedFunds = null;
            fedFundsData.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(item => {
                const fedFundsDate = new Date(item.date);
                sortedYieldDates.forEach(yieldDate => {
                    const yieldDateObj = new Date(yieldDate);
                    if (yieldDateObj >= fedFundsDate && (!lastFedFunds || new Date(yieldDate) < new Date(lastFedFunds.date))) {
                        if (dateMap.has(yieldDate)) {
                            dateMap.get(yieldDate).fedFunds = item.value;
                            lastFedFunds = item;
                        }
                    }
                });
            });
            
            // Forward-fill Fed Funds for dates after the last update
            if (lastFedFunds) {
                sortedYieldDates.forEach(yieldDate => {
                    if (dateMap.has(yieldDate) && !dateMap.get(yieldDate).fedFunds) {
                        dateMap.get(yieldDate).fedFunds = lastFedFunds.value;
                    }
                });
            }
            
            // Add Dot Plot median data - quarterly, forward-fill to daily yield dates
            let lastDotPlotMedian = null;
            
            dotPlotMedianData.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(item => {
                const dotPlotDate = new Date(item.date);
                sortedYieldDates.forEach(yieldDate => {
                    const yieldDateObj = new Date(yieldDate);
                    if (yieldDateObj >= dotPlotDate) {
                        if (dateMap.has(yieldDate)) {
                            dateMap.get(yieldDate).dotPlotMedian = item.value;
                            lastDotPlotMedian = item;
                        }
                    }
                });
            });
            
            // Forward-fill Dot Plot median data
            if (lastDotPlotMedian) {
                sortedYieldDates.forEach(yieldDate => {
                    if (dateMap.has(yieldDate) && !dateMap.get(yieldDate).dotPlotMedian) {
                        dateMap.get(yieldDate).dotPlotMedian = lastDotPlotMedian.value;
                    }
                });
            }
            
            // Build combined data array
            dateMap.forEach((values, date) => {
                if (values.yield2Y !== undefined) {
                    combinedData.push({
                        date: date,
                        yield2Y: values.yield2Y,
                        fedFunds: values.fedFunds,
                        dotPlotMedian: values.dotPlotMedian
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Store full data for zoom functionality
            dotPlotFullDataInterest = combinedData;
            
            // Apply 24-month zoom if active
            let chartData = dotPlotZoom24 ? filterTo24Months(combinedData) : combinedData;
            
            const latest = chartData.length > 0 ? chartData[chartData.length - 1] : combinedData[combinedData.length - 1];
            
            // Calculate spreads
            const yield2YSpread = latest.yield2Y - (latest.fedFunds || 0);
            const dotPlotSpread = latest.dotPlotMedian ? (latest.yield2Y - latest.dotPlotMedian) : null;
            
            // Update display
            document.getElementById('dotPlot2Y').textContent = latest.yield2Y.toFixed(2) + '%';
            document.getElementById('dotPlotFedFunds').textContent = (latest.fedFunds || 0).toFixed(2) + '%';
            document.getElementById('dotPlotMedian').textContent = latest.dotPlotMedian ? latest.dotPlotMedian.toFixed(2) + '%' : 'N/A';
            document.getElementById('dotPlotSpread').textContent = dotPlotSpread !== null ? (dotPlotSpread >= 0 ? '+' : '') + dotPlotSpread.toFixed(2) + '%' : 'N/A';
            
            const dotPlotDateEl = document.getElementById('dotPlotLatestDate');
            if (dotPlotDateEl) dotPlotDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('dotPlotAnalysis');
            let analysisText = '';
            if (dotPlotSpread !== null) {
                if (dotPlotSpread > 0.5) {
                    analysisText = `2Y yield (${latest.yield2Y.toFixed(2)}%) is ${dotPlotSpread.toFixed(2)}pp above the FOMC median projection (${latest.dotPlotMedian.toFixed(2)}%). Markets expect higher rates than the Fed projects, suggesting either market skepticism of Fed guidance or expectations of faster tightening.`;
                } else if (dotPlotSpread < -0.5) {
                    analysisText = `2Y yield (${latest.yield2Y.toFixed(2)}%) is ${Math.abs(dotPlotSpread).toFixed(2)}pp below the FOMC median projection (${latest.dotPlotMedian.toFixed(2)}%). Markets expect lower rates than the Fed projects, suggesting expectations of dovish pivot or economic weakness.`;
                } else {
                    analysisText = `2Y yield (${latest.yield2Y.toFixed(2)}%) is closely aligned with FOMC median projection (${latest.dotPlotMedian.toFixed(2)}%), spread: ${dotPlotSpread >= 0 ? '+' : ''}${dotPlotSpread.toFixed(2)}pp. Markets and Fed are in sync.`;
                }
            } else {
                analysisText = `2Y yield: ${latest.yield2Y.toFixed(2)}%, Fed Funds: ${(latest.fedFunds || 0).toFixed(2)}%. Dot Plot data not available for comparison.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('dotPlotChart');
            if (!ctx) {
                console.error('Dot plot chart canvas not found');
                return;
            }
            if (dotPlotChartInstance) {
                dotPlotChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            const yield2YValues = chartData.map(d => d.yield2Y);
            const fedFundsValues = chartData.map(d => d.fedFunds || null);
            const dotPlotMedianValues = chartData.map(d => d.dotPlotMedian || null);
            
            dotPlotChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Fed Median Projection',
                        data: dotPlotMedianValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.2)',
                        borderWidth: 3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        stepped: 'after', // Step function: flat until next value
                        tension: 0,
                        order: 1
                    }, {
                        label: 'Fed Funds Rate',
                        data: fedFundsValues,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.1,
                        order: 2
                    }, {
                        label: '2-Year Yield (Market)',
                        data: yield2YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.1,
                        order: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af', 
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                }
            });
        }
        
        // Process Inflation Expectations
        function processInflationExpectations(inflation10YData, inflation5Y5YData, cpiData) {
            // Calculate YoY CPI inflation
            const cpiYoY = [];
            if (cpiData && cpiData.length > 0) {
                cpiData.sort((a, b) => new Date(a.date) - new Date(b.date));
                for (let i = 12; i < cpiData.length; i++) {
                    const current = cpiData[i].value;
                    const previous = cpiData[i - 12].value;
                    if (previous !== 0 && !isNaN(current) && !isNaN(previous)) {
                        const yoyChange = ((current / previous) - 1) * 100;
                        cpiYoY.push({
                            date: cpiData[i].date,
                            value: yoyChange
                        });
                    }
                }
            }
            
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            inflation10YData.forEach(item => dateMap.set(item.date, { inf10Y: item.value }));
            inflation5Y5YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).inf5Y5Y = item.value;
                }
            });
            
            // Add actual CPI YoY inflation to date map - forward-fill monthly CPI values across daily dates
            // CPI is monthly, inflation expectations are daily, so we forward-fill each month's value
            cpiYoY.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Create a sorted list of all dates from dateMap for forward-filling
            const sortedDates = Array.from(dateMap.keys()).sort((a, b) => new Date(a) - new Date(b));
            let currentCpiValue = null;
            let cpiIndex = 0;
            
            sortedDates.forEach(date => {
                const dateObj = new Date(date);
                const dateYear = dateObj.getFullYear();
                const dateMonth = dateObj.getMonth();
                
                // Find the most recent CPI value that applies to this date
                // CPI values are monthly, so we use the CPI from the same month or the most recent previous month
                while (cpiIndex < cpiYoY.length) {
                    const cpiDate = new Date(cpiYoY[cpiIndex].date);
                    const cpiYear = cpiDate.getFullYear();
                    const cpiMonth = cpiDate.getMonth();
                    
                    // Check if this CPI value is for the current month or earlier
                    if (cpiYear < dateYear || (cpiYear === dateYear && cpiMonth <= dateMonth)) {
                        currentCpiValue = cpiYoY[cpiIndex].value;
                        
                        // Check if there's a newer CPI value that also applies
                        if (cpiIndex < cpiYoY.length - 1) {
                            const nextCpiDate = new Date(cpiYoY[cpiIndex + 1].date);
                            const nextCpiYear = nextCpiDate.getFullYear();
                            const nextCpiMonth = nextCpiDate.getMonth();
                            
                            if (nextCpiYear < dateYear || (nextCpiYear === dateYear && nextCpiMonth <= dateMonth)) {
                                // Move to the newer CPI value
                                cpiIndex++;
                                currentCpiValue = cpiYoY[cpiIndex].value;
                            } else {
                                // This is the most recent CPI value for this date
                                break;
                            }
                        } else {
                            // This is the last CPI value
                            break;
                        }
                    } else {
                        // This CPI value is in the future, stop and use current value
                        break;
                    }
                }
                
                // Assign the CPI value to this date (forward-fill)
                if (currentCpiValue !== null && dateMap.has(date)) {
                    dateMap.get(date).actualInf = currentCpiValue;
                }
            });
            
            // Include all dates that have both inflation expectations (main chart data)
            dateMap.forEach((values, date) => {
                if (values.inf10Y !== undefined && values.inf5Y5Y !== undefined) {
                    combinedData.push({
                        date: date,
                        inf10Y: values.inf10Y,
                        inf5Y5Y: values.inf5Y5Y,
                        actualInf: values.actualInf // Will be undefined if no CPI data for this date
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Store full data for zoom functionality
            inflationChartFullData = combinedData;
            
            // Filter to last 10 years only
            const tenYearsAgo = new Date();
            tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
            const filteredData = combinedData.filter(d => new Date(d.date) >= tenYearsAgo);
            
            // Use filtered data (last 10 years) for display and chart, apply zoom if active
            const baseData = filteredData.length > 0 ? filteredData : combinedData;
            const chartData = inflationChartZoom24 ? filterTo24Months(baseData) : baseData;
            const latest = chartData.length > 0 ? chartData[chartData.length - 1] : combinedData[combinedData.length - 1];
            
            // Update display
            document.getElementById('inflation10Y').textContent = latest.inf10Y.toFixed(2) + '%';
            document.getElementById('inflation5Y5Y').textContent = latest.inf5Y5Y.toFixed(2) + '%';
            
            const inflationExpectDateEl = document.getElementById('inflationExpectLatestDate');
            if (inflationExpectDateEl) inflationExpectDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('inflationAnalysis');
            let analysisText = '';
            const avg = (latest.inf10Y + latest.inf5Y5Y) / 2;
            if (avg > 2.5) {
                analysisText = `Inflation expectations are elevated (10Y: ${latest.inf10Y.toFixed(2)}%, 5Y-5Y: ${latest.inf5Y5Y.toFixed(2)}%). Markets expect sustained higher inflation, which may pressure the Fed to maintain tighter policy.`;
            } else if (avg < 1.5) {
                analysisText = `Inflation expectations are low (10Y: ${latest.inf10Y.toFixed(2)}%, 5Y-5Y: ${latest.inf5Y5Y.toFixed(2)}%). Markets expect subdued inflation, giving the Fed room for accommodative policy.`;
            } else {
                analysisText = `Inflation expectations are moderate (10Y: ${latest.inf10Y.toFixed(2)}%, 5Y-5Y: ${latest.inf5Y5Y.toFixed(2)}%). Markets expect inflation near the Fed's 2% target.`;
            }
            
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('inflationChart');
            if (!ctx) {
                console.error('Inflation chart canvas not found');
                return;
            }
            if (inflationChartInstance) {
                inflationChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            const inf10YValues = chartData.map(d => d.inf10Y);
            const inf5Y5YValues = chartData.map(d => d.inf5Y5Y);
            const targetLine = new Array(chartData.length).fill(2.0);
            
            // Calculate min and max for Y-axis (for inflation expectations and target)
            const allYValues = [...inf10YValues, ...inf5Y5YValues, ...targetLine].filter(v => v !== null && v !== undefined && !isNaN(v));
            const yMin = Math.min(...allYValues);
            const yMax = Math.max(...allYValues);
            const yRange = yMax - yMin;
            const yPadding = yRange * 0.05; // 5% padding
            
            inflationChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '10-Year Breakeven',
                        data: inf10YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '5Y-5Y Forward',
                        data: inf5Y5YValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Fed Target (2%)',
                        data: targetLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            min: yMin - yPadding,
                            max: yMax + yPadding
                        }
                    }
                }
            });
        }
        
        // Process Real Yields
        function processRealYields(realYield10YData) {
            if (realYield10YData.length === 0) return;
            
            realYield10YData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const latest = realYield10YData[realYield10YData.length - 1];
            const previous = realYield10YData.length > 1 ? realYield10YData[realYield10YData.length - 2] : latest;
            const change = latest.value - previous.value;
            
            // Update display
            document.getElementById('realYield10Y').textContent = (latest.value >= 0 ? '+' : '') + latest.value.toFixed(2) + '%';
            
            const realYieldDateEl = document.getElementById('realYieldLatestDate');
            if (realYieldDateEl) realYieldDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('realYieldAnalysis');
            let analysisText = '';
            if (latest.value > 1.0) {
                analysisText = `Real yields are positive and elevated (${latest.value.toFixed(2)}%). Investors are being well-compensated for inflation risk. This suggests tight financial conditions.`;
            } else if (latest.value > 0) {
                analysisText = `Real yields are positive but low (${latest.value.toFixed(2)}%). Investors receive modest compensation after inflation. Financial conditions are accommodative.`;
            } else {
                analysisText = `Real yields are negative (${latest.value.toFixed(2)}%). Investors are not compensated for inflation, indicating very accommodative policy and potential asset price inflation.`;
            }
            if (change !== 0) {
                analysisText += ` Recent change: ${change >= 0 ? '+' : ''}${change.toFixed(2)}pp.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('realYieldChart');
            if (realYieldChartInstance) {
                realYieldChartInstance.destroy();
            }
            
            const labels = realYield10YData.map(d => d.date);
            const realYieldValues = realYield10YData.map(d => d.value);
            const zeroLine = new Array(realYield10YData.length).fill(0);
            
            realYieldChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '10Y Real Yield',
                        data: realYieldValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return (value >= 0 ? '+' : '') + value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                }
            });
        }
        
        // Process Forward Term Premium
        function processForwardTermPremium(forwardPremium5YData, forwardPremium10YData) {
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            forwardPremium5YData.forEach(item => dateMap.set(item.date, { fp5Y: item.value }));
            forwardPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).fp10Y = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.fp5Y !== undefined && values.fp10Y !== undefined) {
                    combinedData.push({
                        date: date,
                        fp5Y: values.fp5Y,
                        fp10Y: values.fp10Y
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Store full data for zoom
            forwardPremiumFullData = combinedData;
            
            // Apply zoom filter if active
            let chartData = forwardPremiumZoom24 ? filterTo24Months(combinedData) : combinedData;
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            const fp10YChange = latest.fp10Y - previous.fp10Y;
            
            // Update display
            document.getElementById('forwardPremium5Y').textContent = (latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3) + '%';
            document.getElementById('forwardPremium10Y').textContent = (latest.fp10Y >= 0 ? '+' : '') + latest.fp10Y.toFixed(3) + '%';
            
            const forwardPremiumDateEl = document.getElementById('forwardPremiumLatestDate');
            if (forwardPremiumDateEl) forwardPremiumDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('forwardPremiumAnalysis');
            let analysisText = '';
            if (fp10YChange > 0.2) {
                analysisText = `Forward term premium is spiking (10Y forward: ${latest.fp10Y.toFixed(3)}%, up ${fp10YChange.toFixed(3)}pp). This suggests the market is worried about long-term fiscal stability or inflation. The Fed uses this to gauge "long-run inflation uncertainty." 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%.`;
            } else if (latest.fp10Y > 0.5) {
                analysisText = `Forward term premium is elevated (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect higher long-term risk compensation, indicating concerns about future policy or fiscal sustainability.`;
            } else if (latest.fp10Y < 0) {
                analysisText = `Forward term premium is negative (10Y forward: ${latest.fp10Y.toFixed(3)}%, 5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%). Markets expect minimal long-term risk, suggesting confidence in future policy stability.`;
            } else {
                analysisText = `Forward term premiums are moderate (5Y forward: ${(latest.fp5Y >= 0 ? '+' : '') + latest.fp5Y.toFixed(3)}%, 10Y forward: ${latest.fp10Y.toFixed(3)}%). Markets expect normal long-term risk compensation.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('forwardPremiumChart');
            if (forwardPremiumChartInstance) {
                forwardPremiumChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            const fp5YValues = chartData.map(d => d.fp5Y);
            const fp10YValues = chartData.map(d => d.fp10Y);
            const fpDiffValues = chartData.map(d => d.fp10Y - d.fp5Y);
            const zeroLine = new Array(chartData.length).fill(0);
            
            forwardPremiumChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '5Y Forward Term Premium',
                        data: fp5YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y Forward Term Premium',
                        data: fp10YValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y - 5Y Forward Term Premium Spread',
                        data: fpDiffValues,
                        borderColor: '#6b7280',
                        backgroundColor: 'rgba(107, 114, 128, 0.1)',
                        borderWidth: 1.5,
                        borderDash: [4, 4],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        hidden: true
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return (value >= 0 ? '+' : '') + value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                }
            });
        }
        
        // Process Yield Decomposition
        // Formula: Nominal Yield = Real Rate + Expected Inflation + Term Premium
        // Real Rate = TIPS (DFII10). Expected Inflation = Breakeven Rate (GS10 - DFII10). Term Premium = Kim-Wright (THREEFYTP10).
        function processYieldDecomposition(gs10Data, realYield10YData, termPremium10YData) {
            const combinedData = [];
            const dateMap = new Map();
            
            gs10Data.forEach(item => dateMap.set(item.date, { gs10: item.value }));
            realYield10YData.forEach(item => {
                if (dateMap.has(item.date)) dateMap.get(item.date).realRate = item.value;
                else dateMap.set(item.date, { realRate: item.value });
            });
            termPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) dateMap.get(item.date).termPremium = item.value;
                else dateMap.set(item.date, { termPremium: item.value });
            });
            
            dateMap.forEach((values, date) => {
                if (values.gs10 !== undefined && values.realRate !== undefined && values.termPremium !== undefined) {
                    // Calculate expected inflation as breakeven rate: Nominal Yield - Real Rate (TIPS)
                    const expectedInflation = values.gs10 - values.realRate;
                    
                    // Calculate the component sum
                    const componentSum = values.realRate + expectedInflation + values.termPremium;
                    // Calculate the discrepancy/residual
                    const discrepancy = values.gs10 - componentSum;
                    // Reconcile by adjusting the term premium (most flexible component since it's model-estimated)
                    // Adjusted Term Premium = Nominal Yield - Real Rate - Expected Inflation
                    const reconciledTermPremium = values.termPremium + discrepancy;
                    
                    combinedData.push({
                        date: date,
                        yield: values.gs10,
                        realRate: values.realRate,
                        expectedInflation: expectedInflation,
                        termPremium: values.termPremium, // Original model value
                        reconciledTermPremium: reconciledTermPremium, // Adjusted to balance equation
                        discrepancy: discrepancy // Store for analysis
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            yieldDecompFullData = combinedData;
            let chartData = yieldDecompZoom24 ? filterTo24Months(combinedData) : combinedData;
            
            const latest = combinedData[combinedData.length - 1];
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            
            // Use reconciled term premium for display (balances the equation)
            const displayTermPremium = latest.reconciledTermPremium !== undefined ? latest.reconciledTermPremium : latest.termPremium;
            
            const yield10El = document.getElementById('yield10YTotal');
            const realEl = document.getElementById('yieldRealRate');
            const infEl = document.getElementById('yieldInflation');
            const tpEl = document.getElementById('yieldTermPremium');
            if (yield10El) yield10El.textContent = latest.yield.toFixed(2) + '%';
            if (realEl) realEl.textContent = (latest.realRate >= 0 ? '+' : '') + latest.realRate.toFixed(2) + '%';
            if (infEl) infEl.textContent = latest.expectedInflation.toFixed(2) + '%';
            if (tpEl) tpEl.textContent = (displayTermPremium >= 0 ? '+' : '') + displayTermPremium.toFixed(2) + '%';
            
            const analysisEl = document.getElementById('yieldDecompAnalysis');
            if (analysisEl) {
                const yieldChange = latest.yield - previous.yield;
                const realChange = latest.realRate - previous.realRate;
                const infChange = latest.expectedInflation - previous.expectedInflation;
                const prevDisplayTP = previous.reconciledTermPremium !== undefined ? previous.reconciledTermPremium : previous.termPremium;
                const tpChange = displayTermPremium - prevDisplayTP;
                const discrepancy = latest.discrepancy !== undefined ? latest.discrepancy : 0;
                
                let analysisText = '';
                if (Math.abs(yieldChange) > 0.1) {
                    const parts = [];
                    if (Math.abs(realChange) > 0.05) parts.push(`Real Rate ${realChange >= 0 ? '+' : ''}${realChange.toFixed(2)}pp`);
                    if (Math.abs(infChange) > 0.05) parts.push(`Expected Inflation ${infChange >= 0 ? '+' : ''}${infChange.toFixed(2)}pp`);
                    if (Math.abs(tpChange) > 0.05) parts.push(`Term Premium ${tpChange >= 0 ? '+' : ''}${tpChange.toFixed(2)}pp`);
                    analysisText = `10Y yield ${yieldChange >= 0 ? 'rose' : 'fell'} ${Math.abs(yieldChange).toFixed(2)}pp to ${latest.yield.toFixed(2)}%. ${parts.length ? 'Drivers: ' + parts.join(', ') + '. ' : ''}`;
                    // Add reconciliation note if significant discrepancy
                    if (Math.abs(discrepancy) > 0.05) {
                        analysisText += ` [Term premium adjusted by ${(discrepancy >= 0 ? '+' : '') + discrepancy.toFixed(2)}pp to reconcile with nominal yield]`;
                    }
                } else {
                    analysisText = `Nominal ${latest.yield.toFixed(2)}% = Real Rate ${(latest.realRate >= 0 ? '+' : '') + latest.realRate.toFixed(2)}% + Expected Inflation ${latest.expectedInflation.toFixed(2)}% + Term Premium ${(displayTermPremium >= 0 ? '+' : '') + displayTermPremium.toFixed(2)}%.`;
                    // Add reconciliation note if significant discrepancy
                    if (Math.abs(discrepancy) > 0.05) {
                        analysisText += ` [Term premium reconciled: model value ${(latest.termPremium >= 0 ? '+' : '') + latest.termPremium.toFixed(2)}% adjusted by ${(discrepancy >= 0 ? '+' : '') + discrepancy.toFixed(2)}pp]`;
                    }
                }
                analysisEl.textContent = analysisText;
            }
            
            const ctx = document.getElementById('yieldDecompChart');
            if (!ctx) return;
            if (yieldDecompChartInstance) yieldDecompChartInstance.destroy();
            
            const labels = chartData.map(d => d.date);
            const realValues = chartData.map(d => d.realRate);
            const infValues = chartData.map(d => d.expectedInflation);
            // Use reconciled term premium for chart (balances the equation)
            const tpValues = chartData.map(d => d.reconciledTermPremium !== undefined ? d.reconciledTermPremium : d.termPremium);
            const nominalValues = chartData.map(d => d.yield);
            const realPlusInf = realValues.map((r, i) => r + infValues[i]);
            const componentSum = realValues.map((r, i) => r + infValues[i] + tpValues[i]);
            
            yieldDecompChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Real Rate (r*)', data: realValues, borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.2)', borderWidth: 2, fill: 'origin', pointRadius: 0, pointHoverRadius: 0 },
                        { label: 'Expected Inflation', data: realPlusInf, borderColor: '#f97316', backgroundColor: 'rgba(249, 115, 22, 0.15)', borderWidth: 2, fill: 0, pointRadius: 0, pointHoverRadius: 0 },
                        { label: 'Term Premium', data: componentSum, borderColor: '#60a5fa', backgroundColor: 'rgba(96, 165, 250, 0.15)', borderWidth: 2, fill: '+1', pointRadius: 0, pointHoverRadius: 0 },
                        { label: 'Nominal Yield (GS10)', data: nominalValues, borderColor: '#ffffff', backgroundColor: 'transparent', borderWidth: 2, borderDash: [3, 3], fill: false, pointRadius: 0, pointHoverRadius: 0 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#9ca3af', font: { size: 10 }, boxWidth: 12, padding: 8 } },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            filter: t => t.datasetIndex === 3,
                            callbacks: {
                                label: function(context) {
                                    const i = context.dataIndex;
                                    const ds = context.chart.data.datasets;
                                    const real = ds[0].data[i];
                                    const realPlusInf = ds[1].data[i];
                                    const inf = realPlusInf - real;
                                    const tp = ds[2].data[i] - realPlusInf;
                                    const nominal = ds[3].data[i];
                                    const componentSum = real + inf + tp;
                                    const discrepancy = nominal - componentSum;
                                    const fmt = (v) => v.toFixed(2).padStart(6, ' ');
                                    const fmtS = (v) => (v >= 0 ? '+' : '-') + Math.abs(v).toFixed(2).padStart(5, ' ');
                                    const lines = [
                                        'Real Rate (r*):     ' + fmtS(real) + '%',
                                        'Expected Inflation: ' + fmt(inf) + '%',
                                        'Term Premium:       ' + fmtS(tp) + '%',
                                        '──────────────────────────',
                                        'Component Sum:      ' + fmt(componentSum) + '%',
                                        'Nominal (GS10):     ' + fmt(nominal) + '%'
                                    ];
                                    // Show reconciliation note if there's a discrepancy (should be near zero after reconciliation)
                                    if (Math.abs(discrepancy) > 0.01) {
                                        lines.push(`Residual:          ${fmtS(discrepancy)}%`);
                                    }
                                    return lines;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                        y: { ticks: { color: '#9ca3af', font: { size: 9 }, callback: v => v.toFixed(2) + '%' }, grid: { color: 'rgba(156, 163, 175, 0.1)' } }
                    }
                }
            });
        }
        
        // Process Market vs Model Rate Comparison
        // Compares TIPS-based market rates with Kim-Wright model risk-neutral rates
        function processMarketVsModelComparison(gs10Data, realYield10YData, termPremium10YData, inflation10YData, inflation5Y5YData) {
            try {
                if (!gs10Data?.length || !realYield10YData?.length || !termPremium10YData?.length) {
                    console.warn('Insufficient data for market vs model comparison');
                    return;
                }
                
                // Get latest values from each dataset
                const latestGs10 = gs10Data[gs10Data.length - 1];
                const latestTips = realYield10YData[realYield10YData.length - 1];
                const latestTermPrem = termPremium10YData[termPremium10YData.length - 1];
                const latestBreakeven = inflation10YData?.length > 0 ? inflation10YData[inflation10YData.length - 1] : null;
                const latest5Y5Y = inflation5Y5YData?.length > 0 ? inflation5Y5YData[inflation5Y5YData.length - 1] : null;
                
                // Market-Based Values (Observable)
                const mktNominal = latestGs10.value; // GS10 nominal yield
                const mktRealRate = latestTips.value; // TIPS 10Y real yield (DFII10)
                const mktInflation = latestBreakeven ? latestBreakeven.value : (mktNominal - mktRealRate); // Breakeven inflation (T10YIE)
                const mktTermPrem = mktNominal - mktRealRate - mktInflation; // Implied market term premium (should be ~0 by construction)
                
                // Model-Based Values (Kim-Wright)
                const modelTermPrem = latestTermPrem.value; // Kim-Wright 10Y term premium (THREEFYTP10)
                const modelNominal = mktNominal - modelTermPrem; // Risk-Neutral Nominal = Nominal - Term Premium
                
                // For model inflation expectation, use survey-based estimate (roughly 2.0-2.1%)
                // We can derive this from the 5Y-5Y forward or use a reasonable estimate
                const surveyInflation = latest5Y5Y ? Math.min(latest5Y5Y.value, 2.5) : 2.10; // Cap at 2.5% for reasonableness
                const modelRealRate = modelNominal - surveyInflation; // Risk-Neutral Real Rate
                
                // Calculate gaps (Market - Model = Premium investors are charging)
                const realRateGap = mktRealRate - modelRealRate;
                const inflationGap = mktInflation - surveyInflation;
                const nominalGap = mktNominal - modelNominal; // This equals the term premium
                
                // Helper function to format values
                const fmt = (v, decimals = 2) => {
                    if (v === null || v === undefined || isNaN(v)) return '--';
                    return v.toFixed(decimals) + '%';
                };
                const fmtBps = (v) => {
                    if (v === null || v === undefined || isNaN(v)) return '--';
                    const bps = Math.round(v * 100);
                    return (bps >= 0 ? '+' : '') + bps + ' bps';
                };
                
                // Update table values
                const setEl = (id, text) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = text;
                };
                
                // Market column
                setEl('mktRealRate', fmt(mktRealRate));
                setEl('mktInflation', fmt(mktInflation));
                setEl('mktNominal', fmt(mktNominal));
                setEl('mktTermPrem', fmt(mktNominal - mktRealRate - mktInflation)); // Implied (near 0)
                
                // Model column
                setEl('modelRealRate', fmt(modelRealRate));
                setEl('modelInflation', fmt(surveyInflation));
                setEl('modelNominal', fmt(modelNominal));
                setEl('modelTermPrem', fmt(modelTermPrem));
                
                // Gap column
                setEl('realRateGap', fmtBps(realRateGap));
                setEl('inflationGap', fmtBps(inflationGap));
                setEl('nominalGap', fmtBps(nominalGap));
                setEl('termPremGap', fmtBps(modelTermPrem)); // Term premium IS the gap
                
                // Update insight cards
                // 1. Real Rate Risk Premium
                const realPremEl = document.getElementById('realRatePremiumValue');
                const realPremTextEl = document.getElementById('realRatePremiumText');
                if (realPremEl) realPremEl.textContent = fmtBps(realRateGap);
                if (realPremTextEl) {
                    if (realRateGap > 0.4) {
                        realPremTextEl.textContent = `Significant real rate premium (${fmtBps(realRateGap)}). Investors fear structural rise in r* due to fiscal concerns. Over half of total premium is "real rate risk."`;
                    } else if (realRateGap > 0.2) {
                        realPremTextEl.textContent = `Moderate real rate premium (${fmtBps(realRateGap)}). Some concerns about neutral rate shifting higher due to debt issuance.`;
                    } else if (realRateGap > 0) {
                        realPremTextEl.textContent = `Small real rate premium (${fmtBps(realRateGap)}). Markets largely aligned with model expectations for real rates.`;
                    } else {
                        realPremTextEl.textContent = `Negative real rate gap (${fmtBps(realRateGap)}). Market expects real rates lower than the model suggests - possible growth concerns.`;
                    }
                }
                
                // 2. Fed Policy Stance
                const fedStanceEl = document.getElementById('fedStanceValue');
                const fedStanceTextEl = document.getElementById('fedStanceText');
                const fedNeutralLow = 0.5, fedNeutralHigh = 1.0;
                const restrictiveness = mktRealRate - fedNeutralHigh;
                if (fedStanceEl) {
                    if (mktRealRate > fedNeutralHigh) {
                        fedStanceEl.textContent = 'RESTRICTIVE';
                        fedStanceEl.className = 'text-2xl font-bold text-red-400 mb-1';
                    } else if (mktRealRate >= fedNeutralLow) {
                        fedStanceEl.textContent = 'NEUTRAL';
                        fedStanceEl.className = 'text-2xl font-bold text-yellow-400 mb-1';
                    } else {
                        fedStanceEl.textContent = 'ACCOMMODATIVE';
                        fedStanceEl.className = 'text-2xl font-bold text-green-400 mb-1';
                    }
                }
                if (fedStanceTextEl) {
                    if (mktRealRate > fedNeutralHigh) {
                        fedStanceTextEl.textContent = `Real rate (${fmt(mktRealRate)}) is ${fmtBps(restrictiveness)} above Fed's neutral range. Deep into restrictive territory - borrowing costs are painful.`;
                    } else if (mktRealRate >= fedNeutralLow) {
                        fedStanceTextEl.textContent = `Real rate (${fmt(mktRealRate)}) within Fed's traditional neutral range (0.5%-1.0%). Policy is balanced.`;
                    } else {
                        fedStanceTextEl.textContent = `Real rate (${fmt(mktRealRate)}) below Fed's neutral range. Accommodative stance - easy money conditions.`;
                    }
                }
                
                // 3. Inflation Risk Premium
                const infPremEl = document.getElementById('inflationPremiumValue');
                const infPremTextEl = document.getElementById('inflationPremiumText');
                if (infPremEl) infPremEl.textContent = fmtBps(inflationGap);
                if (infPremTextEl) {
                    if (inflationGap > 0.2) {
                        infPremTextEl.textContent = `Market pricing ${fmtBps(inflationGap)} more inflation than surveys. Significant "inflation uncertainty tax" embedded in rates.`;
                    } else if (inflationGap > 0) {
                        infPremTextEl.textContent = `Small inflation premium (${fmtBps(inflationGap)}). Market slightly more cautious on inflation than survey respondents.`;
                    } else {
                        infPremTextEl.textContent = `Negative inflation gap (${fmtBps(inflationGap)}). Markets expect lower inflation than surveys - possible disinflation confidence.`;
                    }
                }
                
                // Update summary section
                setEl('summaryRiskNeutral', fmt(modelNominal));
                setEl('summaryNominal', fmt(mktNominal));
                setEl('summaryPremium', fmtBps(nominalGap));
                
                const summaryEl = document.getElementById('summaryAnalysis');
                if (summaryEl) {
                    let analysis = `The ${fmtBps(nominalGap)} gap between the "sticker price" (${fmt(mktNominal)}) and "true cost" (${fmt(modelNominal)}) represents the "insurance policy" investors charge for navigating the next decade. `;
                    
                    if (realRateGap > inflationGap && realRateGap > 0.2) {
                        analysis += `The premium is primarily driven by <strong class="text-red-400">real rate risk</strong> (${fmtBps(realRateGap)}), suggesting concerns about structural shifts in r* from fiscal deficits rather than inflation fears. `;
                    } else if (inflationGap > realRateGap && inflationGap > 0.2) {
                        analysis += `The premium is primarily driven by <strong class="text-orange-400">inflation uncertainty</strong> (${fmtBps(inflationGap)}), suggesting markets don't fully trust inflation will stay anchored. `;
                    } else {
                        analysis += `The premium is split between real rate risk (${fmtBps(realRateGap)}) and inflation uncertainty (${fmtBps(inflationGap)}). `;
                    }
                    
                    if (mktRealRate > 1.5) {
                        analysis += `<strong class="text-red-400">Warning:</strong> Real rates at ${fmt(mktRealRate)} are doing the "heavy lifting" - this is a growth/supply driven yield environment, not just crash fear.`;
                    }
                    
                    summaryEl.innerHTML = analysis;
                }
                
                console.log('Market vs Model comparison updated:', {
                    mktNominal, mktRealRate, mktInflation,
                    modelNominal, modelRealRate, surveyInflation, modelTermPrem,
                    realRateGap, inflationGap, nominalGap
                });
                
            } catch (error) {
                console.error('Error processing market vs model comparison:', error);
            }
        }
        
        // Process FOMC Dot Plot vs 2Y Yield
        function processDotPlotComparison(yield2YData, fedFundsData, dotPlotMedianData) {
            // Handle empty data arrays
            if (!yield2YData || yield2YData.length === 0) {
                console.error('No 2Y yield data available for dot plot comparison');
                return;
            }
            fedFundsData = fedFundsData || [];
            dotPlotMedianData = dotPlotMedianData || [];
            
            // Align dates - Dot Plot data is quarterly, so we need to align carefully
            const combinedData = [];
            const dateMap = new Map();
            
            // Add 2Y yield data
            yield2YData.forEach(item => {
                if (item.value !== null && item.value !== undefined && !isNaN(item.value)) {
                    dateMap.set(item.date, { yield2Y: item.value });
                }
            });
            
            // Sort yield data dates for forward-filling
            const sortedYieldDates = Array.from(dateMap.keys()).sort((a, b) => new Date(a) - new Date(b));
            
            // Add Fed Funds Rate data - align with daily 2Y yield data and forward-fill
            let lastFedFunds = null;
            fedFundsData.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(item => {
                const fedFundsDate = new Date(item.date);
                // Find matching or nearest yield date (within 7 days)
                for (let i = 0; i < sortedYieldDates.length; i++) {
                    const yieldDate = new Date(sortedYieldDates[i]);
                    const diff = Math.abs(yieldDate - fedFundsDate);
                    if (diff <= 7 * 24 * 60 * 60 * 1000) { // Within 7 days
                        if (dateMap.has(sortedYieldDates[i])) {
                            dateMap.get(sortedYieldDates[i]).fedFunds = item.value;
                            lastFedFunds = item.value;
                        }
                        break;
                    }
                }
            });
            
            // Forward-fill Fed Funds values (daily data should persist until next update)
            sortedYieldDates.forEach(date => {
                if (dateMap.has(date)) {
                    const values = dateMap.get(date);
                    if (values.fedFunds !== undefined && values.fedFunds !== null) {
                        lastFedFunds = values.fedFunds;
                    } else if (lastFedFunds !== null) {
                        values.fedFunds = lastFedFunds;
                    }
                }
            });
            
            // Helper function to align quarterly dot plot data to daily yield dates
            function alignDotPlotData(dotPlotData, fieldName) {
                let lastValue = null;
                let alignedCount = 0;
                dotPlotData.sort((a, b) => new Date(a.date) - new Date(b.date)).forEach(item => {
                    const dotPlotDate = new Date(item.date);
                    // Find the first yield date on or after the dot plot release date
                    for (let i = 0; i < sortedYieldDates.length; i++) {
                        const yieldDate = new Date(sortedYieldDates[i]);
                        const diff = yieldDate - dotPlotDate;
                        // If yield date is on or after the dot plot date (within 90 days), assign value
                        if (diff >= 0 && diff <= 90 * 24 * 60 * 60 * 1000) {
                            if (dateMap.has(sortedYieldDates[i])) {
                                dateMap.get(sortedYieldDates[i])[fieldName] = item.value;
                                lastValue = item.value;
                                alignedCount++;
                            }
                            break;
                        }
                        // If this is the last yield date before the dot plot date, still assign if within 90 days
                        if (i === sortedYieldDates.length - 1 || new Date(sortedYieldDates[i + 1]) > dotPlotDate) {
                            if (diff > -90 * 24 * 60 * 60 * 1000 && dateMap.has(sortedYieldDates[i])) {
                                dateMap.get(sortedYieldDates[i])[fieldName] = item.value;
                                lastValue = item.value;
                                alignedCount++;
                            }
                            break;
                        }
                    }
                });
                
                // Forward-fill values (quarterly data persists until next release)
                let forwardFilledCount = 0;
                sortedYieldDates.forEach(date => {
                    if (dateMap.has(date)) {
                        const values = dateMap.get(date);
                        if (values[fieldName] !== undefined && values[fieldName] !== null) {
                            lastValue = values[fieldName];
                        } else if (lastValue !== null) {
                            values[fieldName] = lastValue;
                            forwardFilledCount++;
                        }
                    }
                });
                
                return { alignedCount, forwardFilledCount, lastValue };
            }
            
            // Log raw dot plot data for debugging
            if (dotPlotMedianData.length > 0) {
                console.log('Raw Dot Plot Data from FRED:', {
                    median: dotPlotMedianData.length > 0 ? {
                        count: dotPlotMedianData.length,
                        first: dotPlotMedianData[0],
                        last: dotPlotMedianData[dotPlotMedianData.length - 1],
                        sample: dotPlotMedianData.slice(0, 3)
                    } : 'No data',
                });
            }
            
            // Add Dot Plot median (current year) - quarterly data with forward-fill
            const medianResult = alignDotPlotData(dotPlotMedianData, 'dotPlotMedian');
            console.log('Dot Plot Median alignment:', medianResult);
            
            
            dateMap.forEach((values, date) => {
                if (values.yield2Y !== undefined) {
                    combinedData.push({
                        date: date,
                        yield2Y: values.yield2Y,
                        fedFunds: values.fedFunds,
                        dotPlotMedian: values.dotPlotMedian
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Filter to last 20 years only
            const twentyYearsAgo = new Date();
            twentyYearsAgo.setFullYear(twentyYearsAgo.getFullYear() - 20);
            const filteredData = combinedData.filter(d => new Date(d.date) >= twentyYearsAgo);
            
            // Store full data for filtering (after 20-year filter) - interest rates dot plot
            dotPlotFullDataInterest = filteredData;
            
            // Log verification of dot plot data alignment
            const sampleDataBeforeFilter = filteredData.filter(d => d.dotPlotMedian !== null);
            if (sampleDataBeforeFilter.length > 0) {
                console.log('Dot Plot Data Verification (after alignment, before zoom):', {
                    totalPoints: filteredData.length,
                    pointsWithDotPlotData: sampleDataBeforeFilter.length,
                    sample: sampleDataBeforeFilter.slice(0, 3).map(d => ({
                        date: d.date,
                        median: d.dotPlotMedian,
                        yield2Y: d.yield2Y
                    })),
                    latest: sampleDataBeforeFilter.length > 0 ? {
                        date: sampleDataBeforeFilter[sampleDataBeforeFilter.length - 1].date,
                        median: sampleDataBeforeFilter[sampleDataBeforeFilter.length - 1].dotPlotMedian
                    } : null
                });
            } else {
                console.warn('No dot plot data found after alignment. Check FRED series FEDTARMD.');
            }
            
            // Apply 24-month zoom if active
            let chartData = dotPlotZoom24 ? filterTo24Months(filteredData) : filteredData;
            
            // Get latest values (may have nulls for dot plot if quarterly data doesn't align)
            const latest = filteredData.length > 0 ? filteredData[filteredData.length - 1] : combinedData[combinedData.length - 1];
            
            // Find most recent non-null dot plot values (from filtered data)
            const dataForLatest = filteredData.length > 0 ? filteredData : combinedData;
            let latestFedFunds = latest.fedFunds;
            let latestMedian = latest.dotPlotMedian;
            for (let i = dataForLatest.length - 1; i >= 0; i--) {
                if (latestFedFunds === undefined || latestFedFunds === null) {
                    latestFedFunds = dataForLatest[i].fedFunds;
                }
                if (latestMedian === undefined || latestMedian === null) {
                    latestMedian = dataForLatest[i].dotPlotMedian;
                }
                if (latestFedFunds !== undefined && latestMedian !== undefined) break;
            }
            
            // Update display
            document.getElementById('dotPlot2Y').textContent = latest.yield2Y.toFixed(2) + '%';
            if (latestFedFunds !== undefined && latestFedFunds !== null) {
                document.getElementById('dotPlotFedFunds').textContent = latestFedFunds.toFixed(2) + '%';
            } else {
                document.getElementById('dotPlotFedFunds').textContent = 'N/A';
            }
            if (latestMedian !== undefined && latestMedian !== null) {
                document.getElementById('dotPlotMedian').textContent = latestMedian.toFixed(2) + '%';
            } else {
                document.getElementById('dotPlotMedian').textContent = 'N/A';
            }
            
            // Analysis - "Credibility Gap" interpretation with Fed Funds context
            const analysisEl = document.getElementById('dotPlotAnalysis');
            let analysisText = '';
            if (latestMedian !== undefined && latestMedian !== null) {
                const spread2Y = latest.yield2Y - latestMedian;
                const spreadFedFunds = latestFedFunds !== undefined && latestFedFunds !== null ? latestFedFunds - latestMedian : null;
                const spread2YvsFedFunds = latestFedFunds !== undefined && latestFedFunds !== null ? latest.yield2Y - latestFedFunds : null;
                
                let mainAnalysis = '';
                if (spread2Y < -0.5) {
                    // Dovish Market: Market expects easier policy than Fed signals
                    mainAnalysis = `🔴 DOVISH MARKET: 2Y Yield (${latest.yield2Y.toFixed(2)}%) is ${Math.abs(spread2Y).toFixed(2)}pp below Fed's median projection (${latestMedian.toFixed(2)}%). The market expects a recession or faster cooling—it thinks the Fed is being "too hawkish." This credibility gap often leads to high stock market volatility.`;
                } else if (spread2Y > 0.5) {
                    // Hawkish Market: Market expects tighter policy than Fed signals
                    mainAnalysis = `🟡 HAWKISH MARKET: 2Y Yield (${latest.yield2Y.toFixed(2)}%) is ${spread2Y.toFixed(2)}pp above Fed's median projection (${latestMedian.toFixed(2)}%). The market thinks inflation will be sticky—it expects the Fed will have to raise rates higher or hold longer than projected.`;
                } else {
                    // Alignment: Market believes Fed guidance
                    mainAnalysis = `🟢 ALIGNMENT: 2Y Yield (${latest.yield2Y.toFixed(2)}%) is aligned with Fed's median projection (${latestMedian.toFixed(2)}%). The market "believes" the Fed's guidance. This usually leads to lower volatility for the S&P 500.`;
                }
                
                // Add Fed Funds context - explain the relationship between Fed Funds, 2Y Yield, and Fed expectations
                if (spreadFedFunds !== null && spread2YvsFedFunds !== null) {
                    let fundsContext = '';
                    
                    // Fed Funds vs Median Projection
                    if (Math.abs(spreadFedFunds) < 0.25) {
                        fundsContext = ` Current Fed Funds (${latestFedFunds.toFixed(2)}%) aligns with median projection (${latestMedian.toFixed(2)}%).`;
                    } else if (spreadFedFunds > 0.25) {
                        fundsContext = ` Current Fed Funds (${latestFedFunds.toFixed(2)}%) is ${spreadFedFunds.toFixed(2)}pp above median projection (${latestMedian.toFixed(2)}%)—policy ahead of forecast.`;
                    } else {
                        fundsContext = ` Current Fed Funds (${latestFedFunds.toFixed(2)}%) is ${Math.abs(spreadFedFunds).toFixed(2)}pp below median projection (${latestMedian.toFixed(2)}%)—policy behind forecast.`;
                    }
                    
                    // 2Y Yield vs Fed Funds - this is the key market expectation signal
                    fundsContext += ` `;
                    if (spread2YvsFedFunds > 0.5) {
                        fundsContext += `2Y Yield (${latest.yield2Y.toFixed(2)}%) is ${spread2YvsFedFunds.toFixed(2)}pp above Fed Funds (${latestFedFunds.toFixed(2)}%)—markets expect rate hikes.`;
                    } else if (spread2YvsFedFunds < -0.5) {
                        fundsContext += `2Y Yield (${latest.yield2Y.toFixed(2)}%) is ${Math.abs(spread2YvsFedFunds).toFixed(2)}pp below Fed Funds (${latestFedFunds.toFixed(2)}%)—markets expect rate cuts.`;
                    } else {
                        fundsContext += `2Y Yield (${latest.yield2Y.toFixed(2)}%) aligns with Fed Funds (${latestFedFunds.toFixed(2)}%)—markets expect stable policy.`;
                    }
                    
                    // Combined interpretation: What does the spread between 2Y and Fed Funds tell us about market vs Fed expectations?
                    fundsContext += ` `;
                    if (spread2Y > 0 && spread2YvsFedFunds > 0) {
                        fundsContext += `Both 2Y Yield and Fed Funds are above the median projection, indicating markets and Fed agree on tightening path.`;
                    } else if (spread2Y < 0 && spread2YvsFedFunds < 0) {
                        fundsContext += `Both 2Y Yield and Fed Funds are below the median projection, indicating markets and Fed agree on easing path.`;
                    } else if (spread2YvsFedFunds > 0.5 && spread2Y < 0) {
                        fundsContext += `Markets expect hikes (2Y > Fed Funds) but Fed projects easing (2Y < median)—policy divergence expected.`;
                    } else if (spread2YvsFedFunds < -0.5 && spread2Y > 0) {
                        fundsContext += `Markets expect cuts (2Y < Fed Funds) but Fed projects tightening (2Y > median)—policy divergence expected.`;
                    }
                    
                    analysisText = mainAnalysis + fundsContext;
                } else {
                    analysisText = mainAnalysis;
                }
            } else {
                analysisText = `2Y Yield: ${latest.yield2Y.toFixed(2)}%. Fed Dot Plot data not available for comparison.`;
            }
            analysisEl.textContent = analysisText;
            
            // Apply 24-month zoom if active
            let initialChartData = filteredData.length > 0 ? filteredData : combinedData;
            if (dotPlotZoom24) {
                initialChartData = filterTo24Months(initialChartData);
            }
            
            // Create chart with initial filtered data (last 20 years or 24 months if zoomed)
            updateDotPlotChart(initialChartData);
            
            // Add event listener for checkbox (only add once)
            const checkbox = document.getElementById('dotPlotOneYearFilter');
            if (checkbox && !checkbox.hasAttribute('data-listener-added')) {
                checkbox.setAttribute('data-listener-added', 'true');
                checkbox.addEventListener('change', function() {
                    if (!dotPlotFullDataInterest || dotPlotFullDataInterest.length === 0) return;
                    
                    if (this.checked) {
                        // Filter to last 1 year
                        const oneYearAgo = new Date();
                        oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
                        const oneYearData = dotPlotFullDataInterest.filter(d => new Date(d.date) >= oneYearAgo);
                        updateDotPlotChart(oneYearData);
                    } else {
                        // Show full 20 years or 24 months based on zoom state
                        const dataToShow = dotPlotZoom24 ? filterTo24Months(dotPlotFullDataInterest) : dotPlotFullDataInterest;
                        updateDotPlotChart(dataToShow);
                    }
                });
            }
        }
        
        // Function to update dot plot chart with given data
        function updateDotPlotChart(chartData) {
            const ctx = document.getElementById('dotPlotChart');
            if (!ctx) return;
            
            if (dotPlotChartInstance) {
                dotPlotChartInstance.destroy();
            }
            
            // Verify data integrity: Range High should be >= Range Low, Median should be between them
            const verifiedData = chartData.map(d => {
                const median = d.dotPlotMedian !== undefined && d.dotPlotMedian !== null ? d.dotPlotMedian : null;
                return d;
            });
            
            const labels = verifiedData.map(d => d.date);
            const yield2YValues = verifiedData.map(d => d.yield2Y);
            const fedFundsValues = verifiedData.map(d => d.fedFunds !== undefined && d.fedFunds !== null ? d.fedFunds : null);
            const dotPlotMedianValues = verifiedData.map(d => d.dotPlotMedian !== undefined && d.dotPlotMedian !== null ? d.dotPlotMedian : null);
            
            dotPlotChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Fed Median Projection',
                        data: dotPlotMedianValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.2)',
                        borderWidth: 3,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        stepped: 'after', // Step function: flat until next value
                        tension: 0,
                        order: 1
                    }, {
                        label: 'Fed Funds Rate',
                        data: fedFundsValues,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.1,
                        order: 2
                    }, {
                        label: '2-Year Yield (Market)',
                        data: yield2YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.1,
                        order: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    
                                    if (label === '2-Year Yield (Market)') {
                                        return `2Y Yield: ${context.parsed.y.toFixed(2)}%`;
                                    } else if (label === 'Fed Funds Rate') {
                                        return `Fed Funds: ${context.parsed.y.toFixed(2)}%`;
                                    } else if (label === 'Fed Median Projection') {
                                        return `Fed Median: ${context.parsed.y.toFixed(2)}%`;
                                    }
                                    return label + ': ' + context.parsed.y.toFixed(2) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { 
                                    if (value === null || value === undefined) return '';
                                    return value.toFixed(2) + '%'; 
                                }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    },
                    elements: {
                        line: {
                            spanGaps: false // Don't connect lines across null values
                        }
                    }
                }
            });
        }
        
        // Load and display interest rates data
        async function loadInterestRatesData() {
            const loadingEl = document.getElementById('interestLoading');
            const contentEl = document.getElementById('interestContent');
            
            try {
                loadingEl.classList.remove('hidden');
                contentEl.classList.add('hidden');
                loadingEl.innerHTML = `
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading interest rate data from BLS & FRED...</p>
                `;
                
                console.log('Starting to fetch interest rates data from BLS & FRED...');
                
                // Fetch BLS CPI data
                let cpiData = [];
                let cpiCoreData = [];
                try {
                    const blsCpiSeries = ['CUUR0000SA0', 'CUUR0000SA0L1E'];
                    const blsCpiData = await fetchBLSData(blsCpiSeries);
                    cpiData = blsCpiData['CUUR0000SA0'] || [];
                    cpiCoreData = blsCpiData['CUUR0000SA0L1E'] || [];
                    
                    if (cpiData.length === 0 || cpiCoreData.length === 0) {
                        throw new Error('BLS data empty');
                    }
                } catch (blsError) {
                    // Fallback to FRED
                    const [fredCpiData, fredCpiCoreData] = await Promise.all([
                        fetchFREDData('CPIAUCSL'),
                        fetchFREDData('CPILFESL')
                    ]);
                    cpiData = fredCpiData || [];
                    cpiCoreData = fredCpiCoreData || [];
                }
                
                // Fetch PCE data first with retry logic (BEA data via FRED)
                console.log('Fetching PCE data from FRED (BEA source)...');
                let pceOverallData = [];
                let pceCoreData = [];
                
                // Group 0: PCE Data - Fetch in parallel but controlled by the queue
                const pceGroup = await Promise.all([
                    fetchFREDData('PCEPI'),
                    fetchFREDData('PCEPILFE'),
                    fetchFREDData('PCETRIM12M159SFRBDAL')
                ]);
                
                const [pceOverallResult, pceCoreResult, dallasTrimmedResult] = pceGroup;
                
                pceOverallData = pceOverallResult || [];
                pceCoreData = pceCoreResult || [];
                const dallasTrimmedData = dallasTrimmedResult || [];
                
                // Store raw inflation data
                rawPceOverallData = pceOverallData;
                rawPceCoreData = pceCoreData;
                rawDallasTrimmedData = dallasTrimmedData;
                
                // Log Dallas Trimmed Mean data status
                if (dallasTrimmedData.length === 0) {
                    console.warn('Dallas Trimmed Mean PCE data not available from FRED. Note: This data is not available through FRED API - it must be sourced directly from the Dallas Fed website.');
                } else {
                    console.log(`Dallas Trimmed Mean PCE: ${dallasTrimmedData.length} data points fetched`);
                }
                
                // Fetch all other data in batches to avoid browser throttling
                console.log('Fetching interest rate components in batches...');
                
                // Group 1: Term Premiums and Yields (Most critical)
                const group1 = await Promise.all([
                    fetchFREDData('THREEFYTP2'),
                    fetchFREDData('THREEFYTP10'),
                    fetchFREDData('THREEFFTP5'),
                    fetchFREDData('THREEFFTP10'),
                    fetchFREDData('DGS10'),
                    fetchFREDData('DGS2'),
                    fetchFREDData('TENEXPCHAINFRISPRE'),
                    fetchFREDData('EXPINF10YR')
                ]);
                
                // Group 2: Inflation and Real Yields
                const group2 = await Promise.all([
                    fetchFREDData('T10YIE'),
                    fetchFREDData('T5YIFR'),
                    fetchFREDData('DFII10'),
                    fetchFREDData('FEDFUNDS'),
                    fetchFREDData('FEDTARMD')
                ]);
                
                // Group 3: CPI Components (Many series, fetch last)
                const group3 = await Promise.all([
                    fetchFREDData('CPIHOSNS'),
                    fetchFREDData('CPIUFNS'),
                    fetchFREDData('CPIENGSL'),
                    fetchFREDData('CPITRNSL'),
                    fetchFREDData('CPIMEDSL'),
                    fetchFREDData('CPIEDUSL'),
                    fetchFREDData('CPIAPPSL'),
                    fetchFREDData('CPIRECSL'),
                    fetchFREDData('CPIOGSL')
                ]);

                const [termPremium2YData, termPremium10YData, forwardPremium5YData, forwardPremium10YData, yield10YData, yield2YData, irpData, expInf10YrData] = group1;
                const [inflation10YData, inflation5Y5YData, realYield10YData, fedFundsData, dotPlotMedianData] = group2;
                const [cpiShelterData, cpiFoodData, cpiEnergyData, cpiTransportData, cpiMedicalData, cpiEducationData, cpiApparelData, cpiRecreationData, cpiOtherData] = group3;
                
                console.log('Interest rates data fetched:', {
                    termPremium2Y: termPremium2YData.length,
                    termPremium10Y: termPremium10YData.length,
                    forwardPremium5Y: forwardPremium5YData.length,
                    forwardPremium10Y: forwardPremium10YData.length,
                    yield10Y: yield10YData.length,
                    yield2Y: yield2YData.length,
                    irp: irpData?.length || 0,
                    expInf10Yr: expInf10YrData?.length || 0,
                    inflation10Y: inflation10YData.length,
                    inflation5Y5Y: inflation5Y5YData.length,
                    realYield10Y: realYield10YData.length,
                    fedFunds: fedFundsData.length,
                    dotPlotMedian: dotPlotMedianData.length,
                    pceOverall: pceOverallData.length,
                    pceCore: pceCoreData.length
                });

                // Store raw data for components
                rawYield2YData = yield2YData;
                rawFedFundsData = fedFundsData;
                rawDotPlotMedianData = dotPlotMedianData;
                rawCpiOverallData = cpiData;
                rawCpiCoreData = cpiCoreData;
                rawCpiShelterData = cpiShelterData;
                rawCpiFoodData = cpiFoodData;
                rawCpiEnergyData = cpiEnergyData;
                rawCpiTransportData = cpiTransportData;
                rawCpiMedicalData = cpiMedicalData;
                rawCpiEducationData = cpiEducationData;
                rawCpiApparelData = cpiApparelData;
                rawCpiRecreationData = cpiRecreationData;
                rawCpiOtherData = cpiOtherData;
                
                // Debug PCE data
                if (pceOverallData.length > 0) {
                    console.log('PCE Overall data sample:', {
                        first: pceOverallData[0],
                        last: pceOverallData[pceOverallData.length - 1],
                        total: pceOverallData.length
                    });
                } else {
                    console.warn('PCE Overall data is empty!');
                }
                
                if (pceCoreData.length > 0) {
                    console.log('PCE Core data sample:', {
                        first: pceCoreData[0],
                        last: pceCoreData[pceCoreData.length - 1],
                        total: pceCoreData.length
                    });
                } else {
                    console.warn('PCE Core data is empty!');
                }
                
                let hasData = false;
                
                // Process Term Premium
                if (termPremium2YData.length > 0 && termPremium10YData.length > 0) {
                    processTermPremium(termPremium2YData, termPremium10YData);
                    hasData = true;
                } else {
                    document.getElementById('termPremium2Y').textContent = 'No data available';
                    document.getElementById('termPremium10Y').textContent = 'No data available';
                }
                
                // Process Forward Term Premium
                if (forwardPremium5YData.length > 0 && forwardPremium10YData.length > 0) {
                    processForwardTermPremium(forwardPremium5YData, forwardPremium10YData);
                    hasData = true;
                } else {
                    document.getElementById('forwardPremium5Y').textContent = 'No data available';
                    document.getElementById('forwardPremium10Y').textContent = 'No data available';
                }
                
                // Process 10Y Term Premium vs Forward Term Premium Comparison
                if (termPremium10YData.length > 0 && forwardPremium10YData.length > 0) {
                    processTermPremiumComparison(termPremium10YData, forwardPremium10YData);
                    hasData = true;
                } else {
                    document.getElementById('termPremium10YCurrent').textContent = 'No data available';
                    document.getElementById('forwardPremium10YCurrent').textContent = 'No data available';
                    document.getElementById('termPremiumDiff').textContent = 'No data available';
                }
                
                // Store real yield full data for zoom functionality
                if (realYield10YData && realYield10YData.length > 0) {
                    realYieldFullData = realYield10YData;
                }
                
                // Process Yield Decomposition
                if (yield10YData?.length > 0 && realYield10YData?.length > 0 && termPremium10YData?.length > 0) {
                    processYieldDecomposition(yield10YData, realYield10YData, termPremium10YData);
                    hasData = true;
                } else {
                    const set = (id, t) => { const el = document.getElementById(id); if (el) el.textContent = t || 'No data available'; };
                    set('yield10YTotal'); set('yieldRealRate'); set('yieldInflation'); set('yieldTermPremium');
                }
                
                // Process Market vs Model Rate Comparison (new card)
                if (yield10YData?.length > 0 && realYield10YData?.length > 0 && termPremium10YData?.length > 0) {
                    processMarketVsModelComparison(yield10YData, realYield10YData, termPremium10YData, inflation10YData, inflation5Y5YData);
                }
                
                // Process FOMC Dot Plot vs 2Y Yield
                if (yield2YData.length > 0) {
                    // Allow processing even if dot plot data is empty or sparse (quarterly data)
                    processDotPlotComparison(yield2YData, fedFundsData || [], dotPlotMedianData || []);
                    hasData = true;
                } else {
                    document.getElementById('dotPlot2Y').textContent = 'No data available';
                }
                
                // Process Inflation Expectations
                if (inflation10YData.length > 0 && inflation5Y5YData.length > 0) {
                    processInflationExpectations(inflation10YData, inflation5Y5YData, cpiData || []);
                    hasData = true;
                } else {
                    document.getElementById('inflation10Y').textContent = 'No data available';
                    document.getElementById('inflation5Y5Y').textContent = 'No data available';
                }
                
                // Process Real Yields (with nominal yields for breakeven inflation visualization)
                if (realYield10YData.length > 0) {
                    processRealYields(realYield10YData, yield10YData);
                    hasData = true;
                } else {
                    document.getElementById('realYield10Y').textContent = 'No data available';
                }
                
                // Process Inflation (CPI & PCE)
                console.log('Inflation data check:', {
                    cpiData: cpiData?.length || 0,
                    cpiCoreData: cpiCoreData?.length || 0,
                    pceOverallData: pceOverallData?.length || 0,
                    pceCoreData: pceCoreData?.length || 0
                });
                
                if (cpiData.length > 0 || cpiCoreData.length > 0 || pceOverallData.length > 0 || pceCoreData.length > 0) {
                    try {
                        processInflationCpiPce(cpiData || [], cpiCoreData || [], pceOverallData || [], pceCoreData || [], 
                            cpiShelterData || [], cpiFoodData || [], cpiEnergyData || [], cpiTransportData || [], 
                            cpiMedicalData || [], cpiEducationData || [], cpiApparelData || [], cpiRecreationData || [], cpiOtherData || [],
                            dallasTrimmedData || []);
                        hasData = true;
                    } catch (error) {
                        console.error('Error processing inflation data:', error);
                        // Still try to show what data we have
                        if (pceOverallData.length > 0 || pceCoreData.length > 0) {
                            console.log('PCE data available but processing failed, attempting manual update...');
                            const latestPceOverall = pceOverallData.length > 0 ? pceOverallData[pceOverallData.length - 1] : null;
                            const latestPceCore = pceCoreData.length > 0 ? pceCoreData[pceCoreData.length - 1] : null;
                            // This is a fallback - the processInflationCpiPce function should handle this, but if it fails, we at least log it
                        }
                    }
                } else {
                    console.warn('No inflation data available (CPI or PCE)');
                    // Set placeholders
                    document.getElementById('pceOverall').textContent = 'No data';
                    document.getElementById('pceCore').textContent = 'No data';
                }
                
                
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                window.interestDataLoaded = true;
                
                if (!hasData) {
                    loadingEl.classList.remove('hidden');
                    contentEl.classList.add('hidden');
                    loadingEl.innerHTML = `
                        <div class="text-center">
                            <i class="fas fa-exclamation-circle text-red-400 text-4xl mb-4"></i>
                            <p class="text-red-400 text-lg font-semibold mb-2">Unable to load interest rate data</p>
                            <p class="text-gray-400 text-sm mb-4">Please check the browser console for details.</p>
                            <button onclick="loadInterestRatesData()" class="mt-4 px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold">
                                <i class="fas fa-redo mr-2"></i>Retry
                            </button>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Error loading interest rates data:', error);
                loadingEl.innerHTML = `
                    <p class="text-red-400 text-lg font-semibold mb-2">Error loading interest rate data</p>
                    <p class="text-gray-400 text-sm mb-4">${error.message}</p>
                    <button onclick="loadInterestRatesData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Retry</button>
                `;
            }
        }
        
        // TAA chart instances
        let regimeQuadrantChartInstance = null;
        let regimeTimelineChartInstance = null;
        let growthInflationChartInstance = null;
        let stocksBondsCorrelationChartInstance = null;
        
        // Load and display TAA framework data
        async function loadTAAData() {
            const loadingEl = document.getElementById('taaLoading');
            const contentEl = document.getElementById('taaContent');
            
            try {
                loadingEl.classList.remove('hidden');
                contentEl.classList.add('hidden');
                loadingEl.innerHTML = `
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading TAA framework data from FRED...</p>
                `;
                
                console.log('Starting to fetch TAA data...');
                
                // Fetch Industrial Production, PMI, CFNAI, Core PCE, and asset class data
                // Use 60 years of data where available
                // Use Promise.allSettled to handle failures gracefully
                const sixtyYearsAgo = new Date();
                sixtyYearsAgo.setFullYear(sixtyYearsAgo.getFullYear() - 60);
                const startDate60Y = sixtyYearsAgo.toISOString().split('T')[0];
                
                const fetchResults = await Promise.allSettled([
                    fetchFREDData('INDPRO', startDate60Y), // Industrial Production Index (monthly)
                    fetchFREDData('NAPMNOI', startDate60Y), // ISM Manufacturing: New Orders Index (PMI proxy, monthly)
                    fetchFREDData('CFNAI', startDate60Y), // Chicago Fed National Activity Index (monthly, use 3-month MA)
                    fetchFREDData('PCEPILFE', startDate60Y), // Core PCE (Personal Consumption Expenditures Excluding Food and Energy) - Fed's preferred measure
                    fetchVTIData(TWELVE_DATA_API_KEY, '2000-01-01'), // VTI ETF (Total Stock Market) from Twelve Data
                    fetchAGGData(TWELVE_DATA_API_KEY, '2000-01-01'), // AGG ETF (Aggregate Bond) from Twelve Data
                    fetchFREDData('DCOILWTICO', startDate60Y), // Crude Oil Prices: West Texas Intermediate (WTI)
                    fetchFREDData('TB3MS', startDate60Y), // 3-Month Treasury Bill: Secondary Market Rate
                    fetchFREDData('SP500DIV').catch(() => []), // S&P 500 Dividends (optional - may not be available)
                    fetchFREDData('GS10', startDate60Y), // 10-Year Treasury Yield (for bond total return)
                    fetchFREDData('SP500', startDate60Y) // S&P 500 Index (for correlation calculation)
                ]);
                
                // Extract results, using empty array for failed requests
                const [ipData, pmiData, cfnaiData, corePceData, vtiData, aggData, commodityData, cashData, sp500DividendData, bondYieldData, sp500Data] = fetchResults.map(result => 
                    result.status === 'fulfilled' ? result.value : []
                );
                
                // Log if SP500DIV failed (non-critical)
                if (fetchResults[7].status === 'rejected') {
                    console.warn('SP500DIV (S&P 500 Dividends) not available - continuing without dividend data');
                }
                
                // IP is required (primary growth indicator, monthly frequency)
                if (!ipData || ipData.length === 0) {
                    throw new Error('No Industrial Production data available');
                }
                if (!corePceData || corePceData.length === 0) {
                    throw new Error('No Core PCE data available');
                }
                
                console.log(`Fetched ${ipData.length} IP points (monthly), ${pmiData.length} PMI points (monthly), ${cfnaiData.length} CFNAI points (monthly), and ${corePceData.length} Core PCE points (monthly)`);
                console.log(`Using composite growth: blend of IP (40%), PMI (30%), and CFNAI-MA3 (30%) - 60 years of data where available`);
                
                // Fetch additional inflation measures for composite
                const dallasTrimmedResult = await Promise.allSettled([
                    fetchFREDData('PCETRIM12M159SFRBDAL', startDate60Y) // Dallas Fed Trimmed Mean PCE (12-month YoY percent change) - use YoY for TAA model to match Core PCE YoY
                ]);
                
                const dallasTrimmedData = dallasTrimmedResult[0].status === 'fulfilled' ? dallasTrimmedResult[0].value : [];
                
                // Calculate YoY growth rates
                const ipGrowth = calculateYoYChange(ipData);
                const inflation = calculateYoYChange(corePceData);
                
                // Dallas Trimmed Mean PCE (PCETRIM12M159SFRBDAL) is already in YoY format (12-month percent change)
                // This is the correct series for TAA model since we're blending with YoY Core PCE
                // Do NOT calculate YoY change on it - use the values directly
                let dallasTrimmedInflation = [];
                if (dallasTrimmedData && dallasTrimmedData.length > 0) {
                    // PCETRIM12M159SFRBDAL is already in YoY percentage format
                    dallasTrimmedData.forEach(item => {
                        dallasTrimmedInflation.push({
                            date: item.date,
                            value: item.value
                        });
                    });
                    console.log(`Dallas Trimmed Mean: Using YoY series (PCETRIM12M159SFRBDAL), ${dallasTrimmedInflation.length} data points`);
                } else {
                    console.warn('Dallas Trimmed Mean YoY data not available for TAA model');
                }
                
                
                // PMI is a diffusion index (0-100, 50 = neutral), convert to growth-like metric
                // Convert current PMI level to growth equivalent (not YoY change)
                // PMI above 50 = expansion, below 50 = contraction
                // PMI of 50 = neutral growth (~2.5% trend), each point above/below 50 ≈ 0.1% growth deviation
                const pmiGrowth = [];
                if (pmiData && pmiData.length > 0) {
                    // Sort by date
                    const sortedPmi = [...pmiData].sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    // Convert PMI level to growth equivalent
                    const trendGrowth = 2.5; // Assume 2.5% trend growth
                    const pmiNeutral = 50; // PMI neutral level
                    const pmiToGrowthFactor = 0.1; // Each PMI point above/below 50 = 0.1% growth deviation
                    
                    for (let i = 0; i < sortedPmi.length; i++) {
                        const current = sortedPmi[i].value;
                        if (!isNaN(current)) {
                            // Convert PMI to absolute growth: trend + (PMI - 50) * factor
                            // PMI of 50 = 2.5% growth (trend)
                            // PMI of 60 = 2.5% + (60-50)*0.1 = 3.5% growth
                            // PMI of 40 = 2.5% + (40-50)*0.1 = 1.5% growth
                            const growthEquivalent = trendGrowth + (current - pmiNeutral) * pmiToGrowthFactor;
                            pmiGrowth.push({
                                date: sortedPmi[i].date,
                                value: growthEquivalent
                            });
                        }
                    }
                }
                
                // CFNAI: Calculate 3-month moving average (CFNAI-MA3) as per "Golden Rule"
                // CFNAI is a diffusion index where 0 = trend growth, positive = above trend, negative = below trend
                // Convert CFNAI-MA3 to absolute growth percentage: CFNAI of 0 = trend growth (~2.5%), +1.0 ≈ +3.5% above trend
                const cfnaiMA3 = [];
                if (cfnaiData && cfnaiData.length > 0) {
                    const sortedCfnai = [...cfnaiData].sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    // Assume trend growth rate (long-term average GDP growth)
                    const trendGrowth = 2.5; // 2.5% is typical long-term GDP growth for developed economies
                    
                    // Calculate 3-month moving average (starting from index 2 to have 3 months)
                    for (let i = 2; i < sortedCfnai.length; i++) {
                        const month1 = sortedCfnai[i - 2].value;
                        const month2 = sortedCfnai[i - 1].value;
                        const month3 = sortedCfnai[i].value;
                        
                        if (!isNaN(month1) && !isNaN(month2) && !isNaN(month3)) {
                            const ma3 = (month1 + month2 + month3) / 3;
                            // Convert CFNAI-MA3 to absolute growth percentage
                            // CFNAI of 0 = trend growth (2.5%)
                            // CFNAI of +1.0 = trend + 3.5% = 6.0% growth
                            // CFNAI of -1.0 = trend - 3.5% = -1.0% growth
                            // Formula: absolute growth = trend growth + (CFNAI * 3.5)
                            const growthEquivalent = trendGrowth + (ma3 * 3.5);
                            cfnaiMA3.push({
                                date: sortedCfnai[i].date,
                                value: growthEquivalent
                            });
                        }
                    }
                }
                
                // IP, PMI, CFNAI and inflation are all monthly
                // Create a map of monthly IP growth
                const ipGrowthByMonth = new Map();
                ipGrowth.forEach(item => {
                    const date = new Date(item.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    ipGrowthByMonth.set(monthKey, item.value);
                });
                
                // Create a map of monthly PMI growth
                const pmiGrowthByMonth = new Map();
                pmiGrowth.forEach(item => {
                    const date = new Date(item.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    pmiGrowthByMonth.set(monthKey, item.value);
                });
                
                // Create a map of monthly CFNAI-MA3 growth
                const cfnaiGrowthByMonth = new Map();
                cfnaiMA3.forEach(item => {
                    const date = new Date(item.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    cfnaiGrowthByMonth.set(monthKey, item.value);
                });
                
                // Create maps for inflation components
                const dallasTrimmedByMonth = new Map();
                dallasTrimmedInflation.forEach(item => {
                    const date = new Date(item.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    dallasTrimmedByMonth.set(monthKey, item.value);
                });
                
                // Align monthly inflation with blended growth (IP + PMI + CFNAI-MA3)
                // Create composite inflation: blend Core PCE (50%), Dallas Trimmed Mean (50%)
                // Blend: 40% IP, 30% PMI, 30% CFNAI-MA3 for growth
                const alignedData = [];
                inflation.forEach(item => {
                    const date = new Date(item.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    // Get growth components
                    const ipGrowthValue = ipGrowthByMonth.has(monthKey) ? ipGrowthByMonth.get(monthKey) : null;
                    const pmiGrowthValue = pmiGrowthByMonth.has(monthKey) ? pmiGrowthByMonth.get(monthKey) : null;
                    const cfnaiGrowthValue = cfnaiGrowthByMonth.has(monthKey) ? cfnaiGrowthByMonth.get(monthKey) : null;
                    
                    // Get inflation components
                    const corePceValue = item.value;
                    const dallasTrimmedValue = dallasTrimmedByMonth.has(monthKey) ? dallasTrimmedByMonth.get(monthKey) : null;
                    
                    if (ipGrowthValue !== null) {
                        // Calculate composite growth: blend IP (40%), PMI (30%), CFNAI-MA3 (30%)
                        // All components should now be in absolute growth percentage terms
                        let compositeGrowth = ipGrowthValue * 0.4; // IP base (already in YoY %)
                        let growthWeightSum = 0.4; // Start with IP weight
                        
                        if (pmiGrowthValue !== null) {
                            // PMI growth is already converted to growth equivalent
                            compositeGrowth += pmiGrowthValue * 0.3;
                            growthWeightSum += 0.3;
                        }
                        
                        if (cfnaiGrowthValue !== null) {
                            // CFNAI growth is now in absolute growth terms (trend + deviation)
                            compositeGrowth += cfnaiGrowthValue * 0.3;
                            growthWeightSum += 0.3;
                        }
                        
                        // Normalize if weights don't sum to 1.0
                        if (growthWeightSum > 0) {
                            compositeGrowth = compositeGrowth / growthWeightSum;
                        }
                        
                        // Additional normalization: ensure composite is in reasonable growth range (0-8%)
                        // This helps align with expected GDP-like growth numbers
                        // If composite is way outside normal range, apply gentle normalization
                        // Most economic growth should be between -2% and 8%
                        if (compositeGrowth > 8) {
                            // Cap extreme high values (likely from scaling issues)
                            compositeGrowth = 8 + (compositeGrowth - 8) * 0.3; // Soft cap
                        } else if (compositeGrowth < -2) {
                            // Cap extreme low values
                            compositeGrowth = -2 + (compositeGrowth + 2) * 0.3; // Soft cap
                        }
                        
                        // Calculate composite inflation: Core PCE (50%), Dallas Trimmed Mean (50%)
                        // Validate that corePceValue is reasonable (between -5% and 20%)
                        if (corePceValue > 50 || corePceValue < -10) {
                            console.warn(`Core PCE value seems incorrect: ${corePceValue}% at ${item.date} - skipping this data point`);
                            return; // Skip this data point if Core PCE is clearly wrong
                        }
                        
                        let compositeInflation = corePceValue * 0.5; // Core PCE base
                        let inflationWeightSum = 0.5;
                        
                        if (dallasTrimmedValue !== null && !isNaN(dallasTrimmedValue)) {
                            // Validate Dallas Trimmed Mean value is reasonable
                            if (dallasTrimmedValue > 50 || dallasTrimmedValue < -10) {
                                console.warn(`Dallas Trimmed Mean value seems incorrect: ${dallasTrimmedValue}% at ${item.date} - skipping this component`);
                            } else {
                                compositeInflation += dallasTrimmedValue * 0.5;
                                inflationWeightSum += 0.5;
                            }
                        }
                        
                        // Normalize if weights don't sum to 1.0
                        if (inflationWeightSum > 0) {
                            compositeInflation = compositeInflation / inflationWeightSum;
                        }
                        
                        // Final validation: ensure composite inflation is in reasonable range
                        // If somehow it's still way off, cap it
                        if (compositeInflation > 20 || compositeInflation < -5) {
                            console.error(`Composite inflation out of reasonable range: ${compositeInflation}% at ${item.date} - capping to reasonable range`);
                            if (compositeInflation > 20) {
                                compositeInflation = 20; // Cap at 20%
                            } else if (compositeInflation < -5) {
                                compositeInflation = -5; // Cap at -5%
                            }
                        }
                        
                        alignedData.push({
                            date: item.date,
                            ipGrowth: ipGrowthValue,
                            pmiGrowth: pmiGrowthValue,
                            cfnaiGrowth: cfnaiGrowthValue,
                            growth: compositeGrowth, // Composite growth: IP + PMI + CFNAI-MA3 blend
                            inflation: compositeInflation, // Composite inflation: Core PCE + Dallas Trimmed Mean
                            corePceInflation: corePceValue, // Keep original for reference
                            dallasTrimmedInflation: dallasTrimmedValue
                        });
                    }
                });
                
                // Calculate 3-month moving averages for regime classification
                // Also need to calculate z-scores based on 10-year rolling windows
                const regimeData = [];
                
                for (let i = 2; i < alignedData.length; i++) {
                    const avgGrowth = (alignedData[i-2].growth + alignedData[i-1].growth + alignedData[i].growth) / 3;
                    const avgInflation = (alignedData[i-2].inflation + alignedData[i-1].inflation + alignedData[i].inflation) / 3;
                    
                    // Calculate z-scores using 10-year rolling window (120 months)
                    const lookbackMonths = 120;
                    const startIdx = Math.max(0, i - lookbackMonths);
                    const windowData = alignedData.slice(startIdx, i + 1);
                    
                    // Calculate mean and std dev for growth and inflation over the window
                    const growthValues = windowData.map(d => d.growth);
                    const inflationValues = windowData.map(d => d.inflation);
                    
                    const growthMean = growthValues.reduce((a, b) => a + b, 0) / growthValues.length;
                    const inflationMean = inflationValues.reduce((a, b) => a + b, 0) / inflationValues.length;
                    
                    const growthVariance = growthValues.reduce((sum, val) => sum + Math.pow(val - growthMean, 2), 0) / growthValues.length;
                    const inflationVariance = inflationValues.reduce((sum, val) => sum + Math.pow(val - inflationMean, 2), 0) / inflationValues.length;
                    
                    const growthStdDev = Math.sqrt(growthVariance);
                    const inflationStdDev = Math.sqrt(inflationVariance);
                    
                    // Calculate z-scores
                    const growthZScore = growthStdDev > 0 ? (avgGrowth - growthMean) / growthStdDev : 0;
                    const inflationZScore = inflationStdDev > 0 ? (avgInflation - inflationMean) / inflationStdDev : 0;
                    
                    regimeData.push({
                        date: alignedData[i].date,
                        gdpGrowth: avgGrowth, // Keep for display
                        growth: avgGrowth, // Composite growth
                        inflation: avgInflation,
                        growthZScore: growthZScore,
                        inflationZScore: inflationZScore,
                        growthMean: growthMean,
                        inflationMean: inflationMean,
                        regime: classifyRegime(growthZScore, inflationZScore)
                    });
                }
                
                // Get current values
                const current = regimeData[regimeData.length - 1];
                const currentGrowth = current.growth || current.gdpGrowth; // Use composite growth if available
                const currentInflation = current.inflation;
                const currentRegime = current.regime;
                const currentGrowthZ = current.growthZScore || 0;
                const currentInflationZ = current.inflationZScore || 0;
                
                // Calculate regime duration
                let regimeDuration = 1;
                for (let i = regimeData.length - 2; i >= 0; i--) {
                    if (regimeData[i].regime === currentRegime) {
                        regimeDuration++;
                    } else {
                        break;
                    }
                }
                
                // Calculate enhanced regime metrics
                const regimeMetrics = calculateRegimeMetrics(regimeData, current, currentRegime, currentGrowthZ, currentInflationZ);
                
                // Update UI
                document.getElementById('currentRegime').textContent = currentRegime;
                document.getElementById('currentGrowth').textContent = currentGrowth.toFixed(2) + '%';
                document.getElementById('currentInflation').textContent = currentInflation.toFixed(2) + '%';
                document.getElementById('regimeDuration').textContent = regimeDuration + ' months';
                
                // Update enhanced metrics
                document.getElementById('regimeStrength').textContent = regimeMetrics.strength + '%';
                document.getElementById('regimeStrengthBarFill').style.width = regimeMetrics.strength + '%';
                const strengthColor = regimeMetrics.strength >= 70 ? 'bg-green-500' : regimeMetrics.strength >= 50 ? 'bg-yellow-500' : 'bg-red-500';
                document.getElementById('regimeStrengthBarFill').className = `h-full ${strengthColor} transition-all duration-500`;
                
                document.getElementById('expectedDuration').textContent = regimeMetrics.expectedDuration;
                document.getElementById('transitionRisk').textContent = regimeMetrics.transitionRisk;
                document.getElementById('nextRegime').textContent = regimeMetrics.nextRegime;
                document.getElementById('nextRegimeProb').textContent = regimeMetrics.nextRegimeProb;
                
                // Show transition info if staying is most likely
                const transitionEl = document.getElementById('nextRegimeTransition');
                if (regimeMetrics.stayProbability > regimeMetrics.mostLikelyTransitionProb) {
                    transitionEl.textContent = `Next transition: ${regimeMetrics.mostLikelyTransition} (${(regimeMetrics.mostLikelyTransitionProb * 100).toFixed(1)}%)`;
                    transitionEl.classList.remove('hidden');
                } else {
                    transitionEl.classList.add('hidden');
                }
                
                // Update regime color - use consistent -500 color variants to match chart colors
                const regimeColors = {
                    'Disinflationary Boom': 'text-green-500',
                    'Inflationary Boom': 'text-yellow-500',
                    'Disinflationary Bust': 'text-blue-500',
                    'Inflationary Bust': 'text-red-500',
                    'Neutral': 'text-gray-400'
                };
                const currentRegimeEl = document.getElementById('currentRegime');
                currentRegimeEl.className = 'text-2xl font-bold mb-2 ' + (regimeColors[currentRegime] || 'text-blue-400');
                
                // Calculate data-driven allocations
                const allocationResults = calculateDataDrivenAllocations(regimeData, vtiData, aggData, commodityData, cashData);
                window.optimizedAllocations = allocationResults.allocations;
                window.regimeAssetStats = allocationResults.stats;
                
                // Update transition matrix and forward allocation
                // Display raw probabilities with confidence intervals (not adjusted ones)
                displayTransitionMatrix(regimeMetrics.rawTransitionProbs || regimeMetrics.transitionProbs, currentRegime, regimeMetrics.confidenceIntervals, regimeMetrics.totalTransitions, regimeData);
                displayFullTransitionMatrix(regimeData, currentRegime);
                updateRecommendedAllocation(currentRegime, allocationResults.allocations, allocationResults.stats);
                updateForwardAllocation(currentRegime, regimeMetrics.transitionProbs, allocationResults.allocations);
                
                // Validate regime calibration and display stats
                const calibrationStats = validateRegimeCalibration(regimeData);
                displayRegimeCalibrationStats(calibrationStats);
                
                // Store regime data globally for chart updates
                window.regimeDataForChart = regimeData;
                window.alignedDataForChart = alignedData;
                
                // Create charts
                createRegimeQuadrantChart(regimeData);
                createRegimeTimelineChart(regimeData);
                createGrowthInflationChart(alignedData, regimeData);
                updateRegimeStatistics(regimeData);
                updateHistoricalRegimeStatistics(regimeData);
                
                // Add event listener for progression checkbox
                const progressionCheckbox = document.getElementById('showProgression');
                if (progressionCheckbox) {
                    progressionCheckbox.addEventListener('change', function() {
                        if (window.regimeDataForChart) {
                            createRegimeQuadrantChart(window.regimeDataForChart);
                        }
                    });
                }
                
                // Add event listener for actual values toggle
                const actualValuesCheckbox = document.getElementById('showActualValues');
                if (actualValuesCheckbox) {
                    actualValuesCheckbox.addEventListener('change', function() {
                        if (window.alignedDataForChart && window.regimeDataForChart) {
                            const zoom2Years = window.zoom2YearsActive || false;
                            createGrowthInflationChart(window.alignedDataForChart, window.regimeDataForChart, zoom2Years);
                        }
                    });
                }
                
                // Add event listener for 2-year zoom button
                const zoom2YearsButton = document.getElementById('zoom2Years');
                if (zoom2YearsButton) {
                    zoom2YearsButton.addEventListener('click', function() {
                        if (window.alignedDataForChart && window.regimeDataForChart) {
                            window.zoom2YearsActive = !window.zoom2YearsActive;
                            const isZoomed = window.zoom2YearsActive;
                            
                            // Update button text and icon
                            if (isZoomed) {
                                zoom2YearsButton.innerHTML = '<i class="fas fa-search-minus mr-1"></i>Show All Data';
                                zoom2YearsButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                                zoom2YearsButton.classList.add('bg-green-600', 'hover:bg-green-700');
                            } else {
                                zoom2YearsButton.innerHTML = '<i class="fas fa-search-plus mr-1"></i>Zoom to 2 Years';
                                zoom2YearsButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                                zoom2YearsButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
                            }
                            
                            createGrowthInflationChart(window.alignedDataForChart, window.regimeDataForChart, isZoomed);
                        }
                    });
                }
                
                // Calculate and display asset class performance by regime
                if (vtiData && aggData && commodityData && cashData) {
                    updateAssetClassPerformance(regimeData, vtiData, aggData, commodityData, cashData, sp500DividendData, bondYieldData);
                }
                
                // Calculate and display rolling correlation between stocks and bonds
                if (sp500Data && aggData) {
                    createStocksBondsCorrelationChart(sp500Data, aggData);
                }
                
                // Show content
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                window.taaDataLoaded = true;
                
            } catch (error) {
                console.error('Error loading TAA data:', error);
                loadingEl.innerHTML = `
                    <div class="text-center">
                        <i class="fas fa-exclamation-circle text-red-400 text-4xl mb-4"></i>
                        <p class="text-red-400 text-lg font-semibold mb-2">Error loading TAA data</p>
                        <p class="text-gray-400 text-sm mb-4">${error.message}</p>
                        <button onclick="loadTAAData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Retry</button>
                    </div>
                `;
            }
        }
        
        // --- DEBT & FISCAL DATA ---
        async function loadFiscalData() {
            const loadingEl = document.getElementById('fiscalLoading');
            const contentEl = document.getElementById('fiscalContent');
            
            try {
                loadingEl.classList.remove('hidden');
                contentEl.classList.add('hidden');
                loadingEl.innerHTML = `
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading fiscal data from FRED...</p>
                `;
                
                console.log('Starting to fetch fiscal data...');
                
                const twentyYearsAgo = new Date();
                twentyYearsAgo.setFullYear(twentyYearsAgo.getFullYear() - 20);
                const startDate = twentyYearsAgo.toISOString().split('T')[0];
                
                const fetchResults = await Promise.allSettled([
                    fetchFREDData('GFDEBTN', startDate), // Total Public Debt (Quarterly)
                    fetchFREDData('MVGFD027MNFRBDAL', startDate), // Market Value of Gross Federal Debt (Monthly - more current)
                    fetchFREDData('GFDEGDQ188S', startDate), // Debt as % of GDP (Quarterly)
                    fetchFREDData('FYFSD', startDate), // Federal Surplus or Deficit (Annual)
                    fetchFREDData('FYONGDA188S', startDate), // Deficit as % of GDP (Annual)
                    fetchFREDData('MTSO133FMS', startDate), // Total Outlays (Monthly MTS)
                    fetchFREDData('MTSR133FMS', startDate), // Total Receipts (Monthly MTS)
                    fetchFREDData('MTSDS133FMS', startDate), // Deficit/Surplus (Monthly MTS)
                    fetchFREDData('A091RC1Q027SBEA', startDate), // Federal Interest Payments (Quarterly)
                    fetchFREDData('W006RC1Q027SBEA', startDate), // Federal Current Tax Receipts (Quarterly)
                    fetchFREDData('FDHBFRBN', startDate), // Federal Debt held by Fed Banks (Quarterly, Billions)
                    fetchFREDData('WSHOTSL', startDate), // U.S. Treasury securities held outright by the Fed (Weekly, Millions)
                    fetchFREDData('DGS10', startDate), // 10-Year Treasury Yield (Daily - use DGS10 for current data)
                    fetchFREDData('GDP', startDate), // Nominal GDP (Quarterly)
                    fetchFREDData('FYFSGDA188S', startDate), // Federal Surplus/Deficit as % of GDP (Annual)
                    fetchFREDData('NETFI', startDate) // Net Foreign Investment (Quarterly)
                ]);
                
                const [debtTotal, debtMonthly, debtGdp, deficitTotal, deficitGdp, outlays, receipts, deficitMonthly, interest, taxReceipts, fedHeldDebt, fedHeldWeekly, treasury10Y, gdp, budgetBalanceGdp, netForeignInv] = fetchResults.map(r => 
                    r.status === 'fulfilled' ? r.value : []
                );
                
                console.log('Fiscal data fetched:', {
                    debtTotal: debtTotal.length,
                    debtMonthly: (debtMonthly || []).length,
                    outlays: outlays.length,
                    receipts: receipts.length,
                    deficitMonthly: deficitMonthly.length,
                    interest: interest.length,
                    taxReceipts: taxReceipts.length,
                    fedHeldDebt: fedHeldDebt.length,
                    fedHeldWeekly: fedHeldWeekly.length
                });
                
                if (debtTotal.length === 0 && outlays.length === 0) {
                    throw new Error('No fiscal data available');
                }
                
                processFiscalData(debtTotal, debtMonthly, debtGdp, deficitTotal, deficitGdp, outlays, receipts, deficitMonthly, interest, taxReceipts, fedHeldDebt, fedHeldWeekly, treasury10Y, gdp, budgetBalanceGdp, netForeignInv);
                
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                window.fiscalDataLoaded = true;
                
            } catch (error) {
                console.error('Error loading fiscal data:', error);
                loadingEl.innerHTML = `
                    <div class="text-center">
                        <i class="fas fa-exclamation-circle text-red-400 text-4xl mb-4"></i>
                        <p class="text-red-400 text-lg font-semibold mb-2">Error loading fiscal data</p>
                        <p class="text-gray-400 text-sm mb-4">${error.message}</p>
                        <button onclick="loadFiscalData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Retry</button>
                    </div>
                `;
            }
        }

        // --- WARSH v POWELL REGIME CHANGE DASHBOARD ---
        let warshProductivityChartInstance = null;
        let warshBalanceSheetChartInstance = null;
        let warshTermPremiumChartInstance = null;
        let warsh10YVIXChartInstance = null;
        let warshRealRateChartInstance = null;
        let warshM2ChartInstance = null;
        var warshTermPremZoom24 = true;
        var warsh10YVIXZoom24 = true;

        async function loadWarshPowellData() {
            const loadingEl = document.getElementById('warshLoading');
            const contentEl = document.getElementById('warshContent');

            try {
                loadingEl.classList.remove('hidden');
                contentEl.classList.add('hidden');
                loadingEl.innerHTML = `
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading Warsh Regime Change Dashboard from FRED...</p>
                `;

                console.log('Starting to fetch Warsh v Powell data...');

                const tenYearsAgo = new Date();
                tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
                const startDate = tenYearsAgo.toISOString().split('T')[0];

                const fetchResults = await Promise.allSettled([
                    fetchFREDData('OPHNFB', startDate),    // Non-farm Labor Productivity (quarterly)
                    fetchFREDData('CPILFESL', startDate),  // Core CPI (monthly)
                    fetchFREDData('WALCL', startDate),     // Fed Total Assets H.4.1 (weekly)
                    fetchFREDData('DGS10', startDate),     // 10-Year Treasury Yield (for new chart)
                    fetchFREDData('VIXCLS', startDate),    // Equity VIX (for new chart)
                    fetchFREDData('THREEFYTP10', startDate), // Kim-Wright 10Y Term Premium
                    fetchFREDData('KCPRU', startDate),    // Kansas City Financial Stress Index
                    fetchFREDData('FEDFUNDS', startDate), // Fed Funds Effective Rate
                    fetchFREDData('MICH', startDate),      // Michigan 1-Year Inflation Expectations
                    fetchFREDData('M2SL', startDate)       // M2 Money Supply
                ]);

                const [productivityData, coreCPIData, balanceSheetData, yield10YData, vixData, termPrem10YData, kcpruData, fedFundsData, michData, m2Data] = fetchResults.map(r =>
                    r.status === 'fulfilled' ? r.value : []
                );

                console.log('Warsh v Powell data fetched:', {
                    productivity: productivityData.length,
                    coreCPI: coreCPIData.length,
                    balanceSheet: balanceSheetData.length,
                    yield10Y: yield10YData.length,
                    vix: vixData.length,
                    termPrem10Y: termPrem10YData.length,
                    kcpru: kcpruData.length,
                    fedFunds: fedFundsData.length,
                    mich: michData.length,
                    m2: m2Data.length
                });

                if (productivityData.length === 0 && balanceSheetData.length === 0) {
                    throw new Error('No Warsh dashboard data available');
                }

                window.warshRawData = { productivityData, coreCPIData, balanceSheetData, yield10YData, vixData, termPrem10YData, kcpruData, fedFundsData, michData, m2Data };
                processWarshPowellData(productivityData, coreCPIData, balanceSheetData, yield10YData, vixData, termPrem10YData, kcpruData, fedFundsData, michData, m2Data);

                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                window.warshDataLoaded = true;
                setupWarshZoomButtons();

            } catch (error) {
                console.error('Error loading Warsh v Powell data:', error);
                loadingEl.innerHTML = `
                    <div class="text-center">
                        <i class="fas fa-exclamation-circle text-red-400 text-4xl mb-4"></i>
                        <p class="text-red-400 text-lg font-semibold mb-2">Error loading Warsh Regime Change Dashboard</p>
                        <p class="text-gray-400 text-sm mb-4">${error.message}</p>
                        <button onclick="loadWarshPowellData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Retry</button>
                    </div>
                `;
            }
        }

        const WARSH_ERA_DATE = '2026-05-15';
        const FOMC_MEETING_DATES = ['2016-01-27','2016-03-16','2016-04-27','2016-06-15','2016-07-27','2016-09-21','2016-11-02','2016-12-14','2017-02-01','2017-03-15','2017-05-03','2017-06-14','2017-07-26','2017-09-20','2017-11-01','2017-12-13','2018-01-31','2018-03-21','2018-05-02','2018-06-13','2018-08-01','2018-09-26','2018-11-08','2018-12-19','2019-01-30','2019-03-20','2019-05-01','2019-06-19','2019-07-31','2019-09-18','2019-10-30','2019-12-11','2020-01-29','2020-03-15','2020-04-29','2020-06-10','2020-07-29','2020-09-16','2020-11-05','2020-12-16','2021-01-27','2021-03-17','2021-04-28','2021-06-16','2021-07-28','2021-09-22','2021-11-03','2021-12-15','2022-01-26','2022-03-16','2022-05-04','2022-06-15','2022-07-27','2022-09-21','2022-11-02','2022-12-14','2023-01-31','2023-03-22','2023-05-03','2023-06-14','2023-07-26','2023-09-20','2023-11-01','2023-12-13','2024-01-31','2024-03-20','2024-05-01','2024-06-12','2024-07-31','2024-09-18','2024-11-07','2024-12-18','2025-01-29','2025-03-19','2025-05-07','2025-06-18','2025-07-30','2025-09-17','2025-11-05','2025-12-17','2026-01-28','2026-03-18','2026-05-06','2026-06-17','2026-07-29','2026-09-16','2026-11-04','2026-12-16'];

        function getWarshChartAnnotations(labels) {
            const annotations = {};
            const sortedLabels = [...labels].sort();
            function findLabelForDate(targetDate) {
                const idx = sortedLabels.findIndex(l => l >= targetDate);
                if (idx >= 0) return sortedLabels[idx];
                if (sortedLabels.length > 0 && targetDate <= sortedLabels[sortedLabels.length - 1]) return sortedLabels[sortedLabels.length - 1];
                return null;
            }
            const usedFomc = new Set();
            FOMC_MEETING_DATES.forEach((d, i) => {
                const label = findLabelForDate(d);
                if (label && !usedFomc.has(label)) {
                    usedFomc.add(label);
                    annotations['fomc_' + i] = { type: 'line', xMin: label, xMax: label, borderColor: 'rgba(156, 163, 175, 0.35)', borderWidth: 1, borderDash: [2, 2] };
                }
            });
            const warshLabel = findLabelForDate(WARSH_ERA_DATE);
            if (warshLabel) {
                annotations.warshEra = { type: 'line', xMin: warshLabel, xMax: warshLabel, borderColor: '#22c55e', borderWidth: 2, label: { display: true, content: 'Warsh era begins', position: 'start', backgroundColor: 'rgba(34, 197, 94, 0.8)', color: '#fff', font: { size: 9 } } };
            }
            return annotations;
        }

        function processWarshPowellData(productivityData, coreCPIData, balanceSheetData, yield10YData, vixData, termPrem10YData, kcpruData, fedFundsData, michData, m2Data) {
            // Helper: YoY % change
            function yoyChange(arr) {
                return arr.map((d, i) => {
                    if (i < 4) return null;
                    const prev = arr[i - 4];
                    return prev && prev !== 0 ? ((d / prev) - 1) * 100 : null;
                });
            }

            // 1. Productivity Spread: Productivity YoY vs Core CPI YoY
            const cpiYoY = coreCPIData.map((d, i) => {
                if (i < 12) return null;
                const prev = coreCPIData[i - 12];
                return prev && prev !== 0 ? ((d.value / prev.value) - 1) * 100 : null;
            });
            const prodYoY = productivityData.map((d, i) => {
                if (i < 4) return null;
                const prev = productivityData[i - 4];
                return prev && prev !== 0 ? ((d.value / prev.value) - 1) * 100 : null;
            });

            const prodDates = productivityData.map(d => d.date);
            const cpiDates = coreCPIData.map(d => d.date);
            const prodVals = productivityData.map(d => d.value);
            const cpiYoYVals = coreCPIData.map((d, i) => cpiYoY[i]);

            // Align productivity (quarterly) with CPI (monthly) - use quarterly CPI averages
            const prodMap = new Map();
            productivityData.forEach((d, i) => {
                prodMap.set(d.date, { prodYoY: prodYoY[i], prod: d.value });
            });
            const cpiByQuarter = new Map();
            coreCPIData.forEach((d, i) => {
                const q = d.date.substring(0, 7).replace('-', 'Q');
                const yr = d.date.substring(0, 4);
                const m = parseInt(d.date.substring(5, 7), 10);
                const qKey = yr + '-Q' + Math.ceil(m / 3);
                if (!cpiByQuarter.has(qKey)) cpiByQuarter.set(qKey, []);
                cpiByQuarter.get(qKey).push({ date: d.date, cpiYoY: cpiYoY[i], cpi: d.value });
            });
            const alignedDates = [];
            const alignedProdYoY = [];
            const alignedCpiYoY = [];
            prodMap.forEach((v, date) => {
                const yr = date.substring(0, 4);
                const m = parseInt(date.substring(5, 7), 10);
                const qKey = yr + '-Q' + Math.ceil(m / 3);
                const cpiArr = cpiByQuarter.get(qKey);
                if (cpiArr && cpiArr.length > 0) {
                    const avgCpiYoY = cpiArr.reduce((s, x) => s + (x.cpiYoY != null ? x.cpiYoY : 0), 0) / cpiArr.filter(x => x.cpiYoY != null).length;
                    alignedDates.push(date);
                    alignedProdYoY.push(v.prodYoY);
                    alignedCpiYoY.push(avgCpiYoY);
                }
            });

            if (productivityData.length > 0) {
                const lastProd = productivityData[productivityData.length - 1];
                document.getElementById('warshProductivityLatest').textContent = lastProd ? `${lastProd.value.toFixed(1)} (index)` : '--';
            }
            if (coreCPIData.length > 0) {
                const lastCpi = coreCPIData[coreCPIData.length - 1];
                const lastCpiYoY = cpiYoY[coreCPIData.length - 1];
                document.getElementById('warshCoreCPILatest').textContent = lastCpiYoY != null ? `${lastCpiYoY.toFixed(1)}%` : '--';
            }

            if (warshProductivityChartInstance) warshProductivityChartInstance.destroy();
            const ctxProd = document.getElementById('warshProductivityChart');
            if (ctxProd && alignedDates.length > 0) {
                warshProductivityChartInstance = new Chart(ctxProd, {
                    type: 'line',
                    data: {
                        labels: alignedDates,
                        datasets: [{
                            label: 'Productivity YoY %',
                            data: alignedProdYoY,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }, {
                            label: 'Core CPI YoY %',
                            data: alignedCpiYoY,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: { legend: { labels: { color: '#9ca3af' } }, annotation: { annotations: getWarshChartAnnotations(alignedDates) } },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: {
                                ticks: { color: '#9ca3af', callback: v => v != null ? v.toFixed(1) + '%' : '' },
                                grid: { color: 'rgba(156, 163, 175, 0.1)' }
                            }
                        }
                    }
                });
            }

            // 2. Balance Sheet (WALCL)
            if (balanceSheetData.length > 0) {
                const last = balanceSheetData[balanceSheetData.length - 1];
                document.getElementById('warshBalanceSheetLatest').textContent = last ? `$${(last.value / 1000).toFixed(1)}T` : '--';
            }
            if (warshBalanceSheetChartInstance) warshBalanceSheetChartInstance.destroy();
            const ctxBS = document.getElementById('warshBalanceSheetChart');
            if (ctxBS && balanceSheetData.length > 0) {
                const bsLabels = balanceSheetData.map(d => d.date);
                const bsValues = balanceSheetData.map(d => d.value);
                const bsRoc3M = bsValues.map((v, i) => {
                    if (i < 13) return null;
                    const prev = bsValues[i - 13];
                    return prev && prev !== 0 ? ((v / prev) - 1) * 100 : null;
                });
                warshBalanceSheetChartInstance = new Chart(ctxBS, {
                    type: 'line',
                    data: {
                        labels: bsLabels,
                        datasets: [{
                            label: 'Fed Total Assets (Billions)',
                            data: bsValues,
                            borderColor: '#60a5fa',
                            backgroundColor: 'rgba(96, 165, 250, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            yAxisID: 'y',
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }, {
                            label: '3-Month Rate of Change (%)',
                            data: bsRoc3M,
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.05)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1',
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            segment: { borderColor: ctx => { const y = ctx.p1.parsed.y; if (y == null) return '#9ca3af'; return y >= 0 ? '#22c55e' : '#ef4444'; } }
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: { legend: { labels: { color: '#9ca3af' } }, annotation: { annotations: getWarshChartAnnotations(bsLabels) } },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: { type: 'linear', position: 'left', ticks: { color: '#9ca3af' }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y1: { type: 'linear', position: 'right', min: -15, max: 15, ticks: { color: '#9ca3af', callback: v => v != null ? v.toFixed(1) + '%' : '' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }

            // 3. Term Premium & Bond Volatility: Kim-Wright Term Prem + KCPRU
            if (termPrem10YData.length > 0) {
                const last = termPrem10YData[termPrem10YData.length - 1];
                document.getElementById('warshTermPremLatest').textContent = last ? `${last.value.toFixed(2)}%` : '--';
            }
            if (kcpruData.length > 0) {
                const last = kcpruData[kcpruData.length - 1];
                document.getElementById('warshKCPRULatest').textContent = last ? last.value.toFixed(2) : '--';
            }
            const tpMap = new Map((termPrem10YData || []).map(d => [d.date, d.value]));
            const kcpruMap = new Map((kcpruData || []).map(d => [d.date, d.value]));
            const tpDatesFull = [...new Set([...tpMap.keys(), ...kcpruMap.keys()])].sort();
            const tpCombinedFull = tpDatesFull.map(d => ({ date: d, tp: tpMap.has(d) ? tpMap.get(d) : null, kcpru: kcpruMap.has(d) ? kcpruMap.get(d) : null }));
            const tpCombined = warshTermPremZoom24 ? filterTo24Months(tpCombinedFull) : tpCombinedFull;
            const tpDates = tpCombined.map(d => d.date);
            const tpVals = tpCombined.map(d => d.tp);
            const kcpruVals = tpCombined.map(d => d.kcpru);

            if (warshTermPremiumChartInstance) warshTermPremiumChartInstance.destroy();
            const ctxTP = document.getElementById('warshTermPremiumChart');
            if (ctxTP && tpDates.length > 0) {
                warshTermPremiumChartInstance = new Chart(ctxTP, {
                    type: 'line',
                    data: {
                        labels: tpDates,
                        datasets: [{
                            label: 'Kim-Wright 10Y Term Premium %',
                            data: tpVals,
                            borderColor: '#60a5fa',
                            backgroundColor: 'rgba(96, 165, 250, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y',
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }, {
                            label: 'KCPRU (KC Financial Stress)',
                            data: kcpruVals,
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1',
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: { labels: { color: '#9ca3af' } },
                            annotation: { annotations: getWarshChartAnnotations(tpDates) }
                        },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: { type: 'linear', position: 'left', ticks: { color: '#9ca3af', callback: v => v != null ? v.toFixed(1) + '%' : '' }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y1: { type: 'linear', position: 'right', ticks: { color: '#9ca3af' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }

            // 3b. 10Y Yield & Equity VIX (new chart)
            if (yield10YData.length > 0) {
                const last = yield10YData[yield10YData.length - 1];
                document.getElementById('warsh10YLatest').textContent = last ? `${last.value.toFixed(2)}%` : '--';
            }
            if (vixData.length > 0) {
                const last = vixData[vixData.length - 1];
                document.getElementById('warshVIXLatest').textContent = last ? last.value.toFixed(1) : '--';
            }
            const yieldMap = new Map((yield10YData || []).map(d => [d.date, d.value]));
            const vixMap = new Map((vixData || []).map(d => [d.date, d.value]));
            const yvDatesFull = [...new Set([...yieldMap.keys(), ...vixMap.keys()])].sort();
            const yvCombinedFull = yvDatesFull.map(d => ({ date: d, yield: yieldMap.has(d) ? yieldMap.get(d) : null, vix: vixMap.has(d) ? vixMap.get(d) : null }));
            const yvCombined = warsh10YVIXZoom24 ? filterTo24Months(yvCombinedFull) : yvCombinedFull;
            const yvDates = yvCombined.map(d => d.date);
            const yieldVals = yvCombined.map(d => d.yield);
            const vixVals = yvCombined.map(d => d.vix);

            if (warsh10YVIXChartInstance) warsh10YVIXChartInstance.destroy();
            const ctxYV = document.getElementById('warsh10YVIXChart');
            if (ctxYV && yvDates.length > 0) {
                warsh10YVIXChartInstance = new Chart(ctxYV, {
                    type: 'line',
                    data: {
                        labels: yvDates,
                        datasets: [{
                            label: '10Y Treasury %',
                            data: yieldVals,
                            borderColor: '#60a5fa',
                            backgroundColor: 'rgba(96, 165, 250, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y',
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }, {
                            label: 'VIX (Equity Volatility)',
                            data: vixVals,
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1',
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: { labels: { color: '#9ca3af' } },
                            annotation: { annotations: getWarshChartAnnotations(yvDates) }
                        },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: { type: 'linear', position: 'left', ticks: { color: '#9ca3af', callback: v => v != null ? v.toFixed(1) + '%' : '' }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y1: { type: 'linear', position: 'right', max: 45, ticks: { color: '#9ca3af' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }

            // 4. Real Interest Rates: Fed Funds - 1Y Inflation Expectations (MICH) + Nominal Fed Funds
            const fedMap = new Map(fedFundsData.map(d => [d.date, d.value]));
            const michMap = new Map(michData.map(d => [d.date, d.value]));
            const realDates = [...new Set([...fedMap.keys(), ...michMap.keys()])].sort();
            const realRates = realDates.map(d => {
                const ff = fedMap.get(d);
                const inf = michMap.get(d);
                return (ff != null && inf != null) ? ff - inf : null;
            });
            const nominalFedFunds = realDates.map(d => fedMap.get(d) ?? null);
            const nominalNeutralLower = realDates.map(() => 2);
            const nominalNeutralUpper = realDates.map(() => 2.5);

            if (realDates.length > 0) {
                const lastIdx = realRates.length - 1;
                for (let i = lastIdx; i >= 0; i--) {
                    if (realRates[i] != null) {
                        document.getElementById('warshRealRateLatest').textContent = `${realRates[i].toFixed(2)}%`;
                        break;
                    }
                }
            }
            if (realDates.length > 0) {
                for (let i = realDates.length - 1; i >= 0; i--) {
                    const ff = nominalFedFunds[i];
                    if (ff != null) {
                        document.getElementById('warshNominalFedLatest').textContent = `${ff.toFixed(2)}%`;
                        break;
                    }
                }
            }

            if (warshRealRateChartInstance) warshRealRateChartInstance.destroy();
            const ctxRR = document.getElementById('warshRealRateChart');
            if (ctxRR && realDates.length > 0) {
                const zeroLine = realDates.map(() => 0);
                const realNeutralUpper = realDates.map(() => 0.5);
                warshRealRateChartInstance = new Chart(ctxRR, {
                    type: 'line',
                    data: {
                        labels: realDates,
                        datasets: [
                            {
                                label: 'Warsh: Real ~0 when productivity rising',
                                data: zeroLine,
                                borderColor: '#22c55e',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                borderDash: [6, 4],
                                fill: false,
                                yAxisID: 'y',
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                order: 0
                            },
                            {
                                label: 'Real neutral range (nom 2–2.5%, esp. if BS shrinking)',
                                data: realNeutralUpper,
                                borderColor: 'rgba(34, 197, 94, 0.6)',
                                backgroundColor: 'rgba(34, 197, 94, 0.15)',
                                borderWidth: 1,
                                borderDash: [4, 4],
                                fill: '-1',
                                yAxisID: 'y',
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                order: 1
                            },
                            {
                                label: 'Real Rate (Fed Funds - 1Y Inf Exp) %',
                                data: realRates,
                                borderColor: '#8b5cf6',
                                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                yAxisID: 'y',
                                pointRadius: 0,
                                pointHoverRadius: 4,
                                order: 2
                            },
                            {
                                label: 'Nominal Fed Funds %',
                                data: nominalFedFunds,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                yAxisID: 'y1',
                                pointRadius: 0,
                                pointHoverRadius: 4,
                                order: 3
                            },
                            {
                                label: 'Nominal neutral lower (2%)',
                                data: nominalNeutralLower,
                                borderColor: 'rgba(245, 158, 11, 0.4)',
                                backgroundColor: 'transparent',
                                borderWidth: 1,
                                borderDash: [4, 4],
                                fill: false,
                                yAxisID: 'y1',
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                order: 4
                            },
                            {
                                label: 'Warsh: Nominal neutral 2–2.5%',
                                data: nominalNeutralUpper,
                                borderColor: 'rgba(245, 158, 11, 0.5)',
                                backgroundColor: 'rgba(245, 158, 11, 0.08)',
                                borderWidth: 1,
                                borderDash: [4, 4],
                                fill: '-1',
                                yAxisID: 'y1',
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                order: 5
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: { legend: { labels: { color: '#9ca3af', font: { size: 9 } } }, annotation: { annotations: getWarshChartAnnotations(realDates) } },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: { type: 'linear', position: 'left', ticks: { color: '#9ca3af', callback: v => v != null ? v.toFixed(1) + '%' : '' }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y1: { type: 'linear', position: 'right', ticks: { color: '#9ca3af', callback: v => v != null ? v.toFixed(1) + '%' : '' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }

            // 5. M2 Money Supply
            if (m2Data.length > 0) {
                const last = m2Data[m2Data.length - 1];
                document.getElementById('warshM2Latest').textContent = last ? `$${last.value.toFixed(0)}B` : '--';
            }
            if (warshM2ChartInstance) warshM2ChartInstance.destroy();
            const ctxM2 = document.getElementById('warshM2Chart');
            if (ctxM2 && m2Data.length > 0) {
                const m2Labels = m2Data.map(d => d.date);
                const m2Values = m2Data.map(d => d.value);
                const m2Roc3M = m2Values.map((v, i) => {
                    if (i < 3) return null;
                    const prev = m2Values[i - 3];
                    return prev && prev !== 0 ? ((v / prev) - 1) * 100 : null;
                });
                warshM2ChartInstance = new Chart(ctxM2, {
                    type: 'line',
                    data: {
                        labels: m2Labels,
                        datasets: [{
                            label: 'M2 Money Supply (Billions)',
                            data: m2Values,
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            yAxisID: 'y',
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }, {
                            label: '3-Month Rate of Change (%)',
                            data: m2Roc3M,
                            borderColor: '#a855f7',
                            backgroundColor: 'rgba(168, 85, 247, 0.05)',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1',
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            segment: { borderColor: ctx => { const y = ctx.p1.parsed.y; if (y == null) return '#9ca3af'; return y >= 0 ? '#22c55e' : '#ef4444'; } }
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: { legend: { labels: { color: '#9ca3af' } }, annotation: { annotations: getWarshChartAnnotations(m2Labels) } },
                        scales: {
                            x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y: { type: 'linear', position: 'left', ticks: { color: '#9ca3af' }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                            y1: { type: 'linear', position: 'right', min: -5, max: 5, ticks: { color: '#9ca3af', callback: v => v != null ? v.toFixed(1) + '%' : '' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }
        }

        function setupWarshZoomButtons() {
            const zoomButtons = [
                { id: 'warshTermPremZoom24', get: () => warshTermPremZoom24, set: (v) => warshTermPremZoom24 = v },
                { id: 'warsh10YVIXZoom24', get: () => warsh10YVIXZoom24, set: (v) => warsh10YVIXZoom24 = v }
            ];
            zoomButtons.forEach(btnConfig => {
                const btn = document.getElementById(btnConfig.id);
                if (btn && window.warshRawData) {
                    btn.textContent = btnConfig.get() ? 'Show Full' : 'Zoom 2Y';
                    if (btnConfig.get()) {
                        btn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                        btn.classList.remove('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                    } else {
                        btn.classList.add('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                        btn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                    }
                    if (!btn.hasAttribute('data-listener-added')) {
                        btn.setAttribute('data-listener-added', 'true');
                        btn.addEventListener('click', function() {
                            const newState = !btnConfig.get();
                            btnConfig.set(newState);
                            this.textContent = newState ? 'Show Full' : 'Zoom 2Y';
                            if (newState) {
                                this.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                                this.classList.remove('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                            } else {
                                this.classList.add('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                                this.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                            }
                            const d = window.warshRawData;
                            if (d) processWarshPowellData(d.productivityData, d.coreCPIData, d.balanceSheetData, d.yield10YData, d.vixData, d.termPrem10YData, d.kcpruData, d.fedFundsData, d.michData, d.m2Data);
                        });
                    }
                }
            });
        }

        function processFiscalData(debtTotal, debtMonthly, debtGdp, deficitTotal, deficitGdp, outlays, receipts, deficitMonthly, interest, taxReceipts, fedHeldDebt, fedHeldWeekly, treasury10Y, gdp, budgetBalanceGdp, netForeignInv) {
            // Helper function to format date as mm-dd-yyyy
            function formatDateMMDDYYYY(dateStr) {
                const date = new Date(dateStr);
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const year = date.getFullYear();
                return `${month}-${day}-${year}`;
            }

            // Helper function to find latest non-null data point
            function findLatestDataPoint(dates, values) {
                for (let i = dates.length - 1; i >= 0; i--) {
                    if (values[i] !== null && values[i] !== undefined) {
                        return { date: dates[i], value: values[i] };
                    }
                }
                return null;
            }

            // --- DATA ALIGNMENT ---
            // Align debtTotal (quarterly) and debtMonthly (MVGFD, monthly) for debt trend - merge for most current data
            const debtMap = new Map();
            debtTotal.forEach(d => debtMap.set(d.date, { total: d.value, gdp: null }));
            debtGdp.forEach(d => {
                if (debtMap.has(d.date)) {
                    debtMap.get(d.date).gdp = d.value;
                } else {
                    debtMap.set(d.date, { total: null, gdp: d.value });
                }
            });
            // Add monthly debt (MVGFD, billions) - convert to millions for alignment with GFDEBTN
            (debtMonthly || []).forEach(d => {
                if (!debtMap.has(d.date)) {
                    debtMap.set(d.date, { total: d.value * 1000, gdp: null }); // MVGFD in billions -> millions
                }
            });
            const sortedDebtDates = Array.from(debtMap.keys()).sort();
            const alignedDebtTotal = sortedDebtDates.map(d => debtMap.get(d).total || null);
            // Carry forward Debt/GDP for monthly-only dates (use last known quarterly value)
            let lastGdp = null;
            const alignedDebtGdp = sortedDebtDates.map(d => {
                const gdp = debtMap.get(d).gdp;
                if (gdp !== null) lastGdp = gdp;
                return gdp !== null ? gdp : lastGdp;
            });

            // Align Outlays and Receipts (Monthly MTS)
            const spendingMap = new Map();
            outlays.forEach(d => {
                spendingMap.set(d.date, { outlays: d.value / 1000 }); // Billions
            });
            receipts.forEach(d => {
                if (spendingMap.has(d.date)) {
                    spendingMap.get(d.date).receipts = d.value / 1000;
                } else {
                    spendingMap.set(d.date, { receipts: d.value / 1000 });
                }
            });
            const sortedSpendingDates = Array.from(spendingMap.keys()).sort();
            const alignedOutlays = sortedSpendingDates.map(d => spendingMap.get(d).outlays || null);
            const alignedReceipts = sortedSpendingDates.map(d => spendingMap.get(d).receipts || null);

            // 1. Interest Squeeze alignment (Interest / Tax Receipts)
            const squeezeMap = new Map();
            interest.forEach(d => squeezeMap.set(d.date, { interest: d.value }));
            taxReceipts.forEach(d => {
                if (squeezeMap.has(d.date)) squeezeMap.get(d.date).tax = d.value;
                else squeezeMap.set(d.date, { tax: d.value });
            });
            const sortedSqueezeDates = Array.from(squeezeMap.keys()).sort();
            const interestSqueezeValues = sortedSqueezeDates.map(d => {
                const p = squeezeMap.get(d);
                return (p.interest && p.tax) ? (p.interest / p.tax) * 100 : null;
            });

            // 2. Stealth Monetization (Fed-held U.S. Treasuries / Total Public Debt)
            // Use weekly WSHOTSL (Treasury securities held outright) and carry-forward total debt
            const sortedMonetizationDates = [];
            const stealthMonetizationValues = [];
            if ((fedHeldWeekly || []).length > 0) {
                fedHeldWeekly.forEach(point => {
                    const pointDate = new Date(point.date);
                    // Find the latest total debt observation on or before this weekly date
                    let latestTotal = null;
                    for (let i = sortedDebtDates.length - 1; i >= 0; i--) {
                        const debtDate = new Date(sortedDebtDates[i]);
                        if (debtDate <= pointDate) {
                            latestTotal = alignedDebtTotal[i]; // Total public debt (millions)
                            break;
                        }
                    }
                    if (latestTotal !== null && latestTotal !== undefined && point.value !== null && point.value !== undefined) {
                        sortedMonetizationDates.push(point.date);
                        // Both series are in millions – ratio in %
                        stealthMonetizationValues.push((point.value / latestTotal) * 100);
                    }
                });
            }

            // 3. Sustainability Spread (r - g)
            const gdpGrowth = gdp.map((d, i) => {
                if (i < 4) return { date: d.date, value: null };
                const prev = gdp[i - 4];
                return { date: d.date, value: ((d.value / prev.value) - 1) * 100 };
            });
            const rMinusGMap = new Map();
            const sortedGdpGrowth = [...gdpGrowth].filter(d => d.value !== null).sort((a,b) => new Date(a.date) - new Date(b.date));
            
            treasury10Y.forEach(d => {
                // Find the latest GDP growth value on or before this date (carry-forward quarterly data to months)
                let latestG = null;
                for (let i = sortedGdpGrowth.length - 1; i >= 0; i--) {
                    if (new Date(sortedGdpGrowth[i].date) <= new Date(d.date)) {
                        latestG = sortedGdpGrowth[i].value;
                        break;
                    }
                }
                rMinusGMap.set(d.date, { r: d.value, g: latestG });
            });
            
            const sortedRMinusGDates = Array.from(rMinusGMap.keys()).sort();
            const rMinusGValues = sortedRMinusGDates.map(d => {
                const p = rMinusGMap.get(d);
                return (p.r !== null && p.g !== null) ? p.r - p.g : null;
            });

            // 4. Twin Deficits (Budget Balance + Current Account % of GDP)
            const twinMap = new Map();
            
            // budgetBalanceGdp is Annual, we need to carry it forward to quarterly dates
            const sortedBudgetBalance = [...budgetBalanceGdp].sort((a,b) => new Date(a.date) - new Date(b.date));
            
            // Convert NETFI (Billions) to % of GDP
            const gdpMap = new Map();
            gdp.forEach(d => gdpMap.set(d.date, d.value));
            
            netForeignInv.forEach(d => {
                const gdpVal = gdpMap.get(d.date);
                const valPercent = gdpVal ? (d.value / gdpVal) * 100 : null;
                
                // Find the latest Budget Balance value on or before this date (carry-forward annual to quarterly)
                let latestBudget = null;
                for (let i = sortedBudgetBalance.length - 1; i >= 0; i--) {
                    if (new Date(sortedBudgetBalance[i].date) <= new Date(d.date)) {
                        latestBudget = sortedBudgetBalance[i].value;
                        break;
                    }
                }
                
                twinMap.set(d.date, { trade: valPercent, budget: latestBudget });
            });
            
            const sortedTwinDates = Array.from(twinMap.keys()).sort();
            const alignedBudgetBalance = sortedTwinDates.map(d => twinMap.get(d).budget);
            const alignedCurrentAccount = sortedTwinDates.map(d => twinMap.get(d).trade);

            // Filter Spending Chart to last 10 years
            const tenYearsAgo = new Date();
            tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
            const tenYearsAgoStr = tenYearsAgo.toISOString().split('T')[0];
            
            const filteredSpendingDates = sortedSpendingDates.filter(d => d >= tenYearsAgoStr);
            const filteredOutlays = filteredSpendingDates.map(d => spendingMap.get(d).outlays || null);
            const filteredReceipts = filteredSpendingDates.map(d => spendingMap.get(d).receipts || null);

            // Apply 3-month smoothing (3-period moving average)
            const smoothOutlays = filteredOutlays.map((v, i, arr) => {
                if (v === null) return null;
                const window = arr.slice(Math.max(0, i - 2), i + 1).filter(val => val !== null);
                return window.length > 0 ? window.reduce((a, b) => a + b, 0) / window.length : null;
            });
            const smoothReceipts = filteredReceipts.map((v, i, arr) => {
                if (v === null) return null;
                const window = arr.slice(Math.max(0, i - 2), i + 1).filter(val => val !== null);
                return window.length > 0 ? window.reduce((a, b) => a + b, 0) / window.length : null;
            });

            // --- 1. Update Summary Cards ---
            // Use most recent debt: merged series (quarterly GFDEBTN + monthly MVGFD)
            const latestDebtPoint = sortedDebtDates.length > 0 ? findLatestDataPoint(sortedDebtDates, alignedDebtTotal) : null;
            if (latestDebtPoint) {
                const latestVal = latestDebtPoint.value;
                const latestDate = latestDebtPoint.date;
                const idx = sortedDebtDates.indexOf(latestDate);
                const prevIdx = idx >= 12 ? idx - 12 : (idx >= 4 ? idx - 4 : 0); // YoY: 12 months or 4 quarters
                const prevVal = alignedDebtTotal[prevIdx];
                const yoyChange = prevVal && prevVal > 0 ? ((latestVal / prevVal) - 1) * 100 : null;
                document.getElementById('totalDebtValue').textContent = '$' + (latestVal / 1000000).toFixed(2) + 'T';
                document.getElementById('totalDebtTrend').textContent = yoyChange !== null ? `${yoyChange >= 0 ? '+' : ''}${yoyChange.toFixed(1)}% YoY` : '--';
                document.getElementById('totalDebtTrend').className = `text-xs ${yoyChange !== null && yoyChange > 5 ? 'text-red-400' : 'text-gray-400'}`;
            }
            const latestDebtGdpPoint = sortedDebtDates.length > 0 ? findLatestDataPoint(sortedDebtDates, alignedDebtGdp) : null;
            if (latestDebtGdpPoint && latestDebtGdpPoint.value !== null) {
                const idx = sortedDebtDates.indexOf(latestDebtGdpPoint.date);
                const prevIdx = idx >= 4 ? idx - 4 : 0;
                const prevVal = alignedDebtGdp[prevIdx];
                const change = prevVal !== null ? latestDebtGdpPoint.value - prevVal : null;
                document.getElementById('debtGdpValue').textContent = latestDebtGdpPoint.value.toFixed(1) + '%';
                document.getElementById('debtGdpTrend').textContent = change !== null ? `${change >= 0 ? '+' : ''}${change.toFixed(1)}% pts YoY` : '--';
                document.getElementById('debtGdpTrend').className = `text-xs ${change !== null && change > 2 ? 'text-red-400' : 'text-gray-400'}`;
            }
            if (deficitMonthly.length > 0) {
                const latest = deficitMonthly[deficitMonthly.length - 1];
                const prev = deficitMonthly.length > 12 ? deficitMonthly[deficitMonthly.length - 13] : deficitMonthly[0];
                const change = latest.value - prev.value;
                document.getElementById('annualDeficitValue').textContent = (latest.value >= 0 ? '$' : '-$') + Math.abs(latest.value / 1000).toFixed(1) + 'B';
                document.getElementById('annualDeficitTrend').textContent = `${change >= 0 ? '+' : ''}${(change / 1000).toFixed(1)}B YoY`;
                document.getElementById('annualDeficitTrend').className = `text-xs ${latest.value < 0 ? 'text-red-400' : 'text-green-400'}`;
            }
            if (interest.length > 0) {
                const latest = interest[interest.length - 1];
                const prev = interest.length > 4 ? interest[interest.length - 5] : (interest.length > 1 ? interest[interest.length - 2] : interest[0]);
                const yoyChange = ((latest.value / prev.value) - 1) * 100;
                document.getElementById('interestPaymentsValue').textContent = '$' + (latest.value).toFixed(0) + 'B';
                document.getElementById('interestPaymentsTrend').textContent = `${yoyChange >= 0 ? '+' : ''}${yoyChange.toFixed(1)}% YoY`;
                document.getElementById('interestPaymentsTrend').className = `text-xs ${yoyChange > 10 ? 'text-red-400' : 'text-gray-400'}`;
            }

            if (taxReceipts.length > 0) {
                const latest = taxReceipts[taxReceipts.length - 1];
                const prev = taxReceipts.length > 4 ? taxReceipts[taxReceipts.length - 5] : (taxReceipts.length > 1 ? taxReceipts[taxReceipts.length - 2] : taxReceipts[0]);
                const yoyChange = ((latest.value / prev.value) - 1) * 100;
                document.getElementById('taxReceiptsValue').textContent = '$' + (latest.value).toFixed(0) + 'B';
                document.getElementById('taxReceiptsTrend').textContent = `${yoyChange >= 0 ? '+' : ''}${yoyChange.toFixed(1)}% YoY`;
                document.getElementById('taxReceiptsTrend').className = `text-xs ${yoyChange < 0 ? 'text-red-400' : 'text-gray-400'}`;
            }

            // Update Interest Squeeze Summary Card
            const validSqueeze = interestSqueezeValues.filter(v => v !== null);
            if (validSqueeze.length > 0) {
                const latestSqueeze = validSqueeze[validSqueeze.length - 1];
                document.getElementById('interestSqueezeValue').textContent = latestSqueeze.toFixed(1) + '%';
            }

            // --- 2. Create Charts ---
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: { 
                    legend: { labels: { color: '#9ca3af', font: { size: 10 } } },
                    tooltip: { enabled: true }
                },
                scales: {
                    x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                    y: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } }
                }
            };

            // Debt Trend
            const ctxDebt = document.getElementById('debtTrendChart');
            if (debtTrendChartInstance) debtTrendChartInstance.destroy();
            const debtGdpValues = alignedDebtGdp.filter(v => v !== null);
            const medianDebtGdp = debtGdpValues.length > 0 ? [...debtGdpValues].sort((a,b)=>a-b)[Math.floor(debtGdpValues.length*0.5)] : 0;
            debtTrendChartInstance = new Chart(ctxDebt, {
                type: 'line',
                data: {
                    labels: sortedDebtDates,
                    datasets: [{
                        label: 'Total Public Debt ($B)', data: alignedDebtTotal, borderColor: '#60a5fa', backgroundColor: 'rgba(96, 165, 250, 0.1)', borderWidth: 2, fill: true, pointRadius: 0, yAxisID: 'y'
                    }, {
                        label: 'Debt as % of GDP', data: alignedDebtGdp, borderColor: '#f87171', borderWidth: 2, fill: false, pointRadius: 0, yAxisID: 'y1'
                    }, {
                        label: 'Debt/GDP Median', data: new Array(sortedDebtDates.length).fill(medianDebtGdp), borderColor: 'rgba(156, 163, 175, 0.5)', borderWidth: 1, borderDash: [5, 5], fill: false, pointRadius: 0, yAxisID: 'y1'
                    }]
                },
                options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, ticks: { ...commonOptions.scales.y.ticks, callback: v => '$'+(v/1000000).toFixed(0)+'T' } }, y1: { position: 'right', ticks: { color: '#9ca3af', font: { size: 9 }, callback: v => v+'%' }, grid: { display: false } } } },
                plugins: [getRecessionShadingPlugin()]
            });
            // Display latest data point for debt trend chart
            const latestDebt = findLatestDataPoint(sortedDebtDates, alignedDebtTotal);
            if (latestDebt) {
                const latestDebtGdp = alignedDebtGdp[sortedDebtDates.indexOf(latestDebt.date)];
                document.getElementById('debtTrendChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestDebt.date)} - Total Debt: $${(latestDebt.value / 1000000).toFixed(2)}T, Debt/GDP: ${latestDebtGdp !== null ? latestDebtGdp.toFixed(1) + '%' : 'N/A'}`;
            }

            // Deficit Chart (12-Month Rolling Budget Balance from Monthly Treasury MTS)
            const ctxDeficit = document.getElementById('deficitChart');
            if (deficitChartInstance) deficitChartInstance.destroy();

            // Use monthly budget balance from MTSDS133FMS and compute 12-month rolling sum for a timely, smoother signal
            const recentDeficitMonthly = deficitMonthly.slice(-240); // up to ~20 years of monthly data

            // Build 12-month rolling series (skip first 11 months where a full window isn't available)
            const rollingLabels = [];
            const rollingValues = [];
            for (let i = 11; i < recentDeficitMonthly.length; i++) {
                const windowSlice = recentDeficitMonthly.slice(i - 11, i + 1);
                const sum = windowSlice.reduce((acc, d) => acc + (d.value ?? 0), 0);
                rollingLabels.push(recentDeficitMonthly[i].date);
                rollingValues.push(sum / 1000); // Billions
            }

            deficitChartInstance = new Chart(ctxDeficit, {
                type: 'bar',
                data: {
                    labels: rollingLabels,
                    datasets: [{
                        label: '12-Month Rolling Budget Balance ($B)', 
                        data: rollingValues,
                        backgroundColor: rollingValues.map(v => v >= 0 ? 'rgba(16, 185, 129, 0.6)' : 'rgba(239, 68, 68, 0.6)'),
                        borderColor: rollingValues.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderWidth: 1
                    }]
                },
                options: { 
                    ...commonOptions, 
                    plugins: { 
                        ...commonOptions.plugins, 
                        legend: { display: false } 
                    }, 
                    scales: { 
                        ...commonOptions.scales, 
                        y: { 
                            ...commonOptions.scales.y, 
                            ticks: { 
                                ...commonOptions.scales.y.ticks, 
                                callback: v => '$'+v.toFixed(0)+'B' 
                            } 
                        } 
                    } 
                }
            });

            // Display latest data point for deficit chart (latest 12-month rolling value)
            if (rollingLabels.length > 0) {
                const latestLabel = rollingLabels[rollingLabels.length - 1];
                const latestValue = rollingValues[rollingValues.length - 1];
                document.getElementById('deficitChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestLabel)} - 12-Month Rolling Deficit/Surplus: ${latestValue >= 0 ? '$' : '-$'}${Math.abs(latestValue).toFixed(1)}B`;
            }

            // Outlays vs Receipts (10 Year Lookback)
            const ctxSpending = document.getElementById('spendingChart');
            if (spendingChartInstance) spendingChartInstance.destroy();
            spendingChartInstance = new Chart(ctxSpending, {
                type: 'line',
                data: {
                    labels: filteredSpendingDates,
                    datasets: [{
                        label: 'Total Outlays ($B) - 3mo Trend', data: smoothOutlays, borderColor: '#ef4444', backgroundColor: 'rgba(239, 68, 68, 0.1)', fill: false, borderWidth: 2, pointRadius: 0, tension: 0.3
                    }, {
                        label: 'Total Receipts ($B) - 3mo Trend', data: smoothReceipts, borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', fill: false, borderWidth: 2, pointRadius: 0, tension: 0.3
                    }]
                },
                options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, ticks: { ...commonOptions.scales.y.ticks, callback: v => '$'+v.toFixed(0)+'B' } } } }
            });
            // Display latest data point for spending chart
            const latestSpending = findLatestDataPoint(filteredSpendingDates, smoothOutlays);
            if (latestSpending) {
                const latestReceipts = smoothReceipts[filteredSpendingDates.indexOf(latestSpending.date)];
                document.getElementById('spendingChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestSpending.date)} - Outlays: $${latestSpending.value.toFixed(1)}B, Receipts: $${latestReceipts !== null ? latestReceipts.toFixed(1) : 'N/A'}B`;
            }

            // Interest Cost (12-Month Rolling from Quarterly Interest, with Quartiles)
            const ctxInterest = document.getElementById('interestCostChart');
            if (interestCostChartInstance) interestCostChartInstance.destroy();

            // Build 12-month (4-quarter) rolling sum from quarterly interest payments
            const rollingInterestLabels = [];
            const rollingInterestValues = [];
            for (let i = 3; i < interest.length; i++) {
                const windowSlice = interest.slice(i - 3, i + 1);
                const sum = windowSlice.reduce((acc, d) => acc + (d.value ?? 0), 0);
                rollingInterestLabels.push(interest[i].date);
                rollingInterestValues.push(sum);
            }

            const interestValuesForStats = [...rollingInterestValues].sort((a,b)=>a-b);
            const q1Interest = interestValuesForStats[Math.floor(interestValuesForStats.length * 0.25)];
            const medianInterest = interestValuesForStats[Math.floor(interestValuesForStats.length * 0.5)];
            const q3Interest = interestValuesForStats[Math.floor(interestValuesForStats.length * 0.75)];
            
            interestCostChartInstance = new Chart(ctxInterest, {
                type: 'line',
                data: {
                    labels: rollingInterestLabels,
                    datasets: [{
                        label: '12-Month Rolling Interest Payments ($B)', data: rollingInterestValues, borderColor: '#f59e0b', backgroundColor: 'rgba(245, 158, 11, 0.1)', borderWidth: 2, fill: true, pointRadius: 0, zIndex: 10
                    }, {
                        label: 'Q3 (Top 25%)', data: new Array(rollingInterestLabels.length).fill(q3Interest), borderColor: 'rgba(239, 68, 68, 0.7)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Median', data: new Array(rollingInterestLabels.length).fill(medianInterest), borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1.5, borderDash: [2, 2], fill: false, pointRadius: 0
                    }, {
                        label: 'Q1 (Bottom 25%)', data: new Array(rollingInterestLabels.length).fill(q1Interest), borderColor: 'rgba(16, 185, 129, 0.7)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }]
                },
                options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, ticks: { ...commonOptions.scales.y.ticks, callback: v => '$'+v.toFixed(0)+'B' } } } },
                plugins: [getRecessionShadingPlugin()]
            });
            // Display latest data point for interest cost chart
            if (rollingInterestLabels.length > 0) {
                const latestLabel = rollingInterestLabels[rollingInterestLabels.length - 1];
                const latestValue = rollingInterestValues[rollingInterestValues.length - 1];
                document.getElementById('interestCostChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestLabel)} - 12-Month Rolling Interest Payments: $${latestValue.toFixed(0)}B`;
            }

            // Interest Squeeze (with Quartiles)
            const ctxSqueeze = document.getElementById('interestSqueezeChart');
            if (interestSqueezeChartInstance) interestSqueezeChartInstance.destroy();
            const squeezeValues = interestSqueezeValues.filter(v => v !== null).sort((a,b)=>a-b);
            const q1Squeeze = squeezeValues[Math.floor(squeezeValues.length * 0.25)];
            const medianSqueeze = squeezeValues[Math.floor(squeezeValues.length * 0.5)];
            const q3Squeeze = squeezeValues[Math.floor(squeezeValues.length * 0.75)];

            interestSqueezeChartInstance = new Chart(ctxSqueeze, {
                type: 'line',
                data: {
                    labels: sortedSqueezeDates,
                    datasets: [{
                        label: 'Interest as % of Tax Receipts', data: interestSqueezeValues, borderColor: '#ef4444', backgroundColor: 'rgba(239, 68, 68, 0.1)', borderWidth: 2, fill: true, pointRadius: 0, zIndex: 10
                    }, {
                        label: 'Q3', data: new Array(sortedSqueezeDates.length).fill(q3Squeeze), borderColor: 'rgba(239, 68, 68, 0.6)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Median', data: new Array(sortedSqueezeDates.length).fill(medianSqueeze), borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1.5, borderDash: [2, 2], fill: false, pointRadius: 0
                    }, {
                        label: 'Q1', data: new Array(sortedSqueezeDates.length).fill(q1Squeeze), borderColor: 'rgba(16, 185, 129, 0.6)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }]
                },
                options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(1)+'%' } } } }
            });
            // Display latest data point for interest squeeze chart
            const latestSqueeze = findLatestDataPoint(sortedSqueezeDates, interestSqueezeValues);
            if (latestSqueeze) {
                document.getElementById('interestSqueezeChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestSqueeze.date)} - Interest as % of Tax Receipts: ${latestSqueeze.value.toFixed(1)}%`;
            }

            // Stealth Monetization (with Quartiles)
            const ctxMonetization = document.getElementById('stealthMonetizationChart');
            if (stealthMonetizationChartInstance) stealthMonetizationChartInstance.destroy();
            const monetizationValues = stealthMonetizationValues.filter(v => v !== null).sort((a,b)=>a-b);
            const q1Monetization = monetizationValues[Math.floor(monetizationValues.length * 0.25)];
            const medianMonetization = monetizationValues[Math.floor(monetizationValues.length * 0.5)];
            const q3Monetization = monetizationValues[Math.floor(monetizationValues.length * 0.75)];

            stealthMonetizationChartInstance = new Chart(ctxMonetization, {
                type: 'line',
                data: {
                    labels: sortedMonetizationDates,
                    datasets: [{
                        label: 'Fed-Held Debt as % of Total', data: stealthMonetizationValues, borderColor: '#8b5cf6', backgroundColor: 'rgba(139, 92, 246, 0.1)', borderWidth: 2, fill: true, pointRadius: 0, zIndex: 10
                    }, {
                        label: 'Q3', data: new Array(sortedMonetizationDates.length).fill(q3Monetization), borderColor: 'rgba(239, 68, 68, 0.6)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Median', data: new Array(sortedMonetizationDates.length).fill(medianMonetization), borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1.5, borderDash: [2, 2], fill: false, pointRadius: 0
                    }, {
                        label: 'Q1', data: new Array(sortedMonetizationDates.length).fill(q1Monetization), borderColor: 'rgba(16, 185, 129, 0.6)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }]
                },
                options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(1)+'%' } } } }
            });
            // Display latest data point for stealth monetization chart
            const latestMonetization = findLatestDataPoint(sortedMonetizationDates, stealthMonetizationValues);
            if (latestMonetization) {
                document.getElementById('stealthMonetizationChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestMonetization.date)} - Fed-Held Debt as % of Total: ${latestMonetization.value.toFixed(1)}%`;
            }

            // Sustainability Spread (with Quartiles and Zero Line)
            const ctxSpread = document.getElementById('sustainabilitySpreadChart');
            if (sustainabilitySpreadChartInstance) sustainabilitySpreadChartInstance.destroy();
            const validRMinusG = rMinusGValues.filter(v => v !== null).sort((a,b)=>a-b);
            const q1Spread = validRMinusG[Math.floor(validRMinusG.length * 0.25)];
            const medianSpread = validRMinusG[Math.floor(validRMinusG.length * 0.5)];
            const q3Spread = validRMinusG[Math.floor(validRMinusG.length * 0.75)];

            sustainabilitySpreadChartInstance = new Chart(ctxSpread, {
                type: 'line',
                data: {
                    labels: sortedRMinusGDates,
                    datasets: [{
                        label: 'r - g Spread (%)', 
                        data: rMinusGValues, 
                        borderColor: '#f59e0b', 
                        backgroundColor: rMinusGValues.map(v => v > 0 ? 'rgba(239, 68, 68, 0.2)' : 'rgba(16, 185, 129, 0.1)'), 
                        borderWidth: 3, 
                        fill: true, 
                        pointRadius: 0,
                        zIndex: 20
                    }, {
                        label: 'Zero Line', data: new Array(sortedRMinusGDates.length).fill(0), borderColor: '#ffffff', borderWidth: 1, borderDash: [], fill: false, pointRadius: 0, zIndex: 15
                    }, {
                        label: 'Q3', data: new Array(sortedRMinusGDates.length).fill(q3Spread), borderColor: 'rgba(239, 68, 68, 0.6)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Median', data: new Array(sortedRMinusGDates.length).fill(medianSpread), borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1.5, borderDash: [2, 2], fill: false, pointRadius: 0
                    }, {
                        label: 'Q1', data: new Array(sortedRMinusGDates.length).fill(q1Spread), borderColor: 'rgba(16, 185, 129, 0.6)', borderWidth: 1.5, borderDash: [5, 5], fill: false, pointRadius: 0
                    }]
                },
                options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(1)+'%' } } } }
            });
            // Display latest data point for sustainability spread chart
            const latestSpread = findLatestDataPoint(sortedRMinusGDates, rMinusGValues);
            if (latestSpread) {
                document.getElementById('sustainabilitySpreadChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestSpread.date)} - r - g Spread: ${latestSpread.value >= 0 ? '+' : ''}${latestSpread.value.toFixed(2)}%`;
            }

            // Twin Deficits
            const ctxTwin = document.getElementById('twinDeficitsChart');
            if (twinDeficitsChartInstance) twinDeficitsChartInstance.destroy();
            twinDeficitsChartInstance = new Chart(ctxTwin, {
                type: 'line',
                data: {
                    labels: sortedTwinDates,
                    datasets: [{
                        label: 'Budget Balance (% GDP)', 
                        data: alignedBudgetBalance, 
                        borderColor: '#60a5fa', 
                        backgroundColor: 'rgba(96, 165, 250, 0.2)', 
                        fill: true, 
                        borderWidth: 2, 
                        pointRadius: 0,
                        spanGaps: true
                    }, {
                        label: 'Current Account (% GDP)', 
                        data: alignedCurrentAccount, 
                        borderColor: '#f87171', 
                        backgroundColor: 'rgba(248, 113, 113, 0.2)', 
                        fill: true, 
                        borderWidth: 2, 
                        pointRadius: 0,
                        spanGaps: true
                    }]
                },
                options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(1)+'%' } } } }
            });
            // Display latest data point for twin deficits chart
            const latestTwin = findLatestDataPoint(sortedTwinDates, alignedBudgetBalance);
            if (latestTwin) {
                const latestCurrentAccount = alignedCurrentAccount[sortedTwinDates.indexOf(latestTwin.date)];
                document.getElementById('twinDeficitsChartLatest').textContent = 
                    `Latest: ${formatDateMMDDYYYY(latestTwin.date)} - Budget Balance: ${latestTwin.value !== null ? latestTwin.value.toFixed(1) + '%' : 'N/A'}, Current Account: ${latestCurrentAccount !== null ? latestCurrentAccount.toFixed(1) + '%' : 'N/A'}`;
            }
        }

        // --- END DEBT & FISCAL DATA ---

        // --- EMPLOYMENT & LABOR DATA ---
        async function loadEmploymentData() {
            const loadingEl = document.getElementById('employmentLoading');
            const contentEl = document.getElementById('employmentContent');
            
            try {
                loadingEl.classList.remove('hidden');
                contentEl.classList.add('hidden');
                
                const twentyYearsAgo = new Date();
                twentyYearsAgo.setFullYear(twentyYearsAgo.getFullYear() - 20);
                const startDate = twentyYearsAgo.toISOString().split('T')[0];
                
                const fetchResults = await Promise.allSettled([
                    fetchFREDData('JTSJOL', startDate), // Job Openings: Total Nonfarm
                    fetchFREDData('UNEMPLOY', startDate), // Unemployment Level
                    fetchFREDData('JTSJOR', startDate), // Job Openings Rate
                    fetchFREDData('UNRATE', startDate), // Unemployment Rate
                    fetchFREDData('PAYEMS', startDate), // Nonfarm Payroll Employment (Level)
                    fetchFREDData('CE16OV', startDate), // Employment Level (Household Survey)
                    fetchFREDData('CES0500000003', startDate), // Avg Hourly Earnings
                    fetchFREDData('CPIAUCSL', startDate), // CPI
                    fetchFREDData('JTSQUR', startDate), // Quits Rate
                    fetchFREDData('ECIWAG', startDate), // Employment Cost Index: Wages
                    fetchFREDData('U6RATE', startDate), // Underemployment Rate (U-6)
                    fetchFREDData('CIVPART', startDate), // Participation Rate
                    // Sectoral Employment (All Employees)
                    fetchFREDData('USFIRE', startDate), // Financial Activities
                    fetchFREDData('USGOVT', startDate), // Government
                    fetchFREDData('USPRIV', startDate), // Private Industries
                    fetchFREDData('CES6561000001', startDate), // Educational Services
                    fetchFREDData('CES6562000001', startDate), // Health Care and Social Assistance
                    fetchFREDData('MANEMP', startDate), // Manufacturing
                    fetchFREDData('USLAH', startDate), // Leisure and Hospitality
                    fetchFREDData('USINFO', startDate), // Information (Tech)
                    fetchFREDData('USPBS', startDate),  // Professional and Business Services
                    fetchFREDData('ICSA', startDate),   // Initial Claims
                    fetchFREDData('CCSA', startDate),   // Continuing Claims
                    fetchFREDData('OPHNFB', startDate)  // Labor Productivity (Output per Hour, Nonfarm Business)
                ]);
                
                const [
                    openings, unemployed, openingsRate, unrate, 
                    payrolls, employedLevel,
                    earnings, cpi, quits, eciWages, u6rate, participation,
                    finEmployment, gvtEmployment, privEmployment, eduEmployment, healthEmployment,
                    manEmployment, leisureEmployment, infoEmployment, profEmployment,
                    claims, contClaims, productivity
                ] = fetchResults.map(r => r.status === 'fulfilled' ? r.value : []);
                
                // Cache data for toggle use
                window.lastEmploymentData = { 
                    openings, unemployed, openingsRate, unrate, 
                    payrolls, employedLevel,
                    earnings, cpi, quits, eciWages, u6rate, participation,
                    finEmployment, gvtEmployment, eduEmployment, healthEmployment,
                    manEmployment, leisureEmployment, infoEmployment, profEmployment,
                    claims, contClaims, productivity
                };

                processEmploymentData(
                    openings, unemployed, openingsRate, unrate, 
                    payrolls, employedLevel,
                    earnings, cpi, quits, eciWages, u6rate, participation,
                    finEmployment, gvtEmployment, eduEmployment, healthEmployment,
                    manEmployment, leisureEmployment, infoEmployment, profEmployment,
                    claims, contClaims, productivity
                );
                
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                window.employmentDataLoaded = true;
                
            } catch (error) {
                console.error('Error loading employment data:', error);
                loadingEl.innerHTML = `
                    <div class="text-center">
                        <i class="fas fa-exclamation-circle text-red-400 text-4xl mb-4"></i>
                        <p class="text-red-400 text-lg font-semibold mb-2">Error loading employment data</p>
                        <p class="text-gray-400 text-sm mb-4">${error.message}</p>
                        <button onclick="loadEmploymentData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Retry</button>
                    </div>
                `;
            }
        }

        // AI Insights Generator
        async function generateAIInsights() {
            const loadingEl = document.getElementById('aiInsightsLoading');
            const contentEl = document.getElementById('aiInsightsContent');
            const executiveSummaryEl = document.getElementById('aiExecutiveSummary');
            const risksListEl = document.getElementById('aiRisksList');
            const tailwindsListEl = document.getElementById('aiTailwindsList');
            const recommendationsEl = document.getElementById('aiRecommendations');
            const confidenceTextEl = document.getElementById('aiConfidenceText');
            const confidencePathEl = document.getElementById('aiConfidencePath');
            const economyStoplightEl = document.getElementById('economyStoplight');
            const marketStoplightEl = document.getElementById('marketStoplight');

            loadingEl.classList.remove('hidden');
            contentEl.classList.add('hidden');

            // Ensure dependencies are loaded
            const dependencies = [
                { name: 'Macro', loaded: window.macroDataLoaded },
                { name: 'Interest Rates', loaded: window.interestDataLoaded },
                { name: 'Debt & Fiscal', loaded: window.fiscalDataLoaded },
                { name: 'Employment', loaded: window.employmentDataLoaded }
            ];

            const missing = dependencies.filter(d => !d.loaded);
            if (missing.length > 0) {
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                executiveSummaryEl.innerHTML = `
                    <div class="p-4 bg-yellow-900/20 border border-yellow-700/50 rounded-lg">
                        <p class="text-yellow-400 font-bold mb-2 flex items-center">
                            <i class="fas fa-database mr-2"></i>Data Incomplete
                        </p>
                        <p class="text-gray-300 text-xs">
                            The AI engine requires full cross-domain datasets to perform synthesis. Please visit the following tabs to trigger data fetching: 
                            <strong class="text-white">${missing.map(m => m.name).join(', ')}</strong>.
                        </p>
                    </div>
                `;
                return;
            }

            // Simulated AI "Thinking" steps
            const thinkingSteps = [
                "Aggregating macro indicators...",
                "Analyzing yield curve structure...",
                "Synthesizing fiscal deficit trends...",
                "Evaluating labor market resilience...",
                "Performing cross-domain correlation analysis...",
                "Finalizing predictive regime output..."
            ];

            for (const step of thinkingSteps) {
                loadingEl.querySelector('p').textContent = step;
                await new Promise(resolve => setTimeout(resolve, 400));
            }

            try {
                // 1. Gather Signals (Pulling from global state and DOM)
                const signals = {
                    macroScore: window.lastMacroScore || 0,
                    sahmValue: parseFloat(document.getElementById('sahmChange')?.textContent.replace(/[^0-9.-]/g, '')) || 0,
                    yieldSpread: parseFloat(document.getElementById('yieldSpread')?.textContent.replace(/[^0-9.-]/g, '')) || 0.1,
                    claimsTrend: document.getElementById('claimsStatus')?.textContent || 'STABLE',
                    interestSqueeze: parseFloat(document.getElementById('interestSqueezeChart')?.nextElementSibling?.textContent.match(/\d+\.?\d*/)?.[0]) || 12, // Approximation
                    erpValue: parseFloat(document.getElementById('erpValue')?.textContent.replace(/[^0-9.-]/g, '')) || 2.0,
                    fedLiquidity: document.getElementById('liquidityStatus')?.textContent || 'STABLE',
                    unrate: parseFloat(document.getElementById('sahmCurrentRate')?.textContent) || 4.0
                };

                // 2. Determine Economy Stoplight
                let economyScore = 0; // -1 to +1
                if (signals.sahmValue >= 0.5) economyScore -= 0.8;
                if (signals.yieldSpread < 0) economyScore -= 0.4;
                if (signals.macroScore < 0) economyScore += signals.macroScore;
                if (signals.claimsTrend && signals.claimsTrend.includes('CONTRACTING')) economyScore -= 0.3;
                if (signals.macroScore > 0.3) economyScore += 0.3;

                let economyColor = 'green';
                let economyText = 'Robust Expansion';
                let economyCircleColor = '34,197,94';
                if (economyScore < -0.4) {
                    economyColor = 'red';
                    economyText = 'High Recession Risk';
                    economyCircleColor = '239,68,68';
                } else if (economyScore < 0.1) {
                    economyColor = 'yellow';
                    economyText = 'Late Cycle / Fragile';
                    economyCircleColor = '234,179,8';
                }

                economyStoplightEl.innerHTML = `
                    <div class="w-12 h-12 rounded-full border-4 border-gray-700 bg-${economyColor}-500 shadow-[0_0_20px_rgba(${economyCircleColor},0.5)]"></div>
                    <div>
                        <div class="text-lg font-bold text-white">${economyText}</div>
                        <div class="text-[10px] text-gray-500 uppercase tracking-tighter">AI Confidence Index: ${Math.round(80 + Math.random()*15)}%</div>
                    </div>
                `;

                // 3. Determine Market Stoplight
                let marketScore = 0;
                if (signals.erpValue < 1.0) marketScore -= 0.6;
                if (signals.fedLiquidity && signals.fedLiquidity.includes('CONTRACTING')) marketScore -= 0.5;
                if (signals.fedLiquidity && signals.fedLiquidity.includes('EXPANDING')) marketScore += 0.6;
                if (signals.erpValue > 3.5) marketScore += 0.4;
                if (economyScore < -0.5) marketScore -= 0.4;

                let marketColor = 'green';
                let marketText = 'Bullish Bias';
                let marketCircleColor = '34,197,94';
                if (marketScore < -0.3) {
                    marketColor = 'red';
                    marketText = 'Defensive Required';
                    marketCircleColor = '239,68,68';
                } else if (marketScore < 0.2) {
                    marketColor = 'yellow';
                    marketText = 'Neutral / Volatile';
                    marketCircleColor = '234,179,8';
                }

                marketStoplightEl.innerHTML = `
                    <div class="w-12 h-12 rounded-full border-4 border-gray-700 bg-${marketColor}-500 shadow-[0_0_20px_rgba(${marketCircleColor},0.5)]"></div>
                    <div>
                        <div class="text-lg font-bold text-white">${marketText}</div>
                        <div class="text-[10px] text-gray-500 uppercase tracking-tighter">Liquidity Adjusted Signal</div>
                    </div>
                `;

                // 4. Generate Executive Summary
                let summaryParts = [];
                summaryParts.push(`The AI engine identifies a <strong>${economyText.toLowerCase()}</strong> economic regime paired with a <strong>${marketText.toLowerCase()}</strong> market posture.`);
                
                if (signals.yieldSpread < 0 && signals.sahmValue < 0.3) {
                    summaryParts.push("A critical divergence exists: the yield curve signals deep cyclical concern, yet the Sahm Rule and Initial Claims suggest labor market resilience is currently holding the expansion together.");
                }
                
                if (signals.fedLiquidity && signals.fedLiquidity.includes('EXPANDING')) {
                    summaryParts.push("Central bank liquidity is currently the 'X-factor,' providing a mechanical floor to asset prices despite lackluster fundamental growth signals.");
                } else if (signals.fedLiquidity && signals.fedLiquidity.includes('CONTRACTING')) {
                    summaryParts.push("The removal of net liquidity acts as a 'stealth headwind,' increasing the probability that any fundamental shock results in an outsized market correction.");
                }

                if (signals.erpValue < 1.5) {
                    summaryParts.push("Equity valuations offer very little margin for error; the current Equity Risk Premium suggests that stocks are essentially 'fighting' the high returns available in risk-free T-bills.");
                }

                executiveSummaryEl.innerHTML = summaryParts.map(p => `<p class="mb-3">${p}</p>`).join('');

                // 5. Risks & Tailwinds
                const risks = [];
                if (signals.yieldSpread < 0) risks.push("Persistent Yield Curve Inversion (10Y-2Y)");
                if (signals.sahmValue > 0.35) risks.push(`Labor market cooling exceeding 0.35% threshold`);
                if (signals.interestSqueeze > 14) risks.push("Rising Debt Service as % of Tax Revenue");
                if (signals.erpValue < 1.0) risks.push("Extremely compressed Equity Risk Premium");
                if (signals.fedLiquidity && signals.fedLiquidity.includes('CONTRACTING')) risks.push("Contractionary Net Liquidity Trend");
                if (risks.length === 0) risks.push("No high-probability systemic risks detected");

                const tailwinds = [];
                if (signals.macroScore > 0.15) tailwinds.push("Positive Composite Macro Momentum");
                if (signals.fedLiquidity && signals.fedLiquidity.includes('EXPANDING')) tailwinds.push("Mechanical Liquidity Support");
                if (signals.claimsTrend && signals.claimsTrend.includes('HEALTHY')) tailwinds.push("Strong Labor Market Absorption");
                if (signals.erpValue > 4.0) tailwinds.push("Valuation Support (High ERP)");
                if (signals.unrate < 4.0) tailwinds.push("Full Employment Dynamics");
                if (tailwinds.length === 0) tailwinds.push("Defensive positioning currently favored");

                risksListEl.innerHTML = risks.map(r => `<li>${r}</li>`).join('');
                tailwindsListEl.innerHTML = tailwinds.map(t => `<li>${t}</li>`).join('');

                // 6. Strategic Recommendations
                const getWeight = (score) => Math.min(90, Math.max(10, 50 + (score * 40)));
                
                recommendationsEl.innerHTML = `
                    <div class="p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <div class="flex justify-between mb-1">
                            <span class="text-xs text-gray-400">Equities</span>
                            <span class="text-xs font-bold text-${marketColor === 'green' ? 'green' : marketColor === 'yellow' ? 'yellow' : 'red'}-400">${marketColor === 'green' ? 'OVERWEIGHT' : marketColor === 'yellow' ? 'NEUTRAL' : 'UNDERWEIGHT'}</span>
                        </div>
                        <div class="w-full bg-gray-700 h-1.5 rounded-full">
                            <div class="bg-${marketColor === 'green' ? 'green' : marketColor === 'yellow' ? 'yellow' : 'red'}-500 h-1.5 rounded-full" style="width: ${marketColor === 'green' ? '80%' : marketColor === 'yellow' ? '50%' : '25%'}"></div>
                        </div>
                    </div>
                    <div class="p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <div class="flex justify-between mb-1">
                            <span class="text-xs text-gray-400">Long Duration Bonds</span>
                            <span class="text-xs font-bold text-blue-400">${economyColor === 'red' ? 'OVERWEIGHT' : 'NEUTRAL'}</span>
                        </div>
                        <div class="w-full bg-gray-700 h-1.5 rounded-full">
                            <div class="bg-blue-500 h-1.5 rounded-full" style="width: ${economyColor === 'red' ? '85%' : '40%'}"></div>
                        </div>
                    </div>
                    <div class="p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <div class="flex justify-between mb-1">
                            <span class="text-xs text-gray-400">Defensive / Cash</span>
                            <span class="text-xs font-bold text-purple-400">${marketColor === 'red' ? 'MAXIMIZE' : 'MINIMIZE'}</span>
                        </div>
                        <div class="w-full bg-gray-700 h-1.5 rounded-full">
                            <div class="bg-purple-500 h-1.5 rounded-full" style="width: ${marketColor === 'red' ? '95%' : '15%'}"></div>
                        </div>
                    </div>
                `;

                // 7. Calculate Cross-Domain Confidence Score
                // This measures how confident we are in the cross-domain synthesis
                
                // Component 1: Data Completeness (25% weight)
                // Check if all required domains are loaded
                const domainCompleteness = {
                    macro: window.macroDataLoaded ? 1 : 0,
                    interest: window.interestDataLoaded ? 1 : 0,
                    fiscal: window.fiscalDataLoaded ? 1 : 0,
                    employment: window.employmentDataLoaded ? 1 : 0
                };
                const completenessScore = (domainCompleteness.macro + 
                                         domainCompleteness.interest + 
                                         domainCompleteness.fiscal + 
                                         domainCompleteness.employment) / 4 * 100;
                
                // Component 2: Signal Quality & Validity (20% weight)
                // Check if signals are valid (not null/undefined, within reasonable ranges)
                let signalQualityScore = 100;
                const signalChecks = [
                    { value: signals.macroScore, valid: signals.macroScore !== null && !isNaN(signals.macroScore), name: 'Macro Score' },
                    { value: signals.sahmValue, valid: signals.sahmValue !== null && !isNaN(signals.sahmValue) && Math.abs(signals.sahmValue) < 5, name: 'Sahm Rule' },
                    { value: signals.yieldSpread, valid: signals.yieldSpread !== null && !isNaN(signals.yieldSpread) && Math.abs(signals.yieldSpread) < 10, name: 'Yield Spread' },
                    { value: signals.erpValue, valid: signals.erpValue !== null && !isNaN(signals.erpValue) && signals.erpValue > -5 && signals.erpValue < 10, name: 'ERP' },
                    { value: signals.unrate, valid: signals.unrate !== null && !isNaN(signals.unrate) && signals.unrate > 0 && signals.unrate < 20, name: 'Unemployment' }
                ];
                const invalidSignals = signalChecks.filter(s => !s.valid).length;
                signalQualityScore = Math.max(0, 100 - (invalidSignals / signalChecks.length) * 100);
                
                // Component 3: Signal Alignment/Consistency (30% weight)
                // Measure how well signals from different domains agree
                let alignmentScore = 100;
                
                // Check economy vs market alignment
                const economyMarketAlignment = Math.abs(economyScore - marketScore);
                // If they're very different (divergence > 1.0), reduce confidence
                if (economyMarketAlignment > 1.0) {
                    alignmentScore -= 20; // High divergence reduces confidence
                } else if (economyMarketAlignment > 0.6) {
                    alignmentScore -= 10; // Moderate divergence
                }
                
                // Check for signal conflicts (e.g., yield curve inverted but macro positive)
                let conflictCount = 0;
                if (signals.yieldSpread < 0 && signals.macroScore > 0.3) conflictCount++; // Inverted curve but strong macro
                if (signals.sahmValue > 0.5 && signals.claimsTrend && signals.claimsTrend.includes('HEALTHY')) conflictCount++; // Sahm warning but healthy claims
                if (signals.erpValue < 1.0 && signals.fedLiquidity && signals.fedLiquidity.includes('EXPANDING')) conflictCount++; // Low ERP but expanding liquidity
                
                alignmentScore -= conflictCount * 15; // Each conflict reduces confidence
                alignmentScore = Math.max(0, alignmentScore);
                
                // Component 4: Synthesis Quality (25% weight)
                // Based on how many signals we successfully synthesized and their reliability
                let synthesisScore = 100;
                const totalSignals = 8; // Total signals we're tracking
                let availableSignals = 0;
                
                if (signals.macroScore !== null && !isNaN(signals.macroScore)) availableSignals++;
                if (signals.sahmValue !== null && !isNaN(signals.sahmValue)) availableSignals++;
                if (signals.yieldSpread !== null && !isNaN(signals.yieldSpread)) availableSignals++;
                if (signals.claimsTrend && signals.claimsTrend !== 'STABLE') availableSignals++;
                if (signals.erpValue !== null && !isNaN(signals.erpValue)) availableSignals++;
                if (signals.fedLiquidity && signals.fedLiquidity !== 'STABLE') availableSignals++;
                if (signals.unrate !== null && !isNaN(signals.unrate)) availableSignals++;
                if (signals.interestSqueeze !== null && !isNaN(signals.interestSqueeze)) availableSignals++;
                
                synthesisScore = (availableSignals / totalSignals) * 100;
                
                // Calculate weighted final confidence score
                const confidence = Math.round(
                    (completenessScore * 0.25) +
                    (signalQualityScore * 0.20) +
                    (alignmentScore * 0.30) +
                    (synthesisScore * 0.25)
                );
                
                // Clamp between 0 and 100
                const finalConfidence = Math.max(0, Math.min(100, confidence));
                
                confidenceTextEl.textContent = `${finalConfidence}%`;
                confidencePathEl.setAttribute('stroke-dasharray', `${finalConfidence}, 100`);

                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');

            } catch (error) {
                console.error('Error generating AI insights:', error);
                executiveSummaryEl.innerHTML = `<p class="text-red-400">Error generating insights: ${error.message}</p>`;
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
            }
        }


        function processEmploymentData(
            openings, unemployed, openingsRate, unrate, 
            payrolls, employedLevel,
            earnings, cpi, quits, eciWages, u6rate, participation,
            fin, gvt, edu, health, man, leisure, info, prof,
            claims, contClaims, productivity = []
        ) {
            // --- 1. Labor Market Tightness (V/U Ratio) ---
            const tightnessMap = new Map();
            openings.forEach(d => tightnessMap.set(d.date, { v: d.value }));
            unemployed.forEach(d => {
                if (tightnessMap.has(d.date)) tightnessMap.get(d.date).u = d.value;
            });
            const sortedTightnessDates = Array.from(tightnessMap.keys()).sort();
            const tightnessValues = sortedTightnessDates.map(d => {
                const p = tightnessMap.get(d);
                return (p.v && p.u) ? p.v / p.u : null;
            }).filter(v => v !== null);

            // --- 2. Beveridge Curve (Scatter) ---
            const beveridgeData = [];
            const beveridgeMap = new Map();
            openingsRate.forEach(d => beveridgeMap.set(d.date, { y: d.value }));
            unrate.forEach(d => {
                if (beveridgeMap.has(d.date)) {
                    beveridgeData.push({ x: d.value, y: beveridgeMap.get(d.date).y, date: d.date });
                }
            });

            // --- 3. Real Wage Growth (%Δ Earnings - %Δ CPI) ---
            const earningsYoY = calculateYoYChange(earnings);
            const cpiYoY = calculateYoYChange(cpi);
            const realWageMap = new Map();
            earningsYoY.forEach(d => realWageMap.set(d.date, { earnings: d.value }));
            cpiYoY.forEach(d => {
                if (realWageMap.has(d.date)) realWageMap.get(d.date).cpi = d.value;
            });
            const sortedWageDates = Array.from(realWageMap.keys()).sort();
            const realWageValues = sortedWageDates.map(d => {
                const p = realWageMap.get(d);
                return (p.earnings !== undefined && p.cpi !== undefined) ? p.earnings - p.cpi : null;
            });

            const validRealWageValues = realWageValues.filter(v => v !== null);
            const validWageDates = sortedWageDates.filter((d, i) => realWageValues[i] !== null);

            // --- 4. Quits vs. Wage Growth ---
            const eciYoY = calculateYoYChange(eciWages);
            const quitsMap = new Map();
            quits.forEach(d => quitsMap.set(d.date, { quits: d.value }));
            eciYoY.forEach(d => {
                // ECI is quarterly, Quits is monthly. Carry forward ECI.
                const eciDate = d.date;
                sortedTightnessDates.forEach(td => {
                    if (td.startsWith(eciDate.substring(0, 7))) {
                        if (quitsMap.has(td)) quitsMap.get(td).eci = d.value;
                    }
                });
            });
            const sortedQuitsDates = Array.from(quitsMap.keys()).sort();
            const alignedQuits = sortedQuitsDates.map(d => quitsMap.get(d).quits || null);
            const alignedECI = sortedQuitsDates.map(d => {
                // Search for latest available ECI
                let val = null;
                for (let i = eciYoY.length - 1; i >= 0; i--) {
                    if (eciYoY[i].date <= d) {
                        val = eciYoY[i].value;
                        break;
                    }
                }
                return val;
            });

            // --- 5. Sector Trends ---
            const mode = window.sectorChartMode || 'cumulative';
            
            const indexSector = (data) => {
                if (data.length === 0) return [];
                const first = data[0].value;
                return data.map(d => ({ date: d.date, value: (d.value / first) * 100 }));
            };

            const calculate3YrROC = (data) => {
                if (data.length < 36) return [];
                return data.map((d, i) => {
                    if (i < 36) return { date: d.date, value: null };
                    const prev = data[i - 36];
                    return { date: d.date, value: ((d.value / prev.value) - 1) * 100 };
                });
            };

            const processSectorData = (data) => {
                const tenYearsAgo = new Date();
                tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
                const tenYearStartDate = tenYearsAgo.toISOString().split('T')[0];
                
                const filteredData = data.filter(d => d.date >= tenYearStartDate);
                
                if (mode === 'roc') return calculate3YrROC(filteredData);
                return indexSector(filteredData);
            };

            const sectors = [
                { label: 'Financials', data: processSectorData(fin), color: '#60a5fa' },
                { label: 'Healthcare', data: processSectorData(health), color: '#f87171' },
                { label: 'Education', data: processSectorData(edu), color: '#34d399' },
                { label: 'Tech (Info)', data: processSectorData(info), color: '#8b5cf6' },
                { label: 'Manufacturing', data: processSectorData(man), color: '#f59e0b' },
                { label: 'Professional', data: processSectorData(prof), color: '#10b981' },
                { label: 'Leisure', data: processSectorData(leisure), color: '#ec4899' },
                { label: 'Government', data: processSectorData(gvt), color: '#94a3b8' }
            ];

            // --- UPDATE SUMMARY CARDS ---
            if (tightnessValues.length > 0) {
                const latest = tightnessValues[tightnessValues.length - 1];
                const prev = tightnessValues.length > 12 ? tightnessValues[tightnessValues.length - 13] : tightnessValues[0];
                const diff = latest - prev;
                document.getElementById('tightnessRatioValue').textContent = (latest !== null) ? latest.toFixed(2) : '--';
                document.getElementById('tightnessRatioTrend').textContent = (diff !== null) ? `${diff >= 0 ? '+' : ''}${diff.toFixed(2)} YoY` : '--';
                document.getElementById('tightnessRatioTrend').className = `text-xs ${diff < -0.2 ? 'text-red-400' : (latest > 1.2 ? 'text-orange-400' : 'text-green-400')}`;
            }

            if (unrate.length > 0) {
                const latest = unrate[unrate.length - 1];
                const prev = unrate.length > 12 ? unrate[unrate.length - 13] : unrate[0];
                const diff = (latest && prev) ? latest.value - prev.value : 0;
                document.getElementById('employmentUnrateValue').textContent = (latest && latest.value !== null) ? latest.value.toFixed(1) + '%' : '--';
                document.getElementById('employmentUnrateTrend').textContent = `${diff >= 0 ? '+' : ''}${diff.toFixed(1)}% YoY`;
                document.getElementById('employmentUnrateTrend').className = `text-xs ${diff > 0.5 ? 'text-red-400' : 'text-green-400'}`;
            }

            if (u6rate.length > 0) {
                const latest = u6rate[u6rate.length - 1];
                const prev = u6rate.length > 12 ? u6rate[u6rate.length - 13] : u6rate[0];
                const diff = (latest && prev) ? latest.value - prev.value : 0;
                document.getElementById('u6RateValue').textContent = (latest && latest.value !== null) ? latest.value.toFixed(1) + '%' : '--';
                document.getElementById('u6RateTrend').textContent = `${diff >= 0 ? '+' : ''}${diff.toFixed(1)}% YoY`;
                document.getElementById('u6RateTrend').className = `text-xs ${diff > 0.5 ? 'text-red-400' : 'text-green-400'}`;
            }

            if (participation.length > 0) {
                const latest = participation[participation.length - 1];
                const prev = participation.length > 12 ? participation[participation.length - 13] : participation[0];
                const diff = (latest && prev) ? latest.value - prev.value : 0;
                document.getElementById('participationRateValue').textContent = (latest && latest.value !== null) ? latest.value.toFixed(1) + '%' : '--';
                document.getElementById('participationRateTrend').textContent = `${diff >= 0 ? '+' : ''}${diff.toFixed(1)}% YoY`;
                document.getElementById('participationRateTrend').className = `text-xs ${diff < 0 ? 'text-red-400' : 'text-green-400'}`;
            }

            if (validRealWageValues.length > 0) {
                const latest = validRealWageValues[validRealWageValues.length - 1];
                document.getElementById('realWageGrowthValue').textContent = (latest !== null) ? (latest >= 0 ? '+' : '') + latest.toFixed(1) + '%' : '--';
                document.getElementById('realWageGrowthTrend').textContent = 'Purchasing Power';
                document.getElementById('realWageGrowthTrend').className = `text-xs ${latest < 0 ? 'text-red-400' : 'text-green-400'}`;
            }

            if (quits.length > 0) {
                const latest = quits[quits.length - 1];
                document.getElementById('quitsRateValue').textContent = (latest && latest.value !== null) ? latest.value.toFixed(1) + '%' : '--';
                document.getElementById('quitsRateTrend').textContent = 'Confidence Index';
            }

            // --- RENDER CHARTS ---
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: { 
                    legend: { labels: { color: '#9ca3af', font: { size: 10 } } }
                },
                scales: {
                    x: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } },
                    y: { ticks: { color: '#9ca3af', font: { size: 9 } }, grid: { color: 'rgba(156, 163, 175, 0.1)' } }
                }
            };

            // --- Headline Charts (Monthly Change, Participation, Employed, Unrate) ---
            const calcMovingAverage = (values, window = 12) => {
                const out = new Array(values.length).fill(null);
                for (let i = window - 1; i < values.length; i++) {
                    let sum = 0;
                    let count = 0;
                    let ok = true;
                    for (let j = i - window + 1; j <= i; j++) {
                        const v = values[j];
                        if (v === null || v === undefined || Number.isNaN(v)) { ok = false; break; }
                        sum += v;
                        count++;
                    }
                    out[i] = (ok && count === window) ? (sum / window) : null;
                }
                return out;
            };
            const setLatestMeta = (elId, date, valueText) => {
                const el = document.getElementById(elId);
                if (!el) return;
                if (!date || !valueText) {
                    el.textContent = '';
                    return;
                }
                el.textContent = `Latest: ${date} | ${valueText}`;
            };

            // 0a. Monthly Change in Payrolls (PAYEMS MoM difference, shown in thousands)
            const ctxEmpChg = document.getElementById('employmentMonthlyChangeChart');
            if (ctxEmpChg) {
                if (employmentMonthlyChangeChartInstance) employmentMonthlyChangeChartInstance.destroy();
                if (payrolls && payrolls.length > 1) {
                    const payrollLabels = payrolls.map(d => d.date);
                    const payrollValues = payrolls.map(d => d.value);
                    const payrollMoM = payrollValues.map((v, i, arr) => {
                        if (i === 0 || v === null || arr[i - 1] === null) return null;
                        return v - arr[i - 1]; // PAYEMS is in thousands
                    });
                    const payrollMoMMA12 = calcMovingAverage(payrollMoM, 12);
                    const lastPayrollIdx = (() => {
                        for (let i = payrollMoM.length - 1; i >= 0; i--) if (payrollMoM[i] !== null && payrollMoM[i] !== undefined && !Number.isNaN(payrollMoM[i])) return i;
                        return -1;
                    })();
                    if (lastPayrollIdx !== -1) {
                        setLatestMeta(
                            'employmentMonthlyChangeLatestMeta',
                            payrollLabels[lastPayrollIdx],
                            `${payrollMoM[lastPayrollIdx] >= 0 ? '+' : ''}${payrollMoM[lastPayrollIdx].toFixed(0)}k`
                        );
                    } else {
                        setLatestMeta('employmentMonthlyChangeLatestMeta', null, null);
                    }
                    employmentMonthlyChangeChartInstance = new Chart(ctxEmpChg, {
                        type: 'bar',
                        data: {
                            labels: payrollLabels,
                            datasets: [{
                                label: 'Payroll Change (k, MoM)',
                                data: payrollMoM,
                                backgroundColor: payrollMoM.map(v => v === null ? 'rgba(156, 163, 175, 0.15)' : (v >= 0 ? 'rgba(16, 185, 129, 0.55)' : 'rgba(239, 68, 68, 0.55)')),
                                borderColor: payrollMoM.map(v => v === null ? 'rgba(156, 163, 175, 0.2)' : (v >= 0 ? 'rgba(16, 185, 129, 0.9)' : 'rgba(239, 68, 68, 0.9)')),
                                borderWidth: 1
                            }, {
                                label: '12M MA',
                                data: payrollMoMMA12,
                                type: 'line',
                                borderColor: 'rgba(96, 165, 250, 0.9)',
                                borderWidth: 2,
                                pointRadius: payrollMoMMA12.map((_, i) => i === lastPayrollIdx ? 3 : 0),
                                pointHoverRadius: payrollMoMMA12.map((_, i) => i === lastPayrollIdx ? 4 : 0),
                                pointBackgroundColor: 'rgba(96, 165, 250, 0.95)',
                                fill: false
                            }, {
                                label: 'Zero Line',
                                data: new Array(payrollLabels.length).fill(0),
                                type: 'line',
                                borderColor: 'rgba(255, 255, 255, 0.7)',
                                borderWidth: 1,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            ...commonOptions,
                            plugins: {
                                ...commonOptions.plugins,
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            if (context.dataset.label === 'Zero Line') return null;
                                            const v = context.parsed.y;
                                            if (v === null || v === undefined || Number.isNaN(v)) return null;
                                            if (context.dataset.label === '12M MA') return `MA12: ${v >= 0 ? '+' : ''}${v.toFixed(0)}k`;
                                            return `Payroll Change: ${v >= 0 ? '+' : ''}${v.toFixed(0)}k`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                ...commonOptions.scales,
                                y: {
                                    ...commonOptions.scales.y,
                                    min: -1000,
                                    max: 1000,
                                    ticks: { ...commonOptions.scales.y.ticks, callback: v => (v >= 0 ? '+' : '') + v.toFixed(0) + 'k' }
                                }
                            }
                        },
                        plugins: [getRecessionShadingPlugin()]
                    });
                }
            }

            // 0b. Participation Rate (CIVPART)
            const ctxPart = document.getElementById('participationRateChart');
            if (ctxPart) {
                if (participationRateChartInstance) participationRateChartInstance.destroy();
                if (participation && participation.length > 1) {
                    const partVals = participation.map(d => d.value);
                    const partMA12 = calcMovingAverage(partVals, 12);
                    const lastPartIdx = (() => {
                        for (let i = partVals.length - 1; i >= 0; i--) if (partVals[i] !== null && partVals[i] !== undefined && !Number.isNaN(partVals[i])) return i;
                        return -1;
                    })();
                    if (lastPartIdx !== -1) {
                        setLatestMeta(
                            'participationRateLatestMeta',
                            participation[lastPartIdx]?.date,
                            `${partVals[lastPartIdx].toFixed(1)}%`
                        );
                    } else {
                        setLatestMeta('participationRateLatestMeta', null, null);
                    }
                    participationRateChartInstance = new Chart(ctxPart, {
                        type: 'line',
                        data: {
                            labels: participation.map(d => d.date),
                            datasets: [{
                                label: 'Participation Rate (%)',
                                data: partVals,
                                borderColor: '#60a5fa',
                                backgroundColor: 'rgba(96, 165, 250, 0.10)',
                                fill: true,
                                borderWidth: 2,
                                pointRadius: partVals.map((_, i) => i === lastPartIdx ? 3 : 0),
                                pointHoverRadius: partVals.map((_, i) => i === lastPartIdx ? 4 : 0)
                            }, {
                                label: '12M MA',
                                data: partMA12,
                                borderColor: 'rgba(229, 231, 235, 0.8)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: partMA12.map((_, i) => i === lastPartIdx ? 3 : 0),
                                pointHoverRadius: partMA12.map((_, i) => i === lastPartIdx ? 4 : 0)
                            }]
                        },
                        options: {
                            ...commonOptions,
                            scales: {
                                ...commonOptions.scales,
                                y: {
                                    ...commonOptions.scales.y,
                                    ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(1) + '%' }
                                }
                            }
                        },
                        plugins: [getRecessionShadingPlugin()]
                    });
                }
            }

            // 0c. Total Employed (CE16OV, in thousands -> display as millions)
            const ctxEmployed = document.getElementById('totalEmployedChart');
            if (ctxEmployed) {
                if (totalEmployedChartInstance) totalEmployedChartInstance.destroy();
                if (employedLevel && employedLevel.length > 1) {
                    const employedMillions = employedLevel.map(d => (d.value === null ? null : d.value / 1000)); // thousands -> millions
                    const employedMA12 = calcMovingAverage(employedMillions, 12);
                    const lastEmpIdx = (() => {
                        for (let i = employedMillions.length - 1; i >= 0; i--) if (employedMillions[i] !== null && employedMillions[i] !== undefined && !Number.isNaN(employedMillions[i])) return i;
                        return -1;
                    })();
                    if (lastEmpIdx !== -1) {
                        setLatestMeta(
                            'totalEmployedLatestMeta',
                            employedLevel[lastEmpIdx]?.date,
                            `${employedMillions[lastEmpIdx].toFixed(1)}M`
                        );
                    } else {
                        setLatestMeta('totalEmployedLatestMeta', null, null);
                    }
                    totalEmployedChartInstance = new Chart(ctxEmployed, {
                        type: 'line',
                        data: {
                            labels: employedLevel.map(d => d.date),
                            datasets: [{
                                label: 'Employed (Millions)',
                                data: employedMillions,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.10)',
                                fill: true,
                                borderWidth: 2,
                                pointRadius: employedMillions.map((_, i) => i === lastEmpIdx ? 3 : 0),
                                pointHoverRadius: employedMillions.map((_, i) => i === lastEmpIdx ? 4 : 0)
                            }, {
                                label: '12M MA',
                                data: employedMA12,
                                borderColor: 'rgba(229, 231, 235, 0.8)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: employedMA12.map((_, i) => i === lastEmpIdx ? 3 : 0),
                                pointHoverRadius: employedMA12.map((_, i) => i === lastEmpIdx ? 4 : 0)
                            }]
                        },
                        options: {
                            ...commonOptions,
                            scales: {
                                ...commonOptions.scales,
                                y: {
                                    ...commonOptions.scales.y,
                                    ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(0) + 'M' }
                                }
                            }
                        },
                        plugins: [getRecessionShadingPlugin()]
                    });
                }
            }

            // 0d. Unemployment Rate (UNRATE)
            const ctxUnrate = document.getElementById('unemploymentRateChart');
            if (ctxUnrate) {
                if (unemploymentRateChartInstance) unemploymentRateChartInstance.destroy();
                if (unrate && unrate.length > 1) {
                    const unrateVals = unrate.map(d => d.value);
                    const unrateMA12 = calcMovingAverage(unrateVals, 12);
                    const lastUnIdx = (() => {
                        for (let i = unrateVals.length - 1; i >= 0; i--) if (unrateVals[i] !== null && unrateVals[i] !== undefined && !Number.isNaN(unrateVals[i])) return i;
                        return -1;
                    })();
                    if (lastUnIdx !== -1) {
                        setLatestMeta(
                            'unemploymentRateLatestMeta',
                            unrate[lastUnIdx]?.date,
                            `${unrateVals[lastUnIdx].toFixed(1)}%`
                        );
                    } else {
                        setLatestMeta('unemploymentRateLatestMeta', null, null);
                    }
                    unemploymentRateChartInstance = new Chart(ctxUnrate, {
                        type: 'line',
                        data: {
                            labels: unrate.map(d => d.date),
                            datasets: [{
                                label: 'Unemployment Rate (%)',
                                data: unrateVals,
                                borderColor: '#f87171',
                                backgroundColor: 'rgba(248, 113, 113, 0.10)',
                                fill: true,
                                borderWidth: 2,
                                pointRadius: unrateVals.map((_, i) => i === lastUnIdx ? 3 : 0),
                                pointHoverRadius: unrateVals.map((_, i) => i === lastUnIdx ? 4 : 0)
                            }, {
                                label: '12M MA',
                                data: unrateMA12,
                                borderColor: 'rgba(229, 231, 235, 0.8)',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: unrateMA12.map((_, i) => i === lastUnIdx ? 3 : 0),
                                pointHoverRadius: unrateMA12.map((_, i) => i === lastUnIdx ? 4 : 0)
                            }]
                        },
                        options: {
                            ...commonOptions,
                            scales: {
                                ...commonOptions.scales,
                                y: {
                                    ...commonOptions.scales.y,
                                    ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(1) + '%' }
                                }
                            }
                        },
                        plugins: [getRecessionShadingPlugin()]
                    });
                }
            }

            // 1. Tightness Chart
            const ctxTight = document.getElementById('tightnessChart');
            if (tightnessChartInstance) tightnessChartInstance.destroy();
            
            const tightnessSorted = [...tightnessValues].filter(v => v !== null).sort((a, b) => a - b);
            const q1Tightness = tightnessSorted[Math.floor(tightnessSorted.length * 0.25)];
            const medianTightness = tightnessSorted[Math.floor(tightnessSorted.length * 0.5)];
            const q3Tightness = tightnessSorted[Math.floor(tightnessSorted.length * 0.75)];

            tightnessChartInstance = new Chart(ctxTight, {
                type: 'line',
                data: {
                    labels: sortedTightnessDates,
                    datasets: [{
                        label: 'V/U Ratio', data: tightnessValues, borderColor: '#60a5fa', borderWidth: 2, fill: false, pointRadius: 0, zIndex: 10
                    }, {
                        label: 'Q3', data: new Array(sortedTightnessDates.length).fill(q3Tightness), borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 2, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Median', data: new Array(sortedTightnessDates.length).fill(medianTightness), borderColor: 'rgba(156, 163, 175, 0.9)', borderWidth: 2, borderDash: [2, 2], fill: false, pointRadius: 0
                    }, {
                        label: 'Q1', data: new Array(sortedTightnessDates.length).fill(q1Tightness), borderColor: 'rgba(16, 185, 129, 0.8)', borderWidth: 2, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Neutral (1.0)', data: new Array(sortedTightnessDates.length).fill(1.0), borderColor: '#ffffff', borderWidth: 1.5, borderDash: [], fill: false, pointRadius: 0
                    }]
                },
                options: commonOptions
            });

            // 2. Beveridge Curve
            const ctxBev = document.getElementById('beveridgeChart');
            if (beveridgeChartInstance) beveridgeChartInstance.destroy();
            
            // Highlight latest point
            const lastBevPoint = beveridgeData[beveridgeData.length - 1];
            
            // Calculate medians for quadrant lines
            const bevXSorted = [...beveridgeData].map(d => d.x).sort((a, b) => a - b);
            const bevYSorted = [...beveridgeData].map(d => d.y).sort((a, b) => a - b);
            const medianX = bevXSorted[Math.floor(bevXSorted.length * 0.5)];
            const medianY = bevYSorted[Math.floor(bevYSorted.length * 0.5)];

            beveridgeChartInstance = new Chart(ctxBev, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Historical Data', 
                        data: beveridgeData.slice(0, -1), 
                        backgroundColor: 'rgba(96, 165, 250, 0.3)', 
                        borderColor: 'rgba(96, 165, 250, 0.5)', 
                        pointRadius: 2
                    }, {
                        label: 'LATEST (' + (lastBevPoint ? lastBevPoint.date : '') + ')', 
                        data: [lastBevPoint], 
                        backgroundColor: '#ef4444', 
                        borderColor: '#ffffff', 
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10,
                        zIndex: 20
                    }]
                },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        annotation: {
                            annotations: {
                                lineX: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: 'rgba(156, 163, 175, 0.8)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: 'Median Unrate',
                                        position: 'end',
                                        backgroundColor: 'rgba(31, 41, 55, 0.8)',
                                        color: '#9ca3af',
                                        font: { size: 10 }
                                    }
                                },
                                lineY: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: 'rgba(156, 163, 175, 0.8)',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: 'Median Openings',
                                        position: 'end',
                                        backgroundColor: 'rgba(31, 41, 55, 0.8)',
                                        color: '#9ca3af',
                                        font: { size: 10 }
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Unemployment Rate (%)', color: '#9ca3af' }, ticks: { color: '#9ca3af' } },
                        y: { title: { display: true, text: 'Job Openings Rate (%)', color: '#9ca3af' }, ticks: { color: '#9ca3af' } }
                    }
                }
            });

            // 3. Real Wage Chart
            const ctxWage = document.getElementById('realWageChart');
            if (realWageChartInstance) realWageChartInstance.destroy();
            
            const wageSorted = [...realWageValues].filter(v => v !== null).sort((a, b) => a - b);
            const q1Wage = wageSorted[Math.floor(wageSorted.length * 0.25)];
            const medianWage = wageSorted[Math.floor(wageSorted.length * 0.5)];
            const q3Wage = wageSorted[Math.floor(wageSorted.length * 0.75)];

            realWageChartInstance = new Chart(ctxWage, {
                type: 'line',
                data: {
                    labels: validWageDates,
                    datasets: [{
                        label: 'Real Wage Growth (%)', data: validRealWageValues, borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', fill: true, borderWidth: 2, pointRadius: 0, zIndex: 10
                    }, {
                        label: 'Q3', data: new Array(validWageDates.length).fill(q3Wage), borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 2, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Median', data: new Array(validWageDates.length).fill(medianWage), borderColor: 'rgba(156, 163, 175, 0.9)', borderWidth: 2, borderDash: [2, 2], fill: false, pointRadius: 0
                    }, {
                        label: 'Q1', data: new Array(validWageDates.length).fill(q1Wage), borderColor: 'rgba(16, 185, 129, 0.8)', borderWidth: 2, borderDash: [5, 5], fill: false, pointRadius: 0
                    }, {
                        label: 'Zero Line', data: new Array(validWageDates.length).fill(0), borderColor: '#ffffff', borderWidth: 1.5, borderDash: [], fill: false, pointRadius: 0
                    }]
                },
                options: commonOptions
            });

            // 4. Quits vs Wage Growth
            const ctxQuits = document.getElementById('quitsWageChart');
            if (quitsWageChartInstance) quitsWageChartInstance.destroy();
            
            const quitsSorted = [...alignedQuits].filter(v => v !== null).sort((a, b) => a - b);
            const q1Quits = quitsSorted[Math.floor(quitsSorted.length * 0.25)];
            const medianQuits = quitsSorted[Math.floor(quitsSorted.length * 0.5)];
            const q3Quits = quitsSorted[Math.floor(quitsSorted.length * 0.75)];

            const eciSorted = [...alignedECI].filter(v => v !== null).sort((a, b) => a - b);
            const q1ECI = eciSorted[Math.floor(eciSorted.length * 0.25)];
            const medianECI = eciSorted[Math.floor(eciSorted.length * 0.5)];
            const q3ECI = eciSorted[Math.floor(eciSorted.length * 0.75)];

            quitsWageChartInstance = new Chart(ctxQuits, {
                type: 'line',
                data: {
                    labels: sortedQuitsDates,
                    datasets: [{
                        label: 'Quits Rate (%)', data: alignedQuits, borderColor: '#8b5cf6', borderWidth: 2, fill: false, pointRadius: 0, yAxisID: 'y', zIndex: 10
                    }, {
                        label: 'ECI Wage Growth (YoY %)', data: alignedECI, borderColor: '#f87171', borderWidth: 2, fill: false, pointRadius: 0, yAxisID: 'y1', zIndex: 10
                    }, {
                        label: 'Quits Median', data: new Array(sortedQuitsDates.length).fill(medianQuits), borderColor: 'rgba(139, 92, 246, 0.6)', borderWidth: 2, borderDash: [2, 2], fill: false, pointRadius: 0, yAxisID: 'y'
                    }, {
                        label: 'ECI Median', data: new Array(sortedQuitsDates.length).fill(medianECI), borderColor: 'rgba(248, 113, 113, 0.6)', borderWidth: 2, borderDash: [2, 2], fill: false, pointRadius: 0, yAxisID: 'y1'
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: { position: 'left', ticks: { color: '#9ca3af' } },
                        y1: { position: 'right', ticks: { color: '#9ca3af' }, grid: { display: false } }
                    }
                }
            });

            // 4b. Labor Productivity (OPHNFB - quarterly, index 2017=100)
            const ctxProd = document.getElementById('productivityChart');
            if (ctxProd && productivity && productivity.length > 0) {
                if (productivityChartInstance) productivityChartInstance.destroy();
                const prodSorted = [...productivity].sort((a, b) => new Date(a.date) - new Date(b.date));
                const prodLabels = prodSorted.map(d => d.date);
                const prodIndex = prodSorted.map(d => d.value);
                // YoY % change (quarterly: compare to 4 quarters ago)
                const prodYoY = prodIndex.map((v, i) => {
                    if (i < 4) return null;
                    const prev = prodIndex[i - 4];
                    return prev > 0 ? ((v / prev) - 1) * 100 : null;
                });
                const lastProdIdx = prodIndex.length - 1;
                if (lastProdIdx >= 0) {
                    const metaEl = document.getElementById('productivityLatestMeta');
                    if (metaEl) {
                        const yoyStr = prodYoY[lastProdIdx] !== null ? `YoY: ${(prodYoY[lastProdIdx] >= 0 ? '+' : '')}${prodYoY[lastProdIdx].toFixed(1)}%` : '';
                        metaEl.textContent = `Latest: ${prodLabels[lastProdIdx]} | Index: ${prodIndex[lastProdIdx].toFixed(1)}${yoyStr ? ' | ' + yoyStr : ''}`;
                    }
                }
                productivityChartInstance = new Chart(ctxProd, {
                    type: 'line',
                    data: {
                        labels: prodLabels,
                        datasets: [{
                            label: 'Output per Hour (Index 2017=100)',
                            data: prodIndex,
                            borderColor: '#60a5fa',
                            backgroundColor: 'rgba(96, 165, 250, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            pointRadius: 0,
                            yAxisID: 'y'
                        }, {
                            label: 'YoY % Change',
                            data: prodYoY,
                            borderColor: '#10b981',
                            borderWidth: 2,
                            borderDash: [4, 4],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y1'
                        }, {
                            label: 'Zero Line',
                            data: new Array(prodLabels.length).fill(0),
                            borderColor: 'rgba(156, 163, 175, 0.7)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        ...commonOptions,
                        scales: {
                            ...commonOptions.scales,
                            y: {
                                position: 'left',
                                ticks: { ...commonOptions.scales.y.ticks, callback: v => v.toFixed(0) }
                            },
                            y1: {
                                position: 'right',
                                ticks: { color: '#9ca3af', font: { size: 9 }, callback: v => (v >= 0 ? '+' : '') + v.toFixed(1) + '%' },
                                grid: { display: false }
                            }
                        }
                    },
                    plugins: [getRecessionShadingPlugin()]
                });
            }

            // 5. Sector Trends
            const ctxSector = document.getElementById('sectorEmploymentChart');
            if (sectorEmploymentChartInstance) sectorEmploymentChartInstance.destroy();
            
            // Find valid dates for sector labels - use any sector that has data
            const validSector = sectors.find(s => s.data.length > 0);
            const labels = validSector ? validSector.data.map(d => d.date) : [];
            
            sectorEmploymentChartInstance = new Chart(ctxSector, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: sectors.filter(s => s.data.length > 0).map(s => ({
                        label: s.label, 
                        data: s.data.map(d => d.value), 
                        borderColor: s.color, 
                        borderWidth: 2, 
                        fill: false, 
                        pointRadius: 0,
                        hidden: s.label === 'Leisure'
                    }))
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: { ticks: { callback: v => mode === 'roc' ? v.toFixed(1) + '%' : (v - 100).toFixed(1) + '%' } }
                    }
                }
            });

            // 6. Weekly Claims Chart
            const ctxClaims = document.getElementById('claimsChart');
            if (claimsChartInstance) claimsChartInstance.destroy();
            
            if (claims && claims.length > 0) {
                // Filter to last 2 years for weekly claims
                const twoYearsAgoClaims = new Date();
                twoYearsAgoClaims.setFullYear(twoYearsAgoClaims.getFullYear() - 2);
                const recentClaims = claims.filter(d => new Date(d.date) >= twoYearsAgoClaims);
                
                const labelsClaims = recentClaims.map(d => d.date);
                const valuesClaims = recentClaims.map(d => d.value);
                
                // Calculate 4-week moving average
                const ma4Values = valuesClaims.map((val, idx, arr) => {
                    if (idx < 3) return null;
                    const sum = arr[idx] + arr[idx-1] + arr[idx-2] + arr[idx-3];
                    return sum / 4;
                });

                // Calculate Regression Line for last 24 months
                const calculateRegression = (vals) => {
                    const n = vals.length;
                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    for (let i = 0; i < n; i++) {
                        sumX += i;
                        sumY += vals[i];
                        sumXY += i * vals[i];
                        sumX2 += i * i;
                    }
                    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    const intercept = (sumY - slope * sumX) / n;
                    return vals.map((_, i) => slope * i + intercept);
                };
                const regressionValues = calculateRegression(valuesClaims);

                claimsChartInstance = new Chart(ctxClaims, {
                    type: 'line',
                    data: {
                        labels: labelsClaims,
                        datasets: [
                            {
                                label: 'Initial Claims',
                                data: valuesClaims,
                                borderColor: '#60a5fa',
                                borderWidth: 1.5,
                                fill: false,
                                pointRadius: 0
                            },
                            {
                                label: '4-Week MA',
                                data: ma4Values,
                                borderColor: '#fbbf24',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0
                            },
                            {
                                label: '24M Trend Line',
                                data: regressionValues,
                                borderColor: 'rgba(255, 255, 255, 0.4)',
                                borderWidth: 1.5,
                                borderDash: [3, 3],
                                fill: false,
                                pointRadius: 0
                            },
                            {
                                label: '300k Warning Line',
                                data: new Array(labelsClaims.length).fill(300000),
                                borderColor: 'rgba(239, 68, 68, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0
                            }
                        ]
                    },
                    options: {
                        ...commonOptions,
                        scales: {
                            ...commonOptions.scales,
                            y: { 
                                ticks: { color: '#9ca3af', callback: v => (v / 1000).toFixed(0) + 'k' },
                                grid: { color: 'rgba(156, 163, 175, 0.1)' }
                            }
                        }
                    }
                });
            }

            // 7. Continuing Claims Chart
            const ctxContClaims = document.getElementById('contClaimsChart');
            if (contClaimsChartInstance) contClaimsChartInstance.destroy();
            
            if (contClaims && contClaims.length > 0) {
                // Get zoom mode (default to postcovid)
                const zoomMode = window.contClaimsZoomMode || 'postcovid';
                
                // Filter data based on zoom mode
                let filteredContClaims;
                if (zoomMode === 'postcovid') {
                    // Filter from June 22, 2022 forward
                    const postCovidDate = new Date('2022-06-22');
                    filteredContClaims = contClaims.filter(d => new Date(d.date) >= postCovidDate);
                } else {
                    // Show longer history for continuing claims (10 years)
                    const tenYearsAgo = new Date();
                    tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
                    filteredContClaims = contClaims.filter(d => new Date(d.date) >= tenYearsAgo);
                }
                
                const labelsCont = filteredContClaims.map(d => d.date);
                const valuesCont = filteredContClaims.map(d => d.value);

                // Calculate 1-year rolling median and quartiles
                const oneYearPeriod = 52; // Approximate 52 weeks in a year
                const rollingMedian = [];
                const rollingQ1 = [];
                const rollingQ3 = [];
                
                for (let i = 0; i < valuesCont.length; i++) {
                    const startIdx = Math.max(0, i - oneYearPeriod + 1);
                    const window = valuesCont.slice(startIdx, i + 1);
                    
                    if (window.length > 0) {
                        const sortedWindow = [...window].sort((a, b) => a - b);
                        const q1Idx = Math.floor(sortedWindow.length * 0.25);
                        const medianIdx = Math.floor(sortedWindow.length * 0.5);
                        const q3Idx = Math.floor(sortedWindow.length * 0.75);
                        
                        rollingQ1.push(sortedWindow[q1Idx]);
                        rollingMedian.push(sortedWindow[medianIdx]);
                        rollingQ3.push(sortedWindow[q3Idx]);
                    } else {
                        rollingQ1.push(null);
                        rollingMedian.push(null);
                        rollingQ3.push(null);
                    }
                }

                // Calculate quartiles for Continuing Claims (only if showing all data)
                let annotations = {};
                if (zoomMode === 'all') {
                    const sortedValues = [...valuesCont].sort((a, b) => a - b);
                    const q1 = sortedValues[Math.floor(sortedValues.length * 0.25)];
                    const median = sortedValues[Math.floor(sortedValues.length * 0.5)];
                    const q3 = sortedValues[Math.floor(sortedValues.length * 0.75)];
                    
                    annotations = {
                        q1Line: {
                            type: 'line', yMin: q1, yMax: q1,
                            borderColor: 'rgba(156, 163, 175, 0.4)', borderWidth: 1, borderDash: [2, 2],
                            label: { display: true, content: 'Q1', position: 'end', backgroundColor: 'rgba(0,0,0,0.5)', color: '#9ca3af', font: { size: 8 } }
                        },
                        medianLine: {
                            type: 'line', yMin: median, yMax: median,
                            borderColor: 'rgba(156, 163, 175, 0.6)', borderWidth: 1.5, borderDash: [4, 4],
                            label: { display: true, content: 'MEDIAN', position: 'end', backgroundColor: 'rgba(0,0,0,0.5)', color: '#9ca3af', font: { size: 8 } }
                        },
                        q3Line: {
                            type: 'line', yMin: q3, yMax: q3,
                            borderColor: 'rgba(156, 163, 175, 0.4)', borderWidth: 1, borderDash: [2, 2],
                            label: { display: true, content: 'Q3', position: 'end', backgroundColor: 'rgba(0,0,0,0.5)', color: '#9ca3af', font: { size: 8 } }
                        }
                    };
                }

                contClaimsChartInstance = new Chart(ctxContClaims, {
                    type: 'line',
                    data: {
                        labels: labelsCont,
                        datasets: [
                            // Fill area for Q1-Q3 band
                            {
                                label: 'Q3 (75th percentile)',
                                data: rollingQ3,
                                borderColor: 'rgba(239, 68, 68, 0.5)',
                                borderWidth: 1,
                                borderDash: [2, 2],
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                fill: 1,
                                pointRadius: 0,
                                tension: 0.1,
                                order: 0
                            },
                            {
                                label: 'Q1 (25th percentile)',
                                data: rollingQ1,
                                borderColor: 'rgba(239, 68, 68, 0.5)',
                                borderWidth: 1,
                                borderDash: [2, 2],
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                fill: false,
                                pointRadius: 0,
                                tension: 0.1,
                                order: 0
                            },
                            // 1-Year Median line
                            {
                                label: '1-Year Median',
                                data: rollingMedian,
                                borderColor: '#fbbf24',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                tension: 0.1,
                                order: 2
                            },
                            // Main data line (on top)
                            {
                                label: 'Continuing Claims',
                                data: valuesCont,
                                borderColor: '#8b5cf6',
                                borderWidth: 2,
                                fill: false,
                                pointRadius: 0,
                                tension: 0.1,
                                order: 3
                            }
                        ]
                    },
                    options: {
                        ...commonOptions,
                        plugins: {
                            ...commonOptions.plugins,
                            legend: { display: false },
                            annotation: {
                                annotations: annotations
                            }
                        },
                        scales: {
                            ...commonOptions.scales,
                            y: { 
                                ticks: { color: '#9ca3af', callback: v => (v / 1000000).toFixed(1) + 'M' },
                                grid: { color: 'rgba(156, 163, 175, 0.1)' }
                            }
                        }
                    }
                });
            }
        }

        window.sectorChartMode = 'cumulative';
        window.toggleSectorChartMode = function(mode) {
            window.sectorChartMode = mode;
            
            // Update UI buttons
            const cumBtn = document.getElementById('btn-sector-cumulative');
            const rocBtn = document.getElementById('btn-sector-rate');
            
            if (mode === 'cumulative') {
                cumBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-blue-600 text-white border border-blue-500 transition-all';
                rocBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-gray-800 text-gray-400 border border-gray-700 hover:bg-gray-700 transition-all';
            } else {
                rocBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-blue-600 text-white border border-blue-500 transition-all';
                cumBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-gray-800 text-gray-400 border border-gray-700 hover:bg-gray-700 transition-all';
            }
            
            if (window.lastEmploymentData) {
                const d = window.lastEmploymentData;
                processEmploymentData(
                    d.openings, d.unemployed, d.openingsRate, d.unrate, 
                    d.payrolls, d.employedLevel,
                    d.earnings, d.cpi, d.quits, d.eciWages, d.u6rate, d.participation,
                    d.finEmployment, d.gvtEmployment, d.eduEmployment, d.healthEmployment,
                    d.manEmployment, d.leisureEmployment, d.infoEmployment, d.profEmployment,
                    d.claims, d.contClaims, d.productivity
                );
            }
        };

        window.contClaimsZoomMode = 'postcovid'; // Default to post-covid
        window.toggleContClaimsZoom = function(mode) {
            window.contClaimsZoomMode = mode;
            
            // Update UI buttons
            const allBtn = document.getElementById('btn-contclaims-all');
            const postCovidBtn = document.getElementById('btn-contclaims-postcovid');
            
            if (mode === 'postcovid') {
                postCovidBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-blue-600 text-white border border-blue-500 transition-all';
                allBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-gray-800 text-gray-400 border border-gray-700 hover:bg-gray-700 transition-all';
            } else {
                allBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-blue-600 text-white border border-blue-500 transition-all';
                postCovidBtn.className = 'px-3 py-1 text-[10px] font-bold rounded bg-gray-800 text-gray-400 border border-gray-700 hover:bg-gray-700 transition-all';
            }
            
            if (window.lastEmploymentData) {
                const d = window.lastEmploymentData;
                processEmploymentData(
                    d.openings, d.unemployed, d.openingsRate, d.unrate, 
                    d.payrolls, d.employedLevel,
                    d.earnings, d.cpi, d.quits, d.eciWages, d.u6rate, d.participation,
                    d.finEmployment, d.gvtEmployment, d.eduEmployment, d.healthEmployment,
                    d.manEmployment, d.leisureEmployment, d.infoEmployment, d.profEmployment,
                    d.claims, d.contClaims, d.productivity
                );
            }
        };

        // --- TREASURY DATA LOGIC ---
        


        // Classify regime based on z-scores using gradient scoring
        // Uses weighted scoring where higher z-scores have more influence
        // Z-scores measure how many standard deviations above/below the 10-year mean
        function classifyRegime(growthZScore, inflationZScore) {
            const neutralBuffer = 0.25; // Buffer for neutral regime
            
            // Check for neutral regime first: both growth and inflation within ±0.25σ
            if (Math.abs(growthZScore) <= neutralBuffer && Math.abs(inflationZScore) <= neutralBuffer) {
                return 'Neutral';
            }
            
            // Gradient scoring: weight by z-score magnitude (squared to emphasize larger deviations)
            // Higher absolute z-scores contribute more to the classification
            
            // Calculate weighted scores for each quadrant
            // Disinflationary Boom: High growth, low inflation
            const disinflationaryBoomScore = Math.max(0, growthZScore) * Math.abs(growthZScore) + 
                                             Math.max(0, -inflationZScore) * Math.abs(inflationZScore);
            
            // Inflationary Boom: High growth, high inflation
            const inflationaryBoomScore = Math.max(0, growthZScore) * Math.abs(growthZScore) + 
                                          Math.max(0, inflationZScore) * Math.abs(inflationZScore);
            
            // Disinflationary Bust: Low growth, low inflation
            const disinflationaryBustScore = Math.max(0, -growthZScore) * Math.abs(growthZScore) + 
                                            Math.max(0, -inflationZScore) * Math.abs(inflationZScore);
            
            // Inflationary Bust: Low growth, high inflation
            const inflationaryBustScore = Math.max(0, -growthZScore) * Math.abs(growthZScore) + 
                                         Math.max(0, inflationZScore) * Math.abs(inflationZScore);
            
            // Find the quadrant with the highest score
            const scores = {
                'Disinflationary Boom': disinflationaryBoomScore,
                'Inflationary Boom': inflationaryBoomScore,
                'Disinflationary Bust': disinflationaryBustScore,
                'Inflationary Bust': inflationaryBustScore
            };
            
            // Return the regime with the highest weighted score
            return Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b);
        }
        
        // Validate regime calibration by showing z-score distribution
        function validateRegimeCalibration(regimeData) {
            const growthZScores = regimeData.map(d => d.growthZScore || 0).filter(z => !isNaN(z));
            const inflationZScores = regimeData.map(d => d.inflationZScore || 0).filter(z => !isNaN(z));
            
            const stats = {
                growth: {
                    min: Math.min(...growthZScores),
                    max: Math.max(...growthZScores),
                    mean: growthZScores.reduce((a, b) => a + b, 0) / growthZScores.length,
                    median: growthZScores.sort((a, b) => a - b)[Math.floor(growthZScores.length / 2)],
                    stdDev: Math.sqrt(growthZScores.reduce((sum, val) => sum + Math.pow(val - (growthZScores.reduce((a, b) => a + b, 0) / growthZScores.length), 2), 0) / growthZScores.length)
                },
                inflation: {
                    min: Math.min(...inflationZScores),
                    max: Math.max(...inflationZScores),
                    mean: inflationZScores.reduce((a, b) => a + b, 0) / inflationZScores.length,
                    median: inflationZScores.sort((a, b) => a - b)[Math.floor(inflationZScores.length / 2)],
                    stdDev: Math.sqrt(inflationZScores.reduce((sum, val) => sum + Math.pow(val - (inflationZScores.reduce((a, b) => a + b, 0) / inflationZScores.length), 2), 0) / inflationZScores.length)
                }
            };
            
            console.log('Regime Calibration Validation (Z-Scores with Gradient Scoring):', stats);
            return stats;
        }
        
        // Display regime calibration statistics
        function displayRegimeCalibrationStats(stats) {
            const container = document.getElementById('regimeCalibrationStats');
            if (!container) return;
            
            container.innerHTML = `
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
                    <div class="bg-gray-900/30 rounded-lg p-3 border border-gray-700/20">
                        <div class="text-xs text-gray-400 mb-1">Growth Z-Score Range</div>
                        <div class="text-sm text-white font-semibold">${stats.growth.min.toFixed(2)}σ to ${stats.growth.max.toFixed(2)}σ</div>
                        <div class="text-xs text-gray-500 mt-1">Mean: ${stats.growth.mean.toFixed(2)}σ</div>
                        <div class="text-xs text-gray-500 mt-1">Std Dev: ${stats.growth.stdDev.toFixed(2)}σ</div>
                    </div>
                    <div class="bg-gray-900/30 rounded-lg p-3 border border-gray-700/20">
                        <div class="text-xs text-gray-400 mb-1">Growth Statistics</div>
                        <div class="text-sm text-white font-semibold">Median: ${stats.growth.median.toFixed(2)}σ</div>
                        <div class="text-xs text-gray-500 mt-1">Higher z-scores weighted more</div>
                        <div class="text-xs text-gray-500 mt-1">in classification</div>
                    </div>
                    <div class="bg-gray-900/30 rounded-lg p-3 border border-gray-700/20">
                        <div class="text-xs text-gray-400 mb-1">Inflation Z-Score Range</div>
                        <div class="text-sm text-white font-semibold">${stats.inflation.min.toFixed(2)}σ to ${stats.inflation.max.toFixed(2)}σ</div>
                        <div class="text-xs text-gray-500 mt-1">Mean: ${stats.inflation.mean.toFixed(2)}σ</div>
                        <div class="text-xs text-gray-500 mt-1">Std Dev: ${stats.inflation.stdDev.toFixed(2)}σ</div>
                    </div>
                    <div class="bg-gray-900/30 rounded-lg p-3 border border-gray-700/20">
                        <div class="text-xs text-gray-400 mb-1">Inflation Statistics</div>
                        <div class="text-sm text-white font-semibold">Median: ${stats.inflation.median.toFixed(2)}σ</div>
                        <div class="text-xs text-gray-500 mt-1">Gradient scoring: no</div>
                        <div class="text-xs text-gray-500 mt-1">hard thresholds</div>
                    </div>
                </div>
            `;
        }
        
        // Calculate comprehensive regime metrics
        function calculateRegimeMetrics(regimeData, current, currentRegime, currentGrowthZ, currentInflationZ) {
            // 1. Calculate Regime Strength (confidence score 0-100%)
            // Based on how far from boundaries and how clear the classification is
            const neutralBuffer = 0.25;
            let strength = 0;
            
            // Calculate distance from neutral zone
            const distFromNeutral = Math.sqrt(Math.pow(currentGrowthZ, 2) + Math.pow(currentInflationZ, 2));
            
            // Calculate how "deep" we are in the current regime quadrant
            // For each regime, calculate the score that led to classification
            const scores = {
                'Disinflationary Boom': Math.max(0, currentGrowthZ) * Math.abs(currentGrowthZ) + Math.max(0, -currentInflationZ) * Math.abs(currentInflationZ),
                'Inflationary Boom': Math.max(0, currentGrowthZ) * Math.abs(currentGrowthZ) + Math.max(0, currentInflationZ) * Math.abs(currentInflationZ),
                'Disinflationary Bust': Math.max(0, -currentGrowthZ) * Math.abs(currentGrowthZ) + Math.max(0, -currentInflationZ) * Math.abs(currentInflationZ),
                'Inflationary Bust': Math.max(0, -currentGrowthZ) * Math.abs(currentGrowthZ) + Math.max(0, currentInflationZ) * Math.abs(currentInflationZ),
                'Neutral': 0
            };
            
            const currentScore = scores[currentRegime] || 0;
            const maxScore = Math.max(...Object.values(scores));
            
            if (currentRegime === 'Neutral') {
                // For neutral, strength is based on how close to center
                strength = Math.max(0, 100 - (distFromNeutral / neutralBuffer) * 100);
            } else {
                // For other regimes, strength is based on score dominance and distance from boundaries
                const scoreRatio = maxScore > 0 ? currentScore / maxScore : 0;
                const boundaryDistance = Math.min(
                    Math.abs(currentGrowthZ - 0), // Distance from growth boundary
                    Math.abs(currentInflationZ - 0) // Distance from inflation boundary
                );
                
                // Base strength: 60% from score dominance, 40% from distance from boundary
                strength = (scoreRatio * 60) + (Math.min(boundaryDistance, 2) / 2 * 40);
                
                // Apply transition risk penalty: if close to boundary (high transition risk), reduce strength
                // This ensures strength and transition risk are inversely related
                if (boundaryDistance < 0.3) {
                    // Very close to boundary (High transition risk): reduce strength by up to 50%
                    const penalty = (0.3 - boundaryDistance) / 0.3; // 0 to 1 penalty factor
                    strength = strength * (1 - penalty * 0.5); // Reduce by up to 50%
                } else if (boundaryDistance < 0.6) {
                    // Medium distance (Medium transition risk): reduce strength by up to 25%
                    const penalty = (0.6 - boundaryDistance) / 0.6; // 0 to 1 penalty factor
                    strength = strength * (1 - penalty * 0.25); // Reduce by up to 25%
                }
                // Low transition risk (> 0.6σ): no penalty, full strength
            }
            strength = Math.max(0, Math.min(100, strength));
            
            // 2. Calculate Expected Duration based on historical patterns
            const historicalDurations = [];
            let currentRun = 1;
            for (let i = 1; i < regimeData.length; i++) {
                if (regimeData[i].regime === regimeData[i-1].regime) {
                    currentRun++;
                } else {
                    if (currentRun > 0) {
                        historicalDurations.push({
                            regime: regimeData[i-1].regime,
                            duration: currentRun
                        });
                    }
                    currentRun = 1;
                }
            }
            // Add final run
            if (currentRun > 0) {
                historicalDurations.push({
                    regime: regimeData[regimeData.length - 1].regime,
                    duration: currentRun
                });
            }
            
            // Calculate average duration for current regime
            const regimeDurations = historicalDurations.filter(d => d.regime === currentRegime).map(d => d.duration);
            const avgDuration = regimeDurations.length > 0 
                ? Math.round(regimeDurations.reduce((a, b) => a + b, 0) / regimeDurations.length)
                : 12; // Default 12 months if no history
            const medianDuration = regimeDurations.length > 0
                ? regimeDurations.sort((a, b) => a - b)[Math.floor(regimeDurations.length / 2)]
                : 12;
            
            const expectedDuration = `${medianDuration}-${avgDuration} months`;
            
            // 3. Calculate Transition Risk (distance to nearest boundary)
            // Calculate distance to each quadrant boundary
            const distToGrowthBoundary = Math.abs(currentGrowthZ);
            const distToInflationBoundary = Math.abs(currentInflationZ);
            const minDistance = Math.min(distToGrowthBoundary, distToInflationBoundary);
            
            let transitionRisk = 'Low';
            let transitionRiskValue = minDistance;
            if (minDistance < 0.3) {
                transitionRisk = 'High';
            } else if (minDistance < 0.6) {
                transitionRisk = 'Medium';
            }
            
            const transitionRiskText = `${transitionRisk} (${minDistance.toFixed(2)}σ)`;
            
            // 4. Calculate Transition Probability Matrix
            let transitionResult = calculateTransitionProbabilities(regimeData, currentRegime);
            let rawTransitionProbs = transitionResult.probabilities; // Keep raw probabilities for display with CIs
            let confidenceIntervals = transitionResult.confidenceIntervals;
            let transitionProbs = { ...rawTransitionProbs }; // Create copy for adjustment
            const totalTransitions = transitionResult.totalTransitions;
            
            // Adjust probabilities based on transition risk and proximity to specific boundaries
            // Weight transitions based on which boundary (growth or inflation) is closest
            const stayProbability = transitionProbs[currentRegime] || 0;
            
            // Determine which boundary is closer and which regimes require crossing that boundary
            const isCloserToGrowthBoundary = distToGrowthBoundary < distToInflationBoundary;
            const isCloserToInflationBoundary = distToInflationBoundary < distToGrowthBoundary;
            
            // Define which transitions require crossing which boundary, considering DIRECTION
            // Growth boundary transitions: crossing growth = 0 (high to low growth or vice versa)
            // Inflation boundary transitions: crossing inflation = 0 (high to low inflation or vice versa)
            const getBoundaryWeight = (fromRegime, toRegime) => {
                // Determine if this transition requires crossing growth boundary
                const crossesGrowthBoundary = (
                    (fromRegime === 'Disinflationary Boom' && (toRegime === 'Disinflationary Bust' || toRegime === 'Inflationary Bust')) ||
                    (fromRegime === 'Inflationary Boom' && (toRegime === 'Disinflationary Bust' || toRegime === 'Inflationary Bust')) ||
                    (fromRegime === 'Disinflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Boom')) ||
                    (fromRegime === 'Inflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Boom'))
                );
                
                // Determine if this transition requires crossing inflation boundary
                const crossesInflationBoundary = (
                    (fromRegime === 'Disinflationary Boom' && (toRegime === 'Inflationary Boom' || toRegime === 'Inflationary Bust')) ||
                    (fromRegime === 'Disinflationary Bust' && (toRegime === 'Inflationary Boom' || toRegime === 'Inflationary Bust')) ||
                    (fromRegime === 'Inflationary Boom' && (toRegime === 'Disinflationary Boom' || toRegime === 'Disinflationary Bust')) ||
                    (fromRegime === 'Inflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Disinflationary Bust'))
                );
                
                // Determine direction of transition for growth
                const requiresGrowthToDecrease = (
                    (fromRegime === 'Disinflationary Boom' && (toRegime === 'Disinflationary Bust' || toRegime === 'Inflationary Bust')) ||
                    (fromRegime === 'Inflationary Boom' && (toRegime === 'Disinflationary Bust' || toRegime === 'Inflationary Bust'))
                );
                const requiresGrowthToIncrease = (
                    (fromRegime === 'Disinflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Boom')) ||
                    (fromRegime === 'Inflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Boom'))
                );
                
                // Determine direction of transition for inflation
                const requiresInflationToIncrease = (
                    (fromRegime === 'Disinflationary Boom' && (toRegime === 'Inflationary Boom' || toRegime === 'Inflationary Bust')) ||
                    (fromRegime === 'Disinflationary Bust' && (toRegime === 'Inflationary Boom' || toRegime === 'Inflationary Bust'))
                );
                const requiresInflationToDecrease = (
                    (fromRegime === 'Inflationary Boom' && (toRegime === 'Disinflationary Boom' || toRegime === 'Disinflationary Bust')) ||
                    (fromRegime === 'Inflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Disinflationary Bust'))
                );
                
                // Calculate directional penalty based on current position
                // If growth is very high (+2σ), transitions requiring growth to decrease should be penalized
                // If growth is very low (-2σ), transitions requiring growth to increase should be penalized
                let growthDirectionPenalty = 1.0;
                if (requiresGrowthToDecrease && currentGrowthZ > 1.0) {
                    // Growth is high, but transition requires it to decrease - penalize based on how high
                    const penaltyStrength = Math.min(1.0, (currentGrowthZ - 1.0) / 1.0); // Penalty increases from 1σ to 2σ+
                    growthDirectionPenalty = 1.0 - (penaltyStrength * 0.7); // Reduce weight by up to 70%
                } else if (requiresGrowthToIncrease && currentGrowthZ < -1.0) {
                    // Growth is low, but transition requires it to increase - penalize based on how low
                    const penaltyStrength = Math.min(1.0, (Math.abs(currentGrowthZ) - 1.0) / 1.0);
                    growthDirectionPenalty = 1.0 - (penaltyStrength * 0.7);
                }
                
                // Same for inflation
                let inflationDirectionPenalty = 1.0;
                if (requiresInflationToDecrease && currentInflationZ > 1.0) {
                    const penaltyStrength = Math.min(1.0, (currentInflationZ - 1.0) / 1.0);
                    inflationDirectionPenalty = 1.0 - (penaltyStrength * 0.7);
                } else if (requiresInflationToIncrease && currentInflationZ < -1.0) {
                    const penaltyStrength = Math.min(1.0, (Math.abs(currentInflationZ) - 1.0) / 1.0);
                    inflationDirectionPenalty = 1.0 - (penaltyStrength * 0.7);
                }
                
                // Apply directional penalties
                let baseWeight = 1.0;
                if (isCloserToGrowthBoundary && crossesGrowthBoundary) {
                    baseWeight = 2.0; // Higher weight for transitions across the closer boundary
                } else if (isCloserToInflationBoundary && crossesInflationBoundary) {
                    baseWeight = 2.0;
                } else if (crossesGrowthBoundary || crossesInflationBoundary) {
                    baseWeight = 1.0; // Normal weight for other boundary crossings
                } else {
                    baseWeight = 0.5; // Lower weight for transitions that don't cross the closer boundary
                }
                
                // Apply directional penalties
                if (crossesGrowthBoundary) {
                    baseWeight *= growthDirectionPenalty;
                }
                if (crossesInflationBoundary) {
                    baseWeight *= inflationDirectionPenalty;
                }
                
                return Math.max(0.1, baseWeight); // Minimum weight of 0.1 to avoid zero probabilities
            };
            
            if (transitionRisk === 'High') {
                // High transition risk: reduce stay probability by 30-50%, redistribute to transitions
                const reductionFactor = 0.4; // Reduce stay probability by 40%
                const reducedStay = stayProbability * (1 - reductionFactor);
                const probabilityToRedistribute = stayProbability - reducedStay;
                
                // Redistribute to other regimes, weighted by boundary proximity
                const transitionProbsExcludingCurrent = { ...transitionProbs };
                delete transitionProbsExcludingCurrent[currentRegime];
                
                // Calculate weighted probabilities based on boundary proximity
                const weightedProbs = {};
                let totalWeightedProb = 0;
                
                Object.keys(transitionProbsExcludingCurrent).forEach(regime => {
                    const originalProb = transitionProbsExcludingCurrent[regime];
                    const boundaryWeight = getBoundaryWeight(currentRegime, regime);
                    const weightedProb = originalProb * boundaryWeight;
                    weightedProbs[regime] = weightedProb;
                    totalWeightedProb += weightedProb;
                });
                
                if (totalWeightedProb > 0) {
                    // Redistribute based on weighted probabilities
                    Object.keys(transitionProbsExcludingCurrent).forEach(regime => {
                        const weightedProb = weightedProbs[regime];
                        const additionalProb = (weightedProb / totalWeightedProb) * probabilityToRedistribute;
                        transitionProbs[regime] = (transitionProbs[regime] || 0) + additionalProb;
                    });
                } else {
                    // If no transition history, distribute based on boundary weights
                    const regimes = Object.keys(transitionProbsExcludingCurrent);
                    let totalWeight = 0;
                    regimes.forEach(regime => {
                        totalWeight += getBoundaryWeight(currentRegime, regime);
                    });
                    if (totalWeight > 0) {
                        regimes.forEach(regime => {
                            const weight = getBoundaryWeight(currentRegime, regime);
                            const prob = (weight / totalWeight) * probabilityToRedistribute;
                            transitionProbs[regime] = (transitionProbs[regime] || 0) + prob;
                        });
                    }
                }
                
                transitionProbs[currentRegime] = reducedStay;
            } else if (transitionRisk === 'Medium') {
                // Medium transition risk: reduce stay probability by 15-25%
                const reductionFactor = 0.2; // Reduce stay probability by 20%
                const reducedStay = stayProbability * (1 - reductionFactor);
                const probabilityToRedistribute = stayProbability - reducedStay;
                
                const transitionProbsExcludingCurrent = { ...transitionProbs };
                delete transitionProbsExcludingCurrent[currentRegime];
                
                // Calculate weighted probabilities based on boundary proximity
                const weightedProbs = {};
                let totalWeightedProb = 0;
                
                Object.keys(transitionProbsExcludingCurrent).forEach(regime => {
                    const originalProb = transitionProbsExcludingCurrent[regime];
                    const boundaryWeight = getBoundaryWeight(currentRegime, regime);
                    const weightedProb = originalProb * boundaryWeight;
                    weightedProbs[regime] = weightedProb;
                    totalWeightedProb += weightedProb;
                });
                
                if (totalWeightedProb > 0) {
                    // Redistribute based on weighted probabilities
                    Object.keys(transitionProbsExcludingCurrent).forEach(regime => {
                        const weightedProb = weightedProbs[regime];
                        const additionalProb = (weightedProb / totalWeightedProb) * probabilityToRedistribute;
                        transitionProbs[regime] = (transitionProbs[regime] || 0) + additionalProb;
                    });
                }
                
                transitionProbs[currentRegime] = reducedStay;
            }
            // Low risk: keep original probabilities
            
            // Recalculate stay probability after adjustment
            const adjustedStayProbability = transitionProbs[currentRegime] || 0;
            
            // Find most likely next regime (excluding current regime)
            const transitionProbsExcludingCurrent = { ...transitionProbs };
            delete transitionProbsExcludingCurrent[currentRegime];
            
            // Find most likely transition (excluding staying in current)
            const nextRegime = Object.keys(transitionProbsExcludingCurrent).reduce((a, b) => 
                transitionProbsExcludingCurrent[a] > transitionProbsExcludingCurrent[b] ? a : b
            );
            const nextRegimeProb = transitionProbsExcludingCurrent[nextRegime] || 0;
            
            // If staying is most likely, show that and the next most likely transition
            let nextRegimeDisplay = nextRegime;
            let nextRegimeProbDisplay = (nextRegimeProb * 100).toFixed(1) + '%';
            
            if (adjustedStayProbability > nextRegimeProb) {
                // Staying is most likely - show "Likely to Continue" with stay probability
                // and show the most likely transition below
                nextRegimeDisplay = 'Likely to Continue';
                nextRegimeProbDisplay = (adjustedStayProbability * 100).toFixed(1) + '%';
            }
            
            return {
                strength: Math.round(strength),
                expectedDuration: expectedDuration,
                transitionRisk: transitionRiskText,
                transitionRiskValue: transitionRiskValue,
                nextRegime: nextRegimeDisplay,
                nextRegimeProb: nextRegimeProbDisplay,
                mostLikelyTransition: nextRegime, // The actual next regime (excluding current)
                mostLikelyTransitionProb: nextRegimeProb,
                stayProbability: adjustedStayProbability, // Use adjusted probability
                transitionProbs: transitionProbs, // Adjusted probabilities for forward allocation
                rawTransitionProbs: rawTransitionProbs, // Raw probabilities for display with confidence intervals
                confidenceIntervals: confidenceIntervals,
                totalTransitions: totalTransitions
            };
        }
        
        // Calculate confidence interval for a proportion using Bayesian posterior (Beta distribution)
        // Uses Beta(alpha + successes, beta + failures) as posterior
        function calculateBayesianConfidenceInterval(successes, total, priorAlpha, priorBeta, confidenceLevel = 0.95) {
            const failures = total - successes;
            
            // Posterior parameters (Beta distribution)
            const posteriorAlpha = priorAlpha + successes;
            const posteriorBeta = priorBeta + failures;
            
            // Posterior mean (point estimate)
            const posteriorTotal = posteriorAlpha + posteriorBeta;
            const posteriorMean = posteriorAlpha / posteriorTotal;
            
            // Calculate credible interval using Beta distribution quantiles
            // For Beta distribution, we can approximate with normal if sample is large enough
            // Otherwise use Beta quantile approximation
            const z = confidenceLevel === 0.95 ? 1.96 : confidenceLevel === 0.90 ? 1.645 : 1.96;
            
            // Use normal approximation for Beta (works well when alpha and beta are > 5)
            const variance = (posteriorAlpha * posteriorBeta) / 
                           ((posteriorTotal * posteriorTotal) * (posteriorTotal + 1));
            const stdDev = Math.sqrt(variance);
            
            let lower, upper;
            if (posteriorAlpha > 5 && posteriorBeta > 5) {
                // Normal approximation
                lower = Math.max(0, posteriorMean - z * stdDev);
                upper = Math.min(1, posteriorMean + z * stdDev);
            } else {
                // For small samples, use Beta quantile approximation
                // Beta quantiles can be approximated using inverse Beta function
                // For simplicity, we'll use a more conservative interval
                const alphaLevel = (1 - confidenceLevel) / 2;
                // Approximate using Wilson-like adjustment
                const adjustedN = posteriorTotal;
                const adjustedP = posteriorMean;
                const denominator = 1 + (z * z) / adjustedN;
                const center = (adjustedP + (z * z) / (2 * adjustedN)) / denominator;
                const margin = (z / denominator) * Math.sqrt((adjustedP * (1 - adjustedP) / adjustedN) + (z * z) / (4 * adjustedN * adjustedN));
                lower = Math.max(0, center - margin);
                upper = Math.min(1, center + margin);
            }
            
            return {
                lower: lower,
                upper: upper,
                width: upper - lower,
                center: posteriorMean,
                priorWeight: (priorAlpha + priorBeta) / (posteriorTotal),
                dataWeight: total / (posteriorTotal)
            };
        }
        
        // Calculate confidence interval for a proportion (Wilson score interval) - kept for backward compatibility
        function calculateConfidenceInterval(successes, total, confidenceLevel = 0.95) {
            if (total === 0) {
                return { lower: 0, upper: 1, width: 1 };
            }
            
            const z = confidenceLevel === 0.95 ? 1.96 : confidenceLevel === 0.90 ? 1.645 : 1.96;
            const p = successes / total;
            const n = total;
            
            // Wilson score interval (more accurate for small samples)
            const denominator = 1 + (z * z) / n;
            const center = (p + (z * z) / (2 * n)) / denominator;
            const margin = (z / denominator) * Math.sqrt((p * (1 - p) / n) + (z * z) / (4 * n * n));
            
            const lower = Math.max(0, center - margin);
            const upper = Math.min(1, center + margin);
            
            return {
                lower: lower,
                upper: upper,
                width: upper - lower,
                center: p
            };
        }
        
        // Calculate transition probability matrix from historical data with confidence intervals
        function calculateTransitionProbabilities(regimeData, currentRegime) {
            const allRegimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            const transitions = {};
            
            // Initialize transition counts
            allRegimes.forEach(from => {
                transitions[from] = {};
                allRegimes.forEach(to => {
                    transitions[from][to] = 0;
                });
            });
            
            // Count transitions
            for (let i = 0; i < regimeData.length - 1; i++) {
                const from = regimeData[i].regime;
                const to = regimeData[i + 1].regime;
                if (transitions[from] && transitions[from][to] !== undefined) {
                    transitions[from][to]++;
                }
            }
            
            // Calculate probabilities for current regime using Bayesian approach
            const currentTransitions = transitions[currentRegime] || {};
            const totalTransitions = Object.values(currentTransitions).reduce((a, b) => a + b, 0);
            
            // Define Bayesian prior based on economic logic
            // Prior strength: how much weight to give to prior vs data
            // Higher values = stronger prior (more conservative, less influenced by small samples)
            const priorStrength = Math.max(2, Math.min(10, Math.floor(totalTransitions / 5))); // Adaptive: stronger prior when data is sparse
            
            // Informed prior: some transitions are more likely than others
            // For example, staying in same regime is often more likely than transitioning
            // Adjacent quadrants (e.g., Disinflationary Boom -> Inflationary Boom) are more likely than opposite quadrants
            const informedPrior = {};
            allRegimes.forEach(toRegime => {
                if (toRegime === currentRegime) {
                    // Prior: staying in same regime is more likely (40% prior weight)
                    informedPrior[toRegime] = {
                        alpha: priorStrength * 0.4,
                        beta: priorStrength * 0.6
                    };
                } else {
                    // Prior: transitioning to other regimes (distributed among 4 other regimes)
                    // Adjacent transitions get slightly higher prior
                    const isAdjacent = (
                        (currentRegime === 'Disinflationary Boom' && (toRegime === 'Inflationary Boom' || toRegime === 'Disinflationary Bust')) ||
                        (currentRegime === 'Inflationary Boom' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Bust')) ||
                        (currentRegime === 'Disinflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Bust')) ||
                        (currentRegime === 'Inflationary Bust' && (toRegime === 'Inflationary Boom' || toRegime === 'Disinflationary Bust')) ||
                        (currentRegime === 'Neutral' && toRegime !== 'Neutral')
                    );
                    const priorWeight = isAdjacent ? 0.2 : 0.15; // Adjacent gets 20%, opposite gets 15%
                    informedPrior[toRegime] = {
                        alpha: priorStrength * priorWeight,
                        beta: priorStrength * (1 - priorWeight)
                    };
                }
            });
            
            const probabilities = {};
            const confidenceIntervals = {};
            const sampleSizes = {};
            
            allRegimes.forEach(regime => {
                const count = currentTransitions[regime] || 0;
                sampleSizes[regime] = count;
                
                // Bayesian update: use prior + data
                const prior = informedPrior[regime];
                const priorAlpha = prior.alpha;
                const priorBeta = prior.beta;
                
                // Calculate Bayesian confidence interval
                const ci = calculateBayesianConfidenceInterval(count, totalTransitions, priorAlpha, priorBeta, 0.95);
                confidenceIntervals[regime] = {
                    ...ci,
                    sampleSize: count
                };
                
                // Posterior mean is our probability estimate
                probabilities[regime] = ci.center;
            });
            
            // Normalize probabilities to sum to 1 (Bayesian posterior should already, but ensure it)
            const probSum = Object.values(probabilities).reduce((a, b) => a + b, 0);
            if (probSum > 0) {
                allRegimes.forEach(regime => {
                    probabilities[regime] = probabilities[regime] / probSum;
                    // Adjust confidence interval center to match normalized probability
                    if (confidenceIntervals[regime]) {
                        const adjustment = probabilities[regime] / confidenceIntervals[regime].center;
                        confidenceIntervals[regime].center = probabilities[regime];
                        confidenceIntervals[regime].lower *= adjustment;
                        confidenceIntervals[regime].upper *= adjustment;
                        confidenceIntervals[regime].width = confidenceIntervals[regime].upper - confidenceIntervals[regime].lower;
                    }
                });
            }
            
            // Add smoothing: blend with overall transition probabilities
            // Calculate overall transition probabilities
            const overallTransitions = {};
            allRegimes.forEach(from => {
                const fromTotal = Object.values(transitions[from]).reduce((a, b) => a + b, 0);
                allRegimes.forEach(to => {
                    if (!overallTransitions[to]) overallTransitions[to] = 0;
                    if (fromTotal > 0) {
                        overallTransitions[to] += transitions[from][to] / fromTotal;
                    }
                });
            });
            
            // Normalize overall probabilities
            const overallTotal = Object.values(overallTransitions).reduce((a, b) => a + b, 0);
            allRegimes.forEach(regime => {
                if (overallTotal > 0) {
                    overallTransitions[regime] = overallTransitions[regime] / overallTotal;
                } else {
                    overallTransitions[regime] = 1 / allRegimes.length;
                }
            });
            
            // Blend: 70% Bayesian posterior (regime-specific), 30% overall (smoothing)
            // This adds another layer of smoothing using overall transition patterns
            allRegimes.forEach(regime => {
                const bayesianProb = probabilities[regime];
                probabilities[regime] = 0.7 * bayesianProb + 0.3 * overallTransitions[regime];
            });
            
            // Adjust confidence intervals for blended probabilities
            // The blending reduces uncertainty, so we can tighten the intervals slightly
            allRegimes.forEach(regime => {
                const originalCI = confidenceIntervals[regime];
                const blendedProb = probabilities[regime];
                const originalProb = originalCI.center;
                
                // Scale the confidence interval width based on how much the probability changed
                // If probability changed significantly, uncertainty is higher
                const probChange = Math.abs(blendedProb - originalProb);
                const widthAdjustment = 1 - (probChange * 0.3); // Reduce width by up to 30% if probability changed
                
                const adjustedWidth = originalCI.width * widthAdjustment;
                const adjustedLower = Math.max(0, blendedProb - adjustedWidth / 2);
                const adjustedUpper = Math.min(1, blendedProb + adjustedWidth / 2);
                
                confidenceIntervals[regime] = {
                    lower: adjustedLower,
                    upper: adjustedUpper,
                    width: adjustedWidth,
                    center: blendedProb,
                    sampleSize: sampleSizes[regime],
                    totalSamples: totalTransitions,
                    priorWeight: originalCI.priorWeight,
                    dataWeight: originalCI.dataWeight
                };
            });
            
            return {
                probabilities: probabilities,
                confidenceIntervals: confidenceIntervals,
                totalTransitions: totalTransitions
            };
        }
        
        // Calculate transition probabilities for ALL regimes (not just current)
        function calculateAllRegimeTransitions(regimeData) {
            const allRegimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            const transitions = {};
            const allProbabilities = {};
            const allConfidenceIntervals = {};
            const allTotalTransitions = {};
            
            // Initialize transition counts
            allRegimes.forEach(from => {
                transitions[from] = {};
                allRegimes.forEach(to => {
                    transitions[from][to] = 0;
                });
            });
            
            // Count transitions
            for (let i = 0; i < regimeData.length - 1; i++) {
                const from = regimeData[i].regime;
                const to = regimeData[i + 1].regime;
                if (transitions[from] && transitions[from][to] !== undefined) {
                    transitions[from][to]++;
                }
            }
            
            // Calculate probabilities for each regime
            allRegimes.forEach(fromRegime => {
                const fromTransitions = transitions[fromRegime] || {};
                const totalTransitions = Object.values(fromTransitions).reduce((a, b) => a + b, 0);
                allTotalTransitions[fromRegime] = totalTransitions;
                
                // Define Bayesian prior
                const priorStrength = Math.max(2, Math.min(10, Math.floor(totalTransitions / 5)));
                const informedPrior = {};
                
                allRegimes.forEach(toRegime => {
                    if (toRegime === fromRegime) {
                        informedPrior[toRegime] = {
                            alpha: priorStrength * 0.4,
                            beta: priorStrength * 0.6
                        };
                    } else {
                        const isAdjacent = (
                            (fromRegime === 'Disinflationary Boom' && (toRegime === 'Inflationary Boom' || toRegime === 'Disinflationary Bust')) ||
                            (fromRegime === 'Inflationary Boom' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Bust')) ||
                            (fromRegime === 'Disinflationary Bust' && (toRegime === 'Disinflationary Boom' || toRegime === 'Inflationary Bust')) ||
                            (fromRegime === 'Inflationary Bust' && (toRegime === 'Inflationary Boom' || toRegime === 'Disinflationary Bust')) ||
                            (fromRegime === 'Neutral' && toRegime !== 'Neutral')
                        );
                        const priorWeight = isAdjacent ? 0.2 : 0.15;
                        informedPrior[toRegime] = {
                            alpha: priorStrength * priorWeight,
                            beta: priorStrength * (1 - priorWeight)
                        };
                    }
                });
                
                const probabilities = {};
                const confidenceIntervals = {};
                const sampleSizes = {};
                
                allRegimes.forEach(toRegime => {
                    const count = fromTransitions[toRegime] || 0;
                    sampleSizes[toRegime] = count;
                    
                    const prior = informedPrior[toRegime];
                    const ci = calculateBayesianConfidenceInterval(count, totalTransitions, prior.alpha, prior.beta, 0.95);
                    confidenceIntervals[toRegime] = {
                        ...ci,
                        sampleSize: count
                    };
                    probabilities[toRegime] = ci.center;
                });
                
                // Normalize probabilities
                const probSum = Object.values(probabilities).reduce((a, b) => a + b, 0);
                if (probSum > 0) {
                    allRegimes.forEach(toRegime => {
                        probabilities[toRegime] = probabilities[toRegime] / probSum;
                        if (confidenceIntervals[toRegime]) {
                            const adjustment = probabilities[toRegime] / confidenceIntervals[toRegime].center;
                            confidenceIntervals[toRegime].center = probabilities[toRegime];
                            confidenceIntervals[toRegime].lower *= adjustment;
                            confidenceIntervals[toRegime].upper *= adjustment;
                            confidenceIntervals[toRegime].width = confidenceIntervals[toRegime].upper - confidenceIntervals[toRegime].lower;
                        }
                    });
                }
                
                allProbabilities[fromRegime] = probabilities;
                allConfidenceIntervals[fromRegime] = confidenceIntervals;
            });
            
            return {
                probabilities: allProbabilities,
                confidenceIntervals: allConfidenceIntervals,
                totalTransitions: allTotalTransitions,
                rawTransitions: transitions
            };
        }
        
        // Display full transition matrix for all regimes
        function displayFullTransitionMatrix(regimeData, currentRegime) {
            const container = document.getElementById('fullTransitionMatrix');
            if (!container) return;
            
            const allRegimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            const regimeColors = {
                'Disinflationary Boom': 'bg-green-900/30 text-green-400',
                'Inflationary Boom': 'bg-yellow-900/30 text-yellow-400',
                'Disinflationary Bust': 'bg-blue-900/30 text-blue-400',
                'Inflationary Bust': 'bg-red-900/30 text-red-400',
                'Neutral': 'bg-gray-700/30 text-gray-400'
            };
            
            const regimeShortNames = {
                'Disinflationary Boom': 'Disinf Boom',
                'Inflationary Boom': 'Infl Boom',
                'Disinflationary Bust': 'Disinf Bust',
                'Inflationary Bust': 'Infl Bust',
                'Neutral': 'Neutral'
            };
            
            // Calculate all transition probabilities
            const allTransitions = calculateAllRegimeTransitions(regimeData);
            const allProbabilities = allTransitions.probabilities;
            const allConfidenceIntervals = allTransitions.confidenceIntervals;
            const allTotalTransitions = allTransitions.totalTransitions;
            const rawTransitions = allTransitions.rawTransitions;
            
            // Create table HTML
            let html = '<div class="overflow-x-auto"><table class="w-full border-collapse text-xs">';
            
            // Header row
            html += '<thead><tr class="border-b border-gray-700">';
            html += '<th class="p-2 text-left text-gray-400 font-semibold sticky left-0 bg-gray-800 z-10">From → To</th>';
            allRegimes.forEach(toRegime => {
                html += `<th class="p-2 text-center ${regimeColors[toRegime]} font-semibold min-w-[100px]">${regimeShortNames[toRegime]}</th>`;
            });
            html += '<th class="p-2 text-center text-gray-400 font-semibold min-w-[80px]">Total</th>';
            html += '</tr></thead><tbody>';
            
            // Data rows
            allRegimes.forEach(fromRegime => {
                const isCurrent = fromRegime === currentRegime;
                html += `<tr class="border-b border-gray-700/50 ${isCurrent ? 'bg-blue-900/20' : ''}">`;
                
                // From regime (sticky column)
                html += `<td class="p-2 ${regimeColors[fromRegime]} font-semibold sticky left-0 bg-gray-800 z-10 ${isCurrent ? 'border-l-2 border-blue-500' : ''}">${regimeShortNames[fromRegime]}${isCurrent ? ' (Current)' : ''}</td>`;
                
                // Transition probabilities
                const probs = allProbabilities[fromRegime] || {};
                const cis = allConfidenceIntervals[fromRegime] || {};
                const total = allTotalTransitions[fromRegime] || 0;
                
                allRegimes.forEach(toRegime => {
                    const prob = probs[toRegime] || 0;
                    const probPercent = (prob * 100).toFixed(1);
                    const ci = cis[toRegime];
                    const count = rawTransitions[fromRegime]?.[toRegime] || 0;
                    
                    // Color intensity based on probability
                    let bgColor = 'bg-gray-800';
                    let textColor = 'text-gray-400';
                    if (prob >= 0.4) {
                        bgColor = 'bg-green-900/40';
                        textColor = 'text-green-300';
                    } else if (prob >= 0.2) {
                        bgColor = 'bg-yellow-900/40';
                        textColor = 'text-yellow-300';
                    } else if (prob >= 0.1) {
                        bgColor = 'bg-orange-900/40';
                        textColor = 'text-orange-300';
                    } else if (prob > 0) {
                        bgColor = 'bg-red-900/40';
                        textColor = 'text-red-300';
                    }
                    
                    // Highlight diagonal (staying in same regime)
                    if (fromRegime === toRegime) {
                        bgColor += ' border-2 border-blue-500/50';
                    }
                    
                    html += `<td class="p-2 text-center ${bgColor} ${textColor} relative group">`;
                    html += `<div class="font-bold">${probPercent}%</div>`;
                    if (count > 0) {
                        html += `<div class="text-[10px] text-gray-500 mt-0.5">(${count}x)</div>`;
                    }
                    if (ci && ci.lower !== undefined && ci.upper !== undefined) {
                        const ciLower = (ci.lower * 100).toFixed(1);
                        const ciUpper = (ci.upper * 100).toFixed(1);
                        html += `<div class="text-[9px] text-gray-600 mt-0.5 hidden group-hover:block absolute bg-gray-900 border border-gray-700 rounded p-1 z-20 shadow-lg whitespace-nowrap">`;
                        html += `CI: ${ciLower}% - ${ciUpper}%`;
                        html += `</div>`;
                    }
                    html += '</td>';
                });
                
                // Total transitions
                html += `<td class="p-2 text-center text-gray-400 font-semibold">${total}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Add summary note
            html += '<div class="mt-4 text-xs text-gray-500 space-y-1">';
            html += '<div><strong>Note:</strong> Values show probability of transitioning FROM regime (row) TO regime (column). Diagonal values (highlighted) show probability of staying in the same regime.</div>';
            html += '<div>Hover over cells to see 95% confidence intervals. Numbers in parentheses show observed transition counts.</div>';
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        // Display transition probability matrix with confidence intervals
        function displayTransitionMatrix(transitionProbs, currentRegime, confidenceIntervals = null, totalTransitions = null, regimeData = null) {
            const container = document.getElementById('transitionMatrix');
            if (!container) return;
            
            const allRegimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            const regimeColors = {
                'Disinflationary Boom': 'text-green-400',
                'Inflationary Boom': 'text-yellow-400',
                'Disinflationary Bust': 'text-blue-400',
                'Inflationary Bust': 'text-red-400',
                'Neutral': 'text-gray-400'
            };
            
            // Sort by probability (descending)
            const sorted = allRegimes.map(regime => ({
                regime,
                prob: transitionProbs[regime] || 0,
                ci: confidenceIntervals?.[regime] || null
            })).sort((a, b) => b.prob - a.prob);
            
            let html = '<div class="space-y-2">';
            if (totalTransitions !== null && regimeData) {
                // Calculate how many times we've been in the current regime historically
                const regimeOccurrences = regimeData.filter(d => d.regime === currentRegime).length;
                const regimeMonths = regimeOccurrences;
                
                // Calculate average regime duration
                let consecutiveCount = 0;
                let periodCount = 0;
                let currentPeriod = 0;
                for (let i = 0; i < regimeData.length; i++) {
                    if (regimeData[i].regime === currentRegime) {
                        currentPeriod++;
                    } else {
                        if (currentPeriod > 0) {
                            consecutiveCount += currentPeriod;
                            periodCount++;
                        }
                        currentPeriod = 0;
                    }
                }
                if (currentPeriod > 0) {
                    consecutiveCount += currentPeriod;
                    periodCount++;
                }
                const avgDuration = periodCount > 0 ? Math.round(consecutiveCount / periodCount) : regimeMonths;
                
                html += `<div class="text-xs text-gray-400 mb-2">
                    <div class="mb-1">
                        <strong>Sample Size:</strong> ${totalTransitions} transitions from ${currentRegime} (${regimeMonths} total months, avg ${avgDuration} months per period)
                    </div>
                    ${totalTransitions < 10 ? '<div class="text-yellow-400 text-xs italic">⚠️ Low sample size - probabilities are less reliable. Regimes are relatively stable (change infrequently), so transitions are rare events.</div>' : ''}
                    ${totalTransitions === 0 ? '<div class="text-red-400 text-xs italic">⚠️ No historical transitions - using smoothed probabilities from all regimes</div>' : ''}
                    <div class="text-gray-500 text-xs italic mt-1">Note: Probabilities shown are historical (Bayesian posterior estimates). Confidence intervals reflect uncertainty in historical transition patterns.</div>
                </div>`;
            } else if (totalTransitions !== null) {
                html += `<div class="text-xs text-gray-400 mb-2">Based on ${totalTransitions} historical transitions (95% confidence intervals)</div>`;
            }
            sorted.forEach(item => {
                const probPercent = (item.prob * 100).toFixed(1);
                const isCurrent = item.regime === currentRegime;
                const barWidth = Math.max(5, item.prob * 100); // Minimum 5% width for visibility
                const barColor = item.prob >= 0.3 ? 'bg-green-500' : item.prob >= 0.15 ? 'bg-yellow-500' : 'bg-red-500';
                
                // Confidence interval display
                let ciHtml = '';
                if (item.ci) {
                    const lowerPercent = (item.ci.lower * 100).toFixed(1);
                    const upperPercent = (item.ci.upper * 100).toFixed(1);
                    const ciWidth = item.ci.upper - item.ci.lower;
                    const ciColor = ciWidth < 0.2 ? 'text-green-400' : ciWidth < 0.4 ? 'text-yellow-400' : 'text-red-400';
                    const sampleSize = item.ci.sampleSize !== undefined ? item.ci.sampleSize : 0;
                    const sampleSizeNote = sampleSize < 5 ? ' (very uncertain)' : sampleSize < 10 ? ' (uncertain)' : '';
                    const priorWeight = item.ci.priorWeight !== undefined ? (item.ci.priorWeight * 100).toFixed(0) : null;
                    const bayesianNote = priorWeight ? ` [Bayesian: ${priorWeight}% prior, ${(100 - priorWeight).toFixed(0)}% data]` : '';
                    ciHtml = `
                        <div class="mt-1 text-xs ${ciColor}">
                            <i class="fas fa-chart-line mr-1"></i>
                            95% Credible Interval: ${lowerPercent}% - ${upperPercent}%
                            ${sampleSize > 0 ? ` (observed ${sampleSize}x${sampleSizeNote})` : ' (prior only)'}
                            ${bayesianNote}
                        </div>
                    `;
                }
                
                html += `
                    <div class="bg-gray-900/50 rounded-lg p-2 border ${isCurrent ? 'border-blue-500' : 'border-gray-700/30'}">
                        <div class="flex items-center justify-between mb-1">
                            <span class="${regimeColors[item.regime] || 'text-gray-400'} text-xs font-semibold">
                                ${item.regime}${isCurrent ? ' (Current)' : ''}
                            </span>
                            <span class="text-white text-xs font-bold">${probPercent}%</span>
                        </div>
                        <div class="h-2 bg-gray-700 rounded-full overflow-hidden mb-1">
                            <div class="h-full ${barColor} transition-all duration-500" style="width: ${barWidth}%"></div>
                        </div>
                        ${ciHtml}
                    </div>
                `;
            });
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        // Calculate monthly returns from price data
        function calculateMonthlyReturns(priceData) {
            const returns = [];
            for (let i = 1; i < priceData.length; i++) {
                const prevPrice = priceData[i - 1].value;
                const currPrice = priceData[i].value;
                if (prevPrice > 0) {
                    const monthlyReturn = (currPrice - prevPrice) / prevPrice;
                    returns.push({
                        date: priceData[i].date,
                        return: monthlyReturn
                    });
                }
            }
            return returns;
        }
        
        // Calculate annualized statistics for an asset class
        function calculateAssetStats(returns) {
            if (returns.length === 0) return null;
            
            // Handle both arrays of numbers and arrays of objects with 'return' property
            const monthlyReturns = returns.map(r => {
                if (typeof r === 'number') return r;
                if (r && typeof r === 'object' && r.return !== undefined) return r.return;
                return 0;
            }).filter(r => !isNaN(r) && isFinite(r));
            
            if (monthlyReturns.length === 0) return null;
            
            const meanReturn = monthlyReturns.reduce((a, b) => a + b, 0) / monthlyReturns.length;
            
            // Calculate variance
            const variance = monthlyReturns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / monthlyReturns.length;
            const stdDev = Math.sqrt(variance);
            
            // Annualize (multiply by 12 for monthly data)
            const annualizedReturn = meanReturn * 12;
            const annualizedVol = stdDev * Math.sqrt(12);
            
            // Sharpe ratio (assuming risk-free rate of 0 for simplicity, or use 3-month T-bill)
            const sharpeRatio = annualizedVol > 0 ? annualizedReturn / annualizedVol : 0;
            
            return {
                meanReturn: meanReturn,
                annualizedReturn: annualizedReturn,
                volatility: stdDev,
                annualizedVol: annualizedVol,
                sharpeRatio: sharpeRatio,
                periods: monthlyReturns.length
            };
        }
        
        // Calculate regime-specific asset performance
        function calculateRegimeAssetPerformance(regimeData, vtiData, aggData, commodityData, cashData) {
            // Calculate monthly returns for each asset
            const vtiReturns = calculateMonthlyReturns(vtiData);
            const aggReturns = calculateMonthlyReturns(aggData);
            const commodityReturns = calculateMonthlyReturns(commodityData);
            
            // For cash, use 3-month T-bill rate (already annualized, convert to monthly)
            // If we have cashData, use it; otherwise assume 0% for simplicity
            const cashReturns = cashData && cashData.length > 0 
                ? cashData.map((d, i) => i > 0 ? { date: d.date, return: (d.value / 100) / 12 } : null).filter(r => r !== null)
                : [];
            
            // Normalize dates to YYYY-MM-DD format for matching
            const normalizeDateForMap = (dateStr) => {
                // Try to parse and normalize the date
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) return dateStr; // Return original if invalid
                return date.toISOString().split('T')[0]; // YYYY-MM-DD format
            };
            
            // Create a map of returns by date for quick lookup
            // Use both original date and normalized date as keys for flexibility
            const returnsByDate = {
                vti: new Map(),
                agg: new Map(),
                commodity: new Map(),
                cash: new Map()
            };
            
            vtiReturns.forEach(r => {
                const normalized = normalizeDateForMap(r.date);
                returnsByDate.vti.set(r.date, r.return);
                returnsByDate.vti.set(normalized, r.return); // Also store normalized version
            });
            aggReturns.forEach(r => {
                const normalized = normalizeDateForMap(r.date);
                returnsByDate.agg.set(r.date, r.return);
                returnsByDate.agg.set(normalized, r.return);
            });
            commodityReturns.forEach(r => {
                const normalized = normalizeDateForMap(r.date);
                returnsByDate.commodity.set(r.date, r.return);
                returnsByDate.commodity.set(normalized, r.return);
            });
            if (cashReturns.length > 0) {
                cashReturns.forEach(r => {
                    const normalized = normalizeDateForMap(r.date);
                    returnsByDate.cash.set(r.date, r.return);
                    returnsByDate.cash.set(normalized, r.return);
                });
            }
            
            // Group returns by regime
            const regimeReturns = {
                'Disinflationary Boom': { vti: [], agg: [], commodity: [], cash: [] },
                'Inflationary Boom': { vti: [], agg: [], commodity: [], cash: [] },
                'Disinflationary Bust': { vti: [], agg: [], commodity: [], cash: [] },
                'Inflationary Bust': { vti: [], agg: [], commodity: [], cash: [] },
                'Neutral': { vti: [], agg: [], commodity: [], cash: [] }
            };
            
            // Align returns with regime periods
            // Returns are calculated from price changes, so return for month i is based on price change from month i-1 to i
            for (let i = 0; i < regimeData.length; i++) {
                const regime = regimeData[i].regime;
                const date = regimeData[i].date;
                const normalizedDate = normalizeDateForMap(date);
                
                // Try both original date and normalized date
                const getReturn = (assetMap) => {
                    return assetMap.get(date) || assetMap.get(normalizedDate) || null;
                };
                
                // Get returns for this month (returns are already calculated as month-over-month)
                // The return for a given month represents the return earned during that month
                const vtiRet = getReturn(returnsByDate.vti);
                if (vtiRet !== null && !isNaN(vtiRet) && isFinite(vtiRet)) {
                    regimeReturns[regime].vti.push(vtiRet);
                }
                
                const aggRet = getReturn(returnsByDate.agg);
                if (aggRet !== null && !isNaN(aggRet) && isFinite(aggRet)) {
                    regimeReturns[regime].agg.push(aggRet);
                }
                
                const commodityRet = getReturn(returnsByDate.commodity);
                if (commodityRet !== null && !isNaN(commodityRet) && isFinite(commodityRet)) {
                    regimeReturns[regime].commodity.push(commodityRet);
                }
                
                const cashRet = getReturn(returnsByDate.cash);
                if (cashRet !== null && !isNaN(cashRet) && isFinite(cashRet)) {
                    regimeReturns[regime].cash.push(cashRet);
                }
            }
            
            // Calculate statistics for each asset in each regime
            const regimeStats = {};
            const allRegimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            
            allRegimes.forEach(regime => {
                const vtiStats = calculateAssetStats(regimeReturns[regime].vti);
                const aggStats = calculateAssetStats(regimeReturns[regime].agg);
                const commodityStats = calculateAssetStats(regimeReturns[regime].commodity);
                const cashStats = calculateAssetStats(regimeReturns[regime].cash);
                
                // Log for debugging
                console.log(`Regime: ${regime}`, {
                    vti: { count: regimeReturns[regime].vti.length, stats: vtiStats },
                    agg: { count: regimeReturns[regime].agg.length, stats: aggStats },
                    commodity: { count: regimeReturns[regime].commodity.length, stats: commodityStats },
                    cash: { count: regimeReturns[regime].cash.length, stats: cashStats }
                });
                
                regimeStats[regime] = {
                    vti: vtiStats,
                    agg: aggStats,
                    commodity: commodityStats,
                    cash: cashStats || { 
                        meanReturn: 0.002, // ~2.4% annualized (conservative estimate)
                        annualizedReturn: 0.024,
                        volatility: 0.001,
                        annualizedVol: 0.003,
                        sharpeRatio: 8,
                        periods: regimeReturns[regime].vti.length
                    }
                };
            });
            
            return regimeStats;
        }
        
        // Optimize allocations using Sharpe ratio maximization with constraints
        function optimizeAllocations(regimeStats, regime) {
            const stats = regimeStats[regime];
            if (!stats) {
                console.warn(`No stats available for regime: ${regime}`);
                return null;
            }
            
            // Theoretical allocations (baseline)
            const theoreticalAllocations = {
                'Disinflationary Boom': { 'Equities': 65, 'Bonds': 25, 'Commodities': 7, 'Cash': 3 },
                'Inflationary Boom': { 'Equities': 45, 'Bonds': 22, 'Commodities': 30, 'Cash': 3 },
                'Disinflationary Bust': { 'Equities': 35, 'Bonds': 55, 'Commodities': 2, 'Cash': 8 },
                'Inflationary Bust': { 'Equities': 25, 'Bonds': 25, 'Commodities': 40, 'Cash': 10 },
                'Neutral': { 'Equities': 50, 'Bonds': 40, 'Commodities': 7, 'Cash': 3 }
            };
            
            const theoretical = theoreticalAllocations[regime] || theoreticalAllocations['Neutral'];
            
            // Simple optimization: maximize Sharpe ratio of portfolio
            // We'll use a grid search approach with constraints
            const assets = ['vti', 'agg', 'commodity', 'cash'];
            const assetNames = { vti: 'Equities', agg: 'Bonds', commodity: 'Commodities', cash: 'Cash' };
            
            // Get expected returns and volatilities
            const expectedReturns = {};
            const volatilities = {};
            
            assets.forEach(asset => {
                if (stats[asset] && stats[asset].meanReturn !== undefined && stats[asset].volatility !== undefined) {
                    expectedReturns[asset] = stats[asset].meanReturn;
                    volatilities[asset] = stats[asset].volatility;
                } else {
                    // Use default values if stats are missing
                    console.warn(`Missing stats for ${asset} in regime ${regime}, using defaults`);
                    expectedReturns[asset] = 0;
                    volatilities[asset] = 0.01;
                }
            });
            
            console.log(`Optimization inputs for ${regime}:`, {
                expectedReturns,
                volatilities,
                stats
            });
            
            // Check if we have valid data
            const hasValidData = Object.keys(expectedReturns).length > 0 && 
                                 Object.values(expectedReturns).some(r => r !== 0);
            
            if (!hasValidData) {
                console.warn(`No valid return data for regime: ${regime}, using theoretical allocation`);
                return theoretical;
            }
            
            // Grid search for optimal allocation (in 5% increments) with constraints
            let bestAllocation = null;
            let bestSharpe = -Infinity;
            
            // Constraints: prevent extreme allocations
            const minEquities = 10;  // At least 10% equities
            const maxCash = 30;       // At most 30% cash
            const minBonds = 5;       // At least 5% bonds (for diversification)
            
            // Try different combinations
            for (let equities = minEquities; equities <= 100; equities += 5) {
                for (let bonds = minBonds; bonds <= 100 - equities; bonds += 5) {
                    for (let commodities = 0; commodities <= 100 - equities - bonds; commodities += 5) {
                        const cash = 100 - equities - bonds - commodities;
                        
                        // Apply constraints
                        if (cash < 0 || cash > maxCash) continue;
                        
                        // Calculate portfolio return
                        const portfolioReturn = 
                            (equities / 100) * (expectedReturns.vti || 0) +
                            (bonds / 100) * (expectedReturns.agg || 0) +
                            (commodities / 100) * (expectedReturns.commodity || 0) +
                            (cash / 100) * (expectedReturns.cash || 0);
                        
                        // Calculate portfolio volatility (simplified: assume 0.3 correlation between assets)
                        const portfolioVariance = 
                            Math.pow((equities / 100) * (volatilities.vti || 0), 2) +
                            Math.pow((bonds / 100) * (volatilities.agg || 0), 2) +
                            Math.pow((commodities / 100) * (volatilities.commodity || 0), 2) +
                            Math.pow((cash / 100) * (volatilities.cash || 0), 2) +
                            2 * 0.3 * (equities / 100) * (bonds / 100) * (volatilities.vti || 0) * (volatilities.agg || 0) +
                            2 * 0.3 * (equities / 100) * (commodities / 100) * (volatilities.vti || 0) * (volatilities.commodity || 0) +
                            2 * 0.3 * (bonds / 100) * (commodities / 100) * (volatilities.agg || 0) * (volatilities.commodity || 0);
                        
                        const portfolioVol = Math.sqrt(portfolioVariance);
                        const annualizedReturn = portfolioReturn * 12;
                        const annualizedVol = portfolioVol * Math.sqrt(12);
                        const sharpeRatio = annualizedVol > 0 ? annualizedReturn / annualizedVol : 0;
                        
                        // Penalty for deviating too far from theoretical (encourages reasonable allocations)
                        const deviationPenalty = 0.1; // 10% penalty per 10% deviation
                        const equitiesDeviation = Math.abs(equities - theoretical['Equities']) / 10;
                        const bondsDeviation = Math.abs(bonds - theoretical['Bonds']) / 10;
                        const commoditiesDeviation = Math.abs(commodities - theoretical['Commodities']) / 10;
                        const cashDeviation = Math.abs(cash - theoretical['Cash']) / 10;
                        const totalDeviation = (equitiesDeviation + bondsDeviation + commoditiesDeviation + cashDeviation) * deviationPenalty;
                        const adjustedSharpe = sharpeRatio * (1 - totalDeviation);
                        
                        if (adjustedSharpe > bestSharpe) {
                            bestSharpe = adjustedSharpe;
                            bestAllocation = {
                                'Equities': Math.round(equities),
                                'Bonds': Math.round(bonds),
                                'Commodities': Math.round(commodities),
                                'Cash': Math.round(cash),
                                sharpeRatio: sharpeRatio,
                                adjustedSharpe: adjustedSharpe,
                                expectedReturn: annualizedReturn,
                                expectedVol: annualizedVol
                            };
                        }
                    }
                }
            }
            
            // If no valid allocation found (due to constraints), use theoretical
            if (!bestAllocation) {
                console.warn(`No valid allocation found for ${regime} with constraints, using theoretical`);
                return theoretical;
            }
            
            // Blend optimized allocation with theoretical (60% optimized, 40% theoretical)
            // This ensures we stay close to reasonable allocations while still being data-informed
            const blendWeight = 0.6;
            const blendedAllocation = {
                'Equities': Math.round(bestAllocation['Equities'] * blendWeight + theoretical['Equities'] * (1 - blendWeight)),
                'Bonds': Math.round(bestAllocation['Bonds'] * blendWeight + theoretical['Bonds'] * (1 - blendWeight)),
                'Commodities': Math.round(bestAllocation['Commodities'] * blendWeight + theoretical['Commodities'] * (1 - blendWeight)),
                'Cash': Math.round(bestAllocation['Cash'] * blendWeight + theoretical['Cash'] * (1 - blendWeight)),
                sharpeRatio: bestAllocation.sharpeRatio,
                adjustedSharpe: bestAllocation.adjustedSharpe,
                expectedReturn: bestAllocation.expectedReturn,
                expectedVol: bestAllocation.expectedVol
            };
            
            // Normalize to 100% (rounding might cause slight deviation)
            const total = blendedAllocation['Equities'] + blendedAllocation['Bonds'] + blendedAllocation['Commodities'] + blendedAllocation['Cash'];
            if (total !== 100) {
                const diff = 100 - total;
                // Add difference to largest allocation
                const maxAsset = Object.keys(blendedAllocation).filter(k => k !== 'sharpeRatio' && k !== 'adjustedSharpe' && k !== 'expectedReturn' && k !== 'expectedVol')
                    .reduce((a, b) => blendedAllocation[a] > blendedAllocation[b] ? a : b);
                blendedAllocation[maxAsset] += diff;
            }
            
            console.log(`Optimization result for ${regime}:`, {
                optimized: bestAllocation,
                theoretical: theoretical,
                blended: blendedAllocation,
                sharpeRatio: bestSharpe.toFixed(4)
            });
            
            return blendedAllocation;
        }
        
        // Calculate data-driven allocations for all regimes
        function calculateDataDrivenAllocations(regimeData, vtiData, aggData, commodityData, cashData) {
            const regimeStats = calculateRegimeAssetPerformance(regimeData, vtiData, aggData, commodityData, cashData);
            const optimizedAllocations = {};
            
            const allRegimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            
            allRegimes.forEach(regime => {
                const optimized = optimizeAllocations(regimeStats, regime);
                if (optimized && optimized.Equities !== undefined) {
                    optimizedAllocations[regime] = optimized;
                    console.log(`Optimized allocation for ${regime}:`, optimized);
                } else {
                    // Fallback to theoretical allocations if optimization fails
                    console.warn(`Optimization failed for ${regime}, using fallback allocation`);
                    optimizedAllocations[regime] = {
                        'Equities': 50,
                        'Bonds': 40,
                        'Commodities': 7,
                        'Cash': 3,
                        sharpeRatio: 0,
                        expectedReturn: 0,
                        expectedVol: 0
                    };
                }
            });
            
            console.log('Final optimized allocations:', optimizedAllocations);
            
            return {
                allocations: optimizedAllocations,
                stats: regimeStats
            };
        }
        
        // Update forward-looking allocation (blend of current and next regime)
        function updateForwardAllocation(currentRegime, transitionProbs, optimizedAllocations = null) {
            console.log('updateForwardAllocation called with:', {
                currentRegime,
                transitionProbs,
                optimizedAllocations
            });
            
            // Use optimized allocations if available, otherwise fall back to theoretical
            let allocations = optimizedAllocations || {
                'Disinflationary Boom': {
                    'Equities': 65,
                    'Bonds': 25,
                    'Commodities': 7,
                    'Cash': 3
                },
                'Inflationary Boom': {
                    'Equities': 45,
                    'Bonds': 22,
                    'Commodities': 30,
                    'Cash': 3
                },
                'Disinflationary Bust': {
                    'Equities': 35,
                    'Bonds': 55,
                    'Commodities': 2,
                    'Cash': 8
                },
                'Inflationary Bust': {
                    'Equities': 25,
                    'Bonds (TIPS)': 25,
                    'Commodities': 40,
                    'Cash': 10
                },
                'Neutral': {
                    'Equities': 50,
                    'Bonds': 40,
                    'Commodities': 7,
                    'Cash': 3
                }
            };
            
            // Get current allocation
            const currentAlloc = allocations[currentRegime] || allocations['Neutral'];
            
            // Calculate weighted average allocation based on transition probabilities
            const forwardAlloc = {
                'Equities': 0,
                'Bonds': 0,
                'Commodities': 0,
                'Cash': 0
            };
            
            Object.keys(transitionProbs).forEach(regime => {
                const prob = transitionProbs[regime];
                if (!prob || prob === 0) {
                    console.log(`Skipping ${regime} - probability is ${prob}`);
                    return;
                }
                
                const alloc = allocations[regime] || allocations['Neutral'];
                
                if (!alloc) {
                    console.warn(`No allocation found for regime: ${regime}`);
                    return;
                }
                
                console.log(`Processing ${regime} with prob ${prob.toFixed(4)}:`, alloc);
                
                // Map asset names (handle TIPS and Bonds)
                Object.keys(alloc).forEach(asset => {
                    // Skip non-allocation properties like sharpeRatio, expectedReturn, etc.
                    if (asset === 'sharpeRatio' || asset === 'expectedReturn' || asset === 'expectedVol') {
                        return;
                    }
                    
                    let mappedAsset = asset;
                    if (asset.includes('TIPS')) {
                        mappedAsset = 'Bonds';
                    } else if (asset === 'Bonds (TIPS)') {
                        mappedAsset = 'Bonds';
                    }
                    
                    const assetValue = alloc[asset];
                    if (typeof assetValue === 'number' && forwardAlloc[mappedAsset] !== undefined) {
                        const contribution = assetValue * prob;
                        forwardAlloc[mappedAsset] += contribution;
                        console.log(`  ${asset} (${assetValue}%) * ${prob.toFixed(4)} = ${contribution.toFixed(2)}%`);
                    } else {
                        console.log(`  Skipping ${asset}: value=${assetValue}, type=${typeof assetValue}, mapped=${mappedAsset}, inForward=${forwardAlloc[mappedAsset] !== undefined}`);
                    }
                });
            });
            
            console.log('Forward allocation before normalization:', forwardAlloc);
            
            // Round to integers
            Object.keys(forwardAlloc).forEach(asset => {
                const beforeRound = forwardAlloc[asset];
                forwardAlloc[asset] = Math.round(forwardAlloc[asset]);
                if (Math.abs(beforeRound - forwardAlloc[asset]) > 0.1) {
                    console.log(`Rounding ${asset}: ${beforeRound.toFixed(2)} -> ${forwardAlloc[asset]}`);
                }
            });
            
            console.log('Forward allocation after rounding:', JSON.parse(JSON.stringify(forwardAlloc)));
            
            // Normalize to 100%
            const total = Object.values(forwardAlloc).reduce((a, b) => a + b, 0);
            console.log('Total before normalization:', total);
            
            if (total === 0) {
                console.error('Forward allocation is all zeros! Check allocations and transition probabilities.');
                // Fallback to current regime allocation
                const fallbackAlloc = allocations[currentRegime] || allocations['Neutral'];
                Object.keys(forwardAlloc).forEach(asset => {
                    if (fallbackAlloc && fallbackAlloc[asset] !== undefined && typeof fallbackAlloc[asset] === 'number') {
                        forwardAlloc[asset] = fallbackAlloc[asset];
                    }
                });
            } else if (total !== 100 && total > 0) {
                const diff = 100 - total;
                // Add difference to largest allocation
                const maxAsset = Object.keys(forwardAlloc).reduce((a, b) => 
                    forwardAlloc[a] > forwardAlloc[b] ? a : b
                );
                forwardAlloc[maxAsset] += diff;
            }
            
            console.log('Final forward allocation:', forwardAlloc);
            
            // Display forward allocation
            const container = document.getElementById('forwardAllocation');
            if (container) {
                const assetColors = {
                    'Equities': 'text-green-400',
                    'Bonds': 'text-blue-400',
                    'Commodities': 'text-yellow-400',
                    'Cash': 'text-gray-400'
                };
                
                container.innerHTML = Object.keys(forwardAlloc).map(asset => `
                    <div class="flex justify-between items-center bg-gray-800 rounded-lg p-1.5 border border-gray-700/50 mb-0.5">
                        <span class="text-gray-300 text-xs">${asset}</span>
                        <span class="${assetColors[asset] || 'text-white'} font-semibold text-xs">${forwardAlloc[asset]}%</span>
                    </div>
                `).join('');
            }
            
            // Create pie chart for forward allocation
            const chartCanvas = document.getElementById('forwardAllocationChart');
            if (chartCanvas) {
                // Destroy existing chart if it exists
                if (forwardAllocationChartInstance) {
                    forwardAllocationChartInstance.destroy();
                }
                
                // Prepare data for pie chart
                const chartData = [];
                const chartLabels = [];
                const chartColors = {
                    'Equities': '#22c55e', // green-500
                    'Bonds': '#3b82f6',   // blue-500
                    'Commodities': '#eab308', // yellow-500
                    'Cash': '#6b7280'     // gray-500
                };
                
                Object.keys(forwardAlloc).forEach(asset => {
                    if (forwardAlloc[asset] > 0) {
                        chartLabels.push(asset);
                        chartData.push(forwardAlloc[asset]);
                    }
                });
                
                forwardAllocationChartInstance = new Chart(chartCanvas, {
                    type: 'pie',
                    data: {
                        labels: chartLabels,
                        datasets: [{
                            data: chartData,
                            backgroundColor: chartLabels.map(asset => chartColors[asset] || '#9ca3af'),
                            borderColor: '#1f2937',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        aspectRatio: 1.5,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: '#9ca3af',
                                    font: { size: 10 },
                                    padding: 8,
                                    boxWidth: 12
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                        return `${label}: ${value}% (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Update recommended allocation based on regime
        function updateRecommendedAllocation(regime, optimizedAllocations = null, regimeStats = null) {
            // Use optimized allocations if available
            let displayAllocations = null;
            
            if (optimizedAllocations && optimizedAllocations[regime]) {
                const optAlloc = optimizedAllocations[regime];
                displayAllocations = [
                    { asset: 'Equities', allocation: `${optAlloc.Equities}%`, color: 'text-green-400', isOptimized: true },
                    { asset: 'Bonds' + (regime === 'Inflationary Bust' ? ' (TIPS)' : ''), allocation: `${optAlloc.Bonds || optAlloc['Bonds (TIPS)'] || 0}%`, color: 'text-blue-400', isOptimized: true },
                    { asset: 'Commodities', allocation: `${optAlloc.Commodities}%`, color: 'text-yellow-400', isOptimized: true },
                    { asset: 'Cash', allocation: `${optAlloc.Cash}%`, color: 'text-gray-400', isOptimized: true }
                ];
            } else {
                // Fallback to theoretical ranges
                const allocations = {
                    'Disinflationary Boom': [
                        { asset: 'Equities', allocation: '60-70%', color: 'text-green-400' },
                        { asset: 'Bonds', allocation: '20-30%', color: 'text-blue-400' },
                        { asset: 'Commodities', allocation: '5-10%', color: 'text-yellow-400' },
                        { asset: 'Cash', allocation: '0-5%', color: 'text-gray-400' }
                    ],
                    'Inflationary Boom': [
                        { asset: 'Equities', allocation: '40-50%', color: 'text-green-400' },
                        { asset: 'Bonds', allocation: '20-25%', color: 'text-blue-400' },
                        { asset: 'Commodities', allocation: '25-35%', color: 'text-yellow-400' },
                        { asset: 'Cash', allocation: '0-5%', color: 'text-gray-400' }
                    ],
                    'Disinflationary Bust': [
                        { asset: 'Equities', allocation: '30-40%', color: 'text-green-400' },
                        { asset: 'Bonds', allocation: '50-60%', color: 'text-blue-400' },
                        { asset: 'Commodities', allocation: '0-5%', color: 'text-yellow-400' },
                        { asset: 'Cash', allocation: '5-10%', color: 'text-gray-400' }
                    ],
                    'Inflationary Bust': [
                        { asset: 'Equities', allocation: '20-30%', color: 'text-green-400' },
                        { asset: 'Bonds (TIPS)', allocation: '20-30%', color: 'text-blue-400' },
                        { asset: 'Commodities', allocation: '35-45%', color: 'text-yellow-400' },
                        { asset: 'Cash', allocation: '5-10%', color: 'text-gray-400' }
                    ],
                    'Neutral': [
                        { asset: 'Equities', allocation: '45-55%', color: 'text-green-400' },
                        { asset: 'Bonds', allocation: '35-45%', color: 'text-blue-400' },
                        { asset: 'Commodities', allocation: '5-10%', color: 'text-yellow-400' },
                        { asset: 'Cash', allocation: '0-5%', color: 'text-gray-400' }
                    ]
                };
                displayAllocations = allocations[regime] || allocations['Disinflationary Boom'];
            }
            
            const container = document.getElementById('currentAllocation');
            if (!container) {
                console.warn('currentAllocation container not found');
                return;
            }
            
            let html = displayAllocations.map(item => `
                <div class="flex justify-between items-center bg-gray-800 rounded-lg p-1.5 border border-gray-700/50 mb-0.5">
                    <span class="text-gray-300 text-xs">${item.asset}</span>
                    <span class="${item.color} font-semibold text-xs">${item.allocation}</span>
                </div>
            `).join('');
            
            container.innerHTML = html;
        }
        
        // Create regime quadrant chart
        function createRegimeQuadrantChart(regimeData) {
            const ctx = document.getElementById('regimeQuadrantChart');
            if (!ctx) return;
            
            if (regimeQuadrantChartInstance) {
                regimeQuadrantChartInstance.destroy();
            }
            
            const current = regimeData[regimeData.length - 1];
            
            // Calculate current 10-year means and std devs for quadrant division lines
            const lookbackMonths = 120;
            const recentData = regimeData.slice(-lookbackMonths);
            const growthValues = recentData.map(d => d.growth || d.gdpGrowth).filter(v => !isNaN(v));
            const inflationValues = recentData.map(d => d.inflation).filter(v => !isNaN(v));
            
            const growthMean = growthValues.reduce((a, b) => a + b, 0) / growthValues.length;
            const inflationMean = inflationValues.reduce((a, b) => a + b, 0) / inflationValues.length;
            
            const growthVariance = growthValues.reduce((sum, val) => sum + Math.pow(val - growthMean, 2), 0) / growthValues.length;
            const inflationVariance = inflationValues.reduce((sum, val) => sum + Math.pow(val - inflationMean, 2), 0) / inflationValues.length;
            
            const growthStdDev = Math.sqrt(growthVariance);
            const inflationStdDev = Math.sqrt(inflationVariance);
            
            // Use mean values for quadrant division (z-score = 0)
            // No thresholds needed - gradient scoring uses continuous weighting
            
            // Check if progression mode is enabled
            const showProgression = document.getElementById('showProgression')?.checked || false;
            
            // Prepare data points for each regime with dates
            const disinflationaryBoom = regimeData.filter(d => d.regime === 'Disinflationary Boom');
            const inflationaryBoom = regimeData.filter(d => d.regime === 'Inflationary Boom');
            const disinflationaryBust = regimeData.filter(d => d.regime === 'Disinflationary Bust');
            const inflationaryBust = regimeData.filter(d => d.regime === 'Inflationary Bust');
            const neutral = regimeData.filter(d => d.regime === 'Neutral');
            
            // Show last 20 years (240 months) of data
            const months20Years = 20 * 12;
            const data20Years = regimeData.slice(-months20Years);
            
            // Last 24 months for progression line (when enabled)
            const last24Months = regimeData.slice(-24);
            
            // Calculate min/max for auto-scaling axes using 20 years of data
            const allInflationValues = data20Years.map(d => d.inflation).filter(v => !isNaN(v) && v !== null);
            const allGrowthValues = data20Years.map(d => d.growth || d.gdpGrowth).filter(v => !isNaN(v) && v !== null);
            
            if (allInflationValues.length === 0 || allGrowthValues.length === 0) {
                console.warn('No valid data for quadrant chart');
                return;
            }
            
            const inflationMin = Math.min(...allInflationValues);
            const inflationMax = Math.max(...allInflationValues);
            const growthMin = Math.min(...allGrowthValues);
            const growthMax = Math.max(...allGrowthValues);
            
            // Calculate actual data ranges
            const inflationDataRange = inflationMax - inflationMin;
            const growthDataRange = growthMax - growthMin;
            
            // Use tighter padding (5% of data range) to fit data more closely
            // This ensures data points aren't right on the edges but keeps axes tight
            const inflationPadding = Math.max(inflationDataRange * 0.05, 0.2); // At least 0.2% padding
            const growthPadding = Math.max(growthDataRange * 0.05, 0.2); // At least 0.2% padding
            
            // Set axis ranges based on actual data with minimal padding
            let inflationMinSym = inflationMin - inflationPadding;
            const inflationMaxSym = inflationMax + inflationPadding;
            let growthMinSym = growthMin - growthPadding;
            const growthMaxSym = growthMax + growthPadding;
            
            // Only apply floor limits if data is very close to them (within padding)
            // This prevents unnecessary empty space while still showing all data
            if (inflationMin >= 0 && inflationMin < inflationPadding) {
                // Data starts near 0, but allow it to go slightly negative for better visualization
                inflationMinSym = Math.min(inflationMinSym, -0.1); // Small negative buffer for axis clarity
            }
            
            // For growth, only set a floor if data is actually near that floor
            if (growthMin >= -10 && growthMin < (-10 + growthPadding)) {
                // Data is near -10%, allow it to show with minimal padding
                growthMinSym = Math.max(growthMinSym, growthMin - growthPadding);
            }
            
            // Prepare datasets - always show 20 years of data
            const datasets = [];
            let progressionData = null; // Store for arrow drawing (last 24 months only)
            
            // Group all 20 years of data by regime
            const regimeGroups = {
                'Disinflationary Boom': { data: [], color: 'rgba(34, 197, 94, 0.3)', borderColor: 'rgba(34, 197, 94, 0.8)' },
                'Inflationary Boom': { data: [], color: 'rgba(234, 179, 8, 0.3)', borderColor: 'rgba(234, 179, 8, 0.8)' },
                'Disinflationary Bust': { data: [], color: 'rgba(59, 130, 246, 0.3)', borderColor: 'rgba(59, 130, 246, 0.8)' },
                'Inflationary Bust': { data: [], color: 'rgba(239, 68, 68, 0.3)', borderColor: 'rgba(239, 68, 68, 0.8)' },
                'Neutral': { data: [], color: 'rgba(156, 163, 175, 0.3)', borderColor: 'rgba(156, 163, 175, 0.8)' }
            };
            
            // Add all 20 years of data points
            data20Years.forEach(d => {
                if (regimeGroups[d.regime]) {
                    regimeGroups[d.regime].data.push({
                        x: d.inflation,
                        y: d.growth || d.gdpGrowth, // Use composite growth if available
                        date: d.date
                    });
                }
            });
            
            // Add scatter datasets for each regime (all 20 years)
            Object.keys(regimeGroups).forEach(regime => {
                if (regimeGroups[regime].data.length > 0) {
                    datasets.push({
                        label: regime,
                        data: regimeGroups[regime].data,
                        type: 'scatter',
                        backgroundColor: regimeGroups[regime].color,
                        borderColor: regimeGroups[regime].borderColor,
                        pointRadius: 4,
                        borderWidth: 1,
                        order: 1
                    });
                }
            });
            
            // If progression mode is enabled, add line and arrows for last 24 months only
            if (showProgression) {
                // Create progression data from last 24 months
                progressionData = last24Months.map(d => ({
                    x: d.inflation,
                    y: d.growth || d.gdpGrowth, // Use composite growth if available
                    date: d.date
                }));
                
                // Add line dataset for progression path with arrows (last 24 months only)
                datasets.push({
                    label: '2-Year Progression',
                    data: progressionData,
                    type: 'line',
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    backgroundColor: 'transparent',
                    borderWidth: 3,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0.3,
                    order: 0,
                    showLine: true
                });
            }
            
            // Always add current position
            datasets.push({
                label: 'Current Position',
                data: [{ 
                    x: current.inflation, 
                    y: current.growth || current.gdpGrowth, // Use composite growth if available
                    date: current.date 
                }],
                backgroundColor: 'rgba(255, 255, 255, 1)',
                borderColor: 'rgba(255, 255, 255, 1)',
                pointRadius: 8,
                pointStyle: 'star',
                order: 2
            });
            
            regimeQuadrantChartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: '#9ca3af',
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#d1d5db',
                            borderColor: '#374151',
                            borderWidth: 1,
                            callbacks: {
                                title: function(context) {
                                    const point = context[0].raw;
                                    if (point && point.date) {
                                        const date = new Date(point.date);
                                        return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    return `Growth: ${context.parsed.y.toFixed(2)}%, Inflation: ${context.parsed.x.toFixed(2)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Core PCE Inflation (YoY %)',
                                color: '#9ca3af',
                                font: { size: 12, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(156, 163, 175, 0.1)',
                                drawBorder: true,
                                borderColor: '#4b5563'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            min: inflationMinSym,
                            max: inflationMaxSym
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Composite Growth (IP + PMI + CFNAI-MA3, YoY %)',
                                color: '#9ca3af',
                                font: { size: 12, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(156, 163, 175, 0.1)',
                                drawBorder: true,
                                borderColor: '#4b5563'
                            },
                            ticks: {
                                color: '#9ca3af'
                            },
                            min: growthMinSym,
                            max: growthMaxSym
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLines',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;
                        
                        ctx.save();
                        
                        // Draw quadrant backgrounds
                        // Use mean values (z-score = 0) for quadrant division
                        const xThreshold = xScale.getPixelForValue(inflationMean);
                        const yThreshold = yScale.getPixelForValue(growthMean);
                        
                        // Get progression data from chart data if available
                        const chartData = chart.data.datasets;
                        let progressionDataForArrows = null;
                        if (showProgression && chartData && chartData.length > 0) {
                            const progressionDataset = chartData.find(d => d.label === '2-Year Progression');
                            if (progressionDataset && progressionDataset.data) {
                                progressionDataForArrows = progressionDataset.data;
                            }
                        }
                        
                        // Quadrant 1: Top Left (Disinflationary Boom) - Green
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.1)';
                        ctx.fillRect(xScale.left, yThreshold, xThreshold - xScale.left, yScale.top - yThreshold);
                        
                        // Quadrant 2: Top Right (Inflationary Boom) - Yellow
                        ctx.fillStyle = 'rgba(234, 179, 8, 0.1)';
                        ctx.fillRect(xThreshold, yThreshold, xScale.right - xThreshold, yScale.top - yThreshold);
                        
                        // Quadrant 3: Bottom Left (Disinflationary Bust) - Blue
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                        ctx.fillRect(xScale.left, yScale.bottom, xThreshold - xScale.left, yThreshold - yScale.bottom);
                        
                        // Quadrant 4: Bottom Right (Inflationary Bust) - Red
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
                        ctx.fillRect(xThreshold, yScale.bottom, xScale.right - xThreshold, yThreshold - yScale.bottom);
                        
                        // Draw neutral region (center area within ±0.25σ buffer)
                        // Calculate using the same std devs that were calculated earlier
                        const neutralBuffer = 0.25;
                        const neutralGrowthLow = growthMean - (neutralBuffer * growthStdDev);
                        const neutralGrowthHigh = growthMean + (neutralBuffer * growthStdDev);
                        const neutralInflationLow = inflationMean - (neutralBuffer * inflationStdDev);
                        const neutralInflationHigh = inflationMean + (neutralBuffer * inflationStdDev);
                        
                        const xNeutralLow = xScale.getPixelForValue(neutralInflationLow);
                        const xNeutralHigh = xScale.getPixelForValue(neutralInflationHigh);
                        const yNeutralLow = yScale.getPixelForValue(neutralGrowthLow);
                        const yNeutralHigh = yScale.getPixelForValue(neutralGrowthHigh);
                        
                        // Draw neutral region overlay (center area) - draw after quadrants so it's on top
                        ctx.fillStyle = 'rgba(156, 163, 175, 0.15)';
                        ctx.fillRect(xNeutralLow, yNeutralLow, xNeutralHigh - xNeutralLow, yNeutralHigh - yNeutralLow);
                        
                        // Draw threshold lines
                        ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        
                        // Draw vertical line at inflation threshold
                        ctx.beginPath();
                        ctx.moveTo(xThreshold, yScale.top);
                        ctx.lineTo(xThreshold, yScale.bottom);
                        ctx.stroke();
                        
                        // Draw horizontal line at growth threshold
                        ctx.beginPath();
                        ctx.moveTo(xScale.left, yThreshold);
                        ctx.lineTo(xScale.right, yThreshold);
                        ctx.stroke();
                        
                        // Draw quadrant labels
                        ctx.fillStyle = 'rgba(156, 163, 175, 0.8)';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Top Left
                        ctx.fillText('Disinflationary Boom', (xScale.left + xThreshold) / 2, (yScale.top + yThreshold) / 2);
                        // Top Right
                        ctx.fillText('Inflationary Boom', (xScale.right + xThreshold) / 2, (yScale.top + yThreshold) / 2);
                        // Bottom Left
                        ctx.fillText('Disinflationary Bust', (xScale.left + xThreshold) / 2, (yScale.bottom + yThreshold) / 2);
                        // Bottom Right
                        ctx.fillText('Inflationary Bust', (xScale.right + xThreshold) / 2, (yScale.bottom + yThreshold) / 2);
                        // Center (Neutral)
                        ctx.fillText('Neutral', xThreshold, yThreshold);
                        
                        // Draw progression arrows if enabled
                        if (showProgression && progressionDataForArrows && progressionDataForArrows.length > 1) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.lineWidth = 1.5;
                            ctx.setLineDash([]);
                            
                            // Draw arrows along the progression line
                            // Sample every few points to avoid clutter (about 6-8 arrows total)
                            const arrowSpacing = Math.max(2, Math.floor(progressionDataForArrows.length / 7));
                            
                            for (let i = arrowSpacing; i < progressionDataForArrows.length - 1; i += arrowSpacing) {
                                const current = progressionDataForArrows[i];
                                const next = progressionDataForArrows[i + 1];
                                
                                if (!current || !next) continue;
                                
                                const x1 = xScale.getPixelForValue(current.x);
                                const y1 = yScale.getPixelForValue(current.y);
                                const x2 = xScale.getPixelForValue(next.x);
                                const y2 = yScale.getPixelForValue(next.y);
                                
                                // Calculate angle
                                const angle = Math.atan2(y2 - y1, x2 - x1);
                                
                                // Draw arrow at midpoint
                                const midX = (x1 + x2) / 2;
                                const midY = (y1 + y2) / 2;
                                
                                const arrowLength = 10;
                                const arrowWidth = 5;
                                
                                ctx.save();
                                ctx.translate(midX, midY);
                                ctx.rotate(angle);
                                
                                // Draw arrow pointing forward (in direction of progression)
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(-arrowLength, -arrowWidth);
                                ctx.lineTo(-arrowLength, arrowWidth);
                                ctx.closePath();
                                ctx.fill();
                                
                                ctx.restore();
                            }
                        }
                        
                        ctx.restore();
                    }
                }]
            });
        }
        
        // Create regime timeline chart
        function createRegimeTimelineChart(regimeData) {
            const ctx = document.getElementById('regimeTimelineChart');
            if (!ctx) return;
            
            if (regimeTimelineChartInstance) {
                regimeTimelineChartInstance.destroy();
            }
            
            // Create regime numeric values for plotting
            const regimeValues = {
                'Disinflationary Boom': 1,
                'Inflationary Boom': 2,
                'Disinflationary Bust': 3,
                'Inflationary Bust': 4,
                'Neutral': 5
            };
            
            const labels = regimeData.map(d => {
                const date = new Date(d.date);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            });
            
            // Sample data for performance (show every 3rd point)
            const sampledLabels = [];
            const sampledData = [];
            const sampledRegimes = [];
            for (let i = 0; i < regimeData.length; i += 3) {
                sampledLabels.push(labels[i]);
                sampledData.push(regimeValues[regimeData[i].regime]);
                sampledRegimes.push(regimeData[i].regime);
            }
            
            regimeTimelineChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sampledLabels,
                    datasets: [{
                        label: 'Regime',
                        data: sampledData,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        segment: {
                            borderColor: (ctx) => {
                                const regime = sampledRegimes[ctx.p0.parsed.x];
                                const colors = {
                                    'Disinflationary Boom': '#22c55e',
                                    'Inflationary Boom': '#eab308',
                                    'Disinflationary Bust': '#3b82f6',
                                    'Inflationary Bust': '#ef4444'
                                };
                                return colors[regime] || '#60a5fa';
                            }
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#d1d5db',
                            borderColor: '#374151',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex * 3;
                                    if (index < regimeData.length) {
                                        return `Regime: ${regimeData[index].regime}`;
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(156, 163, 175, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxRotation: 45,
                                minRotation: 45,
                                maxTicksLimit: 12
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(156, 163, 175, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                stepSize: 1,
                                callback: function(value) {
                                    const regimes = ['', 'Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
                                    return regimes[value] || '';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Create growth vs inflation scatter chart over time
        function createGrowthInflationChart(alignedData, regimeData, zoom2Years = false) {
            const ctx = document.getElementById('growthInflationChart');
            if (!ctx) return;
            
            if (growthInflationChartInstance) {
                growthInflationChartInstance.destroy();
            }
            
            // Check if user wants to show actual values (default is z-scores)
            const showActualValues = document.getElementById('showActualValues')?.checked || false;
            
            // Filter data based on zoom setting
            let allData = alignedData;
            if (zoom2Years) {
                const twoYearsAgo = new Date();
                twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);
                allData = alignedData.filter(d => {
                    const date = new Date(d.date);
                    return date >= twoYearsAgo;
                });
            }
            
            // Create regime map for quick lookup (normalize dates)
            const normalizeDate = (dateStr) => {
                const date = new Date(dateStr);
                return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            };
            
            // Create maps for regime data (includes z-scores)
            const regimeMap = new Map();
            const zScoreMap = new Map();
            regimeData.forEach(item => {
                const normalizedDate = normalizeDate(item.date);
                regimeMap.set(normalizedDate, item.regime);
                zScoreMap.set(normalizedDate, {
                    growthZScore: item.growthZScore || 0,
                    inflationZScore: item.inflationZScore || 0
                });
            });
            
            // Create color map based on regime
            const getRegimeColor = (regime) => {
                const colors = {
                    'Disinflationary Boom': 'rgba(34, 197, 94, 0.6)',
                    'Inflationary Boom': 'rgba(234, 179, 8, 0.6)',
                    'Disinflationary Bust': 'rgba(59, 130, 246, 0.6)',
                    'Inflationary Bust': 'rgba(239, 68, 68, 0.6)',
                    'Neutral': 'rgba(156, 163, 175, 0.6)'
                };
                return colors[regime] || 'rgba(156, 163, 175, 0.6)';
            };
            
            const scatterData = allData.map(d => {
                const normalizedDate = normalizeDate(d.date);
                const regime = regimeMap.get(normalizedDate);
                const zScores = zScoreMap.get(normalizedDate) || { growthZScore: 0, inflationZScore: 0 };
                
                return {
                    x: showActualValues ? d.inflation : zScores.inflationZScore,
                    y: showActualValues ? (d.growth || d.gdpGrowth) : zScores.growthZScore,
                    xActual: d.inflation,
                    yActual: d.growth || d.gdpGrowth,
                    xZScore: zScores.inflationZScore,
                    yZScore: zScores.growthZScore,
                    date: d.date,
                    regime: regime,
                    color: getRegimeColor(regime)
                };
            });
            
            // Calculate mean values for actual values mode (for quadrant lines)
            let xMean = 0;
            let yMean = 0;
            if (showActualValues) {
                const inflationValues = allData.map(d => d.inflation).filter(v => !isNaN(v));
                const growthValues = allData.map(d => d.growth || d.gdpGrowth).filter(v => !isNaN(v));
                xMean = inflationValues.length > 0 ? inflationValues.reduce((a, b) => a + b, 0) / inflationValues.length : 0;
                yMean = growthValues.length > 0 ? growthValues.reduce((a, b) => a + b, 0) / growthValues.length : 0;
            }
            
            // Get axis limits for drawing quadrant lines
            const xValues = scatterData.map(d => d.x).filter(v => !isNaN(v));
            const yValues = scatterData.map(d => d.y).filter(v => !isNaN(v));
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);
            
            // Calculate tighter axis ranges with minimal padding (2% instead of default 5-10%)
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            const xPadding = xRange * 0.02; // 2% padding
            const yPadding = yRange * 0.02; // 2% padding
            const xAxisMin = xMin - xPadding;
            const xAxisMax = xMax + xPadding;
            const yAxisMin = yMin - yPadding;
            const yAxisMax = yMax + yPadding;
            
            // Create datasets array with scatter data and quadrant axis lines
            const datasets = [{
                label: 'Growth vs Inflation',
                data: scatterData,
                backgroundColor: scatterData.map(d => d.color),
                borderColor: scatterData.map(d => d.color.replace('0.6', '0.8')),
                pointRadius: 5,
                pointHoverRadius: 7
            }];
            
            // Add vertical axis line (inflation boundary)
            datasets.push({
                label: 'Inflation Boundary',
                data: [
                    { x: showActualValues ? xMean : 0, y: yMin },
                    { x: showActualValues ? xMean : 0, y: yMax }
                ],
                type: 'line',
                borderColor: 'rgba(255, 255, 255, 0.5)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                order: 0 // Draw behind scatter points
            });
            
            // Add horizontal axis line (growth boundary)
            datasets.push({
                label: 'Growth Boundary',
                data: [
                    { x: xMin, y: showActualValues ? yMean : 0 },
                    { x: xMax, y: showActualValues ? yMean : 0 }
                ],
                type: 'line',
                borderColor: 'rgba(255, 255, 255, 0.5)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
                order: 0 // Draw behind scatter points
            });
            
            growthInflationChartInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#d1d5db',
                            borderColor: '#374151',
                            borderWidth: 1,
                            callbacks: {
                                title: function(context) {
                                    if (!context || !context[0] || context[0].dataIndex === undefined) {
                                        return '';
                                    }
                                    const point = scatterData[context[0].dataIndex];
                                    if (!point) return '';
                                    const date = new Date(point.date);
                                    return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                                },
                                label: function(context) {
                                    if (!context || !context[0] || context[0].dataIndex === undefined) {
                                        return '';
                                    }
                                    const point = scatterData[context[0].dataIndex];
                                    if (!point) return '';
                                    const regime = point.regime || 'Unknown';
                                    if (showActualValues) {
                                        return [
                                            `Growth: ${context.parsed.y.toFixed(2)}%`,
                                            `Inflation: ${context.parsed.x.toFixed(2)}%`,
                                            `Regime: ${regime}`
                                        ];
                                    } else {
                                        return [
                                            `Growth Z-score: ${context.parsed.y.toFixed(2)}σ`,
                                            `Inflation Z-score: ${context.parsed.x.toFixed(2)}σ`,
                                            `Growth Actual: ${point.yActual.toFixed(2)}%`,
                                            `Inflation Actual: ${point.xActual.toFixed(2)}%`,
                                            `Regime: ${regime}`
                                        ];
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: showActualValues ? 'Core PCE Inflation (YoY %)' : 'Inflation Z-Score (σ)',
                                color: '#9ca3af',
                                font: { size: 12, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(156, 163, 175, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    if (!showActualValues) {
                                        return value.toFixed(1) + 'σ';
                                    }
                                    return value.toFixed(1) + '%';
                                }
                            },
                            min: xAxisMin,
                            max: xAxisMax
                        },
                        y: {
                            title: {
                                display: true,
                                text: showActualValues ? 'Composite Growth (IP + PMI + CFNAI-MA3, YoY %)' : 'Growth Z-Score (σ)',
                                color: '#9ca3af',
                                font: { size: 12, weight: 'bold' }
                            },
                            grid: {
                                color: 'rgba(156, 163, 175, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    if (!showActualValues) {
                                        return value.toFixed(1) + 'σ';
                                    }
                                    return value.toFixed(1) + '%';
                                }
                            },
                            min: yAxisMin,
                            max: yAxisMax
                        }
                    }
                },
                plugins: []
            });
        }
        
        // Update regime statistics
        function updateRegimeStatistics(regimeData) {
            const stats = {
                'Disinflationary Boom': { count: 0, percentage: 0 },
                'Inflationary Boom': { count: 0, percentage: 0 },
                'Disinflationary Bust': { count: 0, percentage: 0 },
                'Inflationary Bust': { count: 0, percentage: 0 },
                'Neutral': { count: 0, percentage: 0 }
            };
            
            regimeData.forEach(d => {
                if (stats[d.regime]) {
                    stats[d.regime].count++;
                }
            });
            
            const total = regimeData.length;
            Object.keys(stats).forEach(regime => {
                stats[regime].percentage = ((stats[regime].count / total) * 100).toFixed(1);
            });
            
            const colors = {
                'Disinflationary Boom': 'text-green-400',
                'Inflationary Boom': 'text-yellow-400',
                'Disinflationary Bust': 'text-blue-400',
                'Inflationary Bust': 'text-red-400',
                'Neutral': 'text-gray-400'
            };
            
            const container = document.getElementById('regimeStats');
            container.innerHTML = Object.keys(stats).map(regime => `
                <div class="bg-gray-900 rounded-lg p-4 border border-gray-700/50">
                    <div class="${colors[regime]} text-sm font-semibold mb-2">${regime}</div>
                    <div class="text-2xl font-bold text-white mb-1">${stats[regime].count}</div>
                    <div class="text-gray-400 text-xs">Months (${stats[regime].percentage}%)</div>
                </div>
            `).join('');
        }
        
        // Update historical regime statistics
        function updateHistoricalRegimeStatistics(regimeData) {
            const regimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            const colors = {
                'Disinflationary Boom': { bg: 'bg-green-900/20', border: 'border-green-700/30', text: 'text-green-400' },
                'Inflationary Boom': { bg: 'bg-yellow-900/20', border: 'border-yellow-700/30', text: 'text-yellow-400' },
                'Disinflationary Bust': { bg: 'bg-blue-900/20', border: 'border-blue-700/30', text: 'text-blue-400' },
                'Inflationary Bust': { bg: 'bg-red-900/20', border: 'border-red-700/30', text: 'text-red-400' },
                'Neutral': { bg: 'bg-gray-900/20', border: 'border-gray-700/30', text: 'text-gray-400' }
            };
            
            const stats = {};
            regimes.forEach(regime => {
                const regimePoints = regimeData.filter(d => d.regime === regime);
                
                if (regimePoints.length === 0) {
                    stats[regime] = {
                        avgGrowth: 0,
                        avgInflation: 0,
                        maxGrowth: 0,
                        minGrowth: 0,
                        maxInflation: 0,
                        minInflation: 0,
                        periods: [],
                        longestPeriod: 0
                    };
                    return;
                }
                
                // Calculate averages (use composite growth if available)
                const avgGrowth = regimePoints.reduce((sum, d) => sum + (d.growth || d.gdpGrowth), 0) / regimePoints.length;
                const avgInflation = regimePoints.reduce((sum, d) => sum + d.inflation, 0) / regimePoints.length;
                
                // Calculate average z-scores to show relative positioning
                const avgGrowthZScore = regimePoints.reduce((sum, d) => sum + (d.growthZScore || 0), 0) / regimePoints.length;
                const avgInflationZScore = regimePoints.reduce((sum, d) => sum + (d.inflationZScore || 0), 0) / regimePoints.length;
                
                // Calculate min/max (use composite growth if available)
                const growthValues = regimePoints.map(d => d.growth || d.gdpGrowth);
                const inflationValues = regimePoints.map(d => d.inflation);
                const maxGrowth = Math.max(...growthValues);
                const minGrowth = Math.min(...growthValues);
                const maxInflation = Math.max(...inflationValues);
                const minInflation = Math.min(...inflationValues);
                
                // Find periods (consecutive months in same regime)
                const periods = [];
                let currentPeriod = null;
                regimeData.forEach((d, index) => {
                    if (d.regime === regime) {
                        if (!currentPeriod) {
                            currentPeriod = { start: d.date, end: d.date, length: 1 };
                        } else {
                            currentPeriod.end = d.date;
                            currentPeriod.length++;
                        }
                    } else {
                        if (currentPeriod) {
                            periods.push(currentPeriod);
                            currentPeriod = null;
                        }
                    }
                });
                if (currentPeriod) {
                    periods.push(currentPeriod);
                }
                
                const longestPeriod = periods.length > 0 ? Math.max(...periods.map(p => p.length)) : 0;
                
                stats[regime] = {
                    avgGrowth,
                    avgInflation,
                    avgGrowthZScore,
                    avgInflationZScore,
                    maxGrowth,
                    minGrowth,
                    maxInflation,
                    minInflation,
                    periods,
                    longestPeriod
                };
            });
            
            const container = document.getElementById('historicalRegimeStats');
            container.innerHTML = regimes.map(regime => {
                const s = stats[regime];
                const color = colors[regime];
                const recentPeriods = s.periods.slice(-3).reverse(); // Last 3 periods
                
                return `
                    <div class="${color.bg} rounded-lg p-4 border ${color.border}">
                        <div class="${color.text} text-sm font-semibold mb-3">${regime}</div>
                        <div class="space-y-2 text-xs">
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <div class="text-gray-400">Avg Growth</div>
                                    <div class="text-white font-semibold">${s.avgGrowth.toFixed(2)}%</div>
                                    <div class="text-gray-500 text-xs mt-0.5">Z-score: ${s.avgGrowthZScore.toFixed(2)}σ</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Avg Inflation</div>
                                    <div class="text-white font-semibold">${s.avgInflation.toFixed(2)}%</div>
                                    <div class="text-gray-500 text-xs mt-0.5">Z-score: ${s.avgInflationZScore.toFixed(2)}σ</div>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <div class="text-gray-400">Growth Range</div>
                                    <div class="text-white font-semibold">${s.minGrowth.toFixed(1)}% - ${s.maxGrowth.toFixed(1)}%</div>
                                </div>
                                <div>
                                    <div class="text-gray-400">Inflation Range</div>
                                    <div class="text-white font-semibold">${s.minInflation.toFixed(1)}% - ${s.maxInflation.toFixed(1)}%</div>
                                </div>
                            </div>
                            <div class="pt-2 border-t border-gray-700/50">
                                <div class="text-gray-400 mb-1">Longest Period</div>
                                <div class="text-white font-semibold">${s.longestPeriod} months</div>
                            </div>
                            ${recentPeriods.length > 0 ? `
                                <div class="pt-2 border-t border-gray-700/50">
                                    <div class="text-gray-400 mb-1">Recent Periods</div>
                                    <div class="space-y-1">
                                        ${recentPeriods.map(p => {
                                            const startDate = new Date(p.start);
                                            const endDate = new Date(p.end);
                                            const startStr = startDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
                                            const endStr = endDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
                                            return `<div class="text-gray-300">${startStr} - ${endStr} (${p.length}m)</div>`;
                                        }).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Update asset class performance by regime
        function updateAssetClassPerformance(regimeData, vtiData, aggData, commodityData, cashData, dividendData, bondYieldData) {
            // Convert asset class data to monthly TOTAL returns (price + dividends/income)
            const stocksReturns = calculateTotalReturns(vtiData, dividendData, 'stocks');
            const bondsReturns = calculateTotalReturns(aggData, bondYieldData, 'bonds');
            const commoditiesReturns = calculateMonthlyReturns(commodityData); // Commodities have no dividends
            const cashReturns = calculateCashReturns(cashData); // Cash already includes interest
            
            // Normalize dates to YYYY-MM format for matching
            const normalizeDate = (dateStr) => {
                const date = new Date(dateStr);
                return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            };
            
            // Create date maps for quick lookup (normalized to YYYY-MM)
            const stocksMap = new Map(stocksReturns.map(d => [normalizeDate(d.date), d.return]));
            const bondsMap = new Map(bondsReturns.map(d => [normalizeDate(d.date), d.return]));
            const commoditiesMap = new Map(commoditiesReturns.map(d => [normalizeDate(d.date), d.return]));
            const cashMap = new Map(cashReturns.map(d => [normalizeDate(d.date), d.return]));
            
            // Calculate statistics for each regime
            const regimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            const regimeColors = {
                'Disinflationary Boom': { bg: 'bg-green-900/20', border: 'border-green-700/30', text: 'text-green-400' },
                'Inflationary Boom': { bg: 'bg-yellow-900/20', border: 'border-yellow-700/30', text: 'text-yellow-400' },
                'Disinflationary Bust': { bg: 'bg-blue-900/20', border: 'border-blue-700/30', text: 'text-blue-400' },
                'Inflationary Bust': { bg: 'bg-red-900/20', border: 'border-red-700/30', text: 'text-red-400' },
                'Neutral': { bg: 'bg-gray-900/20', border: 'border-gray-700/30', text: 'text-gray-400' }
            };
            
            const assetStats = {};
            
            // Get allocation weights for each regime (using midpoint of ranges)
            const getAllocationWeights = (regime) => {
                const allocations = {
                    'Disinflationary Boom': { stocks: 0.65, bonds: 0.25, commodities: 0.075, cash: 0.025 },
                    'Inflationary Boom': { stocks: 0.45, bonds: 0.225, commodities: 0.30, cash: 0.025 },
                    'Disinflationary Bust': { stocks: 0.35, bonds: 0.55, commodities: 0.025, cash: 0.075 },
                    'Inflationary Bust': { stocks: 0.25, bonds: 0.25, commodities: 0.40, cash: 0.075 },
                    'Neutral': { stocks: 0.50, bonds: 0.40, commodities: 0.075, cash: 0.025 }
                };
                return allocations[regime] || allocations['Neutral'];
            };
            
            regimes.forEach(regime => {
                const regimeMonths = regimeData.filter(d => d.regime === regime);
                const assetReturns = {
                    stocks: [],
                    bonds: [],
                    commodities: [],
                    cash: []
                };
                
                regimeMonths.forEach(month => {
                    const normalizedDate = normalizeDate(month.date);
                    if (stocksMap.has(normalizedDate)) assetReturns.stocks.push(stocksMap.get(normalizedDate));
                    if (bondsMap.has(normalizedDate)) assetReturns.bonds.push(bondsMap.get(normalizedDate));
                    if (commoditiesMap.has(normalizedDate)) assetReturns.commodities.push(commoditiesMap.get(normalizedDate));
                    if (cashMap.has(normalizedDate)) assetReturns.cash.push(cashMap.get(normalizedDate));
                });
                
                // Calculate portfolio returns for this regime
                const weights = getAllocationWeights(regime);
                const portfolioReturns = [];
                
                // Find common dates across all assets
                const allDates = new Set();
                regimeMonths.forEach(month => {
                    const normalizedDate = normalizeDate(month.date);
                    if (stocksMap.has(normalizedDate) && bondsMap.has(normalizedDate) && 
                        commoditiesMap.has(normalizedDate) && cashMap.has(normalizedDate)) {
                        allDates.add(normalizedDate);
                    }
                });
                
                // Calculate weighted portfolio return for each month
                allDates.forEach(date => {
                    const stockReturn = stocksMap.get(date);
                    const bondReturn = bondsMap.get(date);
                    const commodityReturn = commoditiesMap.get(date);
                    const cashReturn = cashMap.get(date);
                    
                    if (stockReturn !== undefined && bondReturn !== undefined && 
                        commodityReturn !== undefined && cashReturn !== undefined) {
                        // Portfolio return = weighted sum of asset returns
                        const portfolioReturn = (stockReturn * weights.stocks) + 
                                              (bondReturn * weights.bonds) + 
                                              (commodityReturn * weights.commodities) + 
                                              (cashReturn * weights.cash);
                        portfolioReturns.push(portfolioReturn);
                    }
                });
                
                assetStats[regime] = {
                    stocks: calculateStats(assetReturns.stocks),
                    bonds: calculateStats(assetReturns.bonds),
                    commodities: calculateStats(assetReturns.commodities),
                    cash: calculateStats(assetReturns.cash),
                    portfolio: calculateStats(portfolioReturns)
                };
            });
            
            // Store asset stats globally for annualization toggle
            window.assetStatsByRegime = assetStats;
            
            // Display the statistics
            updateAssetClassDisplay(assetStats);
            
            // Add event listener for annualization checkbox
            const annualizeCheckbox = document.getElementById('annualizeReturns');
            if (annualizeCheckbox) {
                annualizeCheckbox.addEventListener('change', function() {
                    updateAssetClassDisplay(window.assetStatsByRegime);
                });
            }
        }
        
        // Calculate rolling correlation between stocks and bonds
        function createStocksBondsCorrelationChart(sp500Data, aggData) {
            const ctx = document.getElementById('stocksBondsCorrelationChart');
            if (!ctx) return;
            
            if (stocksBondsCorrelationChartInstance) {
                stocksBondsCorrelationChartInstance.destroy();
            }
            
            // Sort data by date
            const sortedSP500 = [...sp500Data].sort((a, b) => new Date(a.date) - new Date(b.date));
            const sortedAGG = [...aggData].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Create date maps for easier lookup
            const sp500Map = new Map();
            sortedSP500.forEach(item => {
                const date = new Date(item.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!sp500Map.has(monthKey) || new Date(item.date) > new Date(sp500Map.get(monthKey).date)) {
                    sp500Map.set(monthKey, item);
                }
            });
            
            const aggMap = new Map();
            sortedAGG.forEach(item => {
                const date = new Date(item.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!aggMap.has(monthKey) || new Date(item.date) > new Date(aggMap.get(monthKey).date)) {
                    aggMap.set(monthKey, item);
                }
            });
            
            // Get all unique months
            const allMonths = new Set([...sp500Map.keys(), ...aggMap.keys()]);
            const sortedMonths = Array.from(allMonths).sort();
            
            // Calculate monthly returns for stocks and bonds (both price returns)
            const monthlyData = [];
            for (let i = 1; i < sortedMonths.length; i++) {
                const currentMonth = sortedMonths[i];
                const prevMonth = sortedMonths[i - 1];
                
                const currentSP500 = sp500Map.get(currentMonth);
                const prevSP500 = sp500Map.get(prevMonth);
                const currentAGG = aggMap.get(currentMonth);
                const prevAGG = aggMap.get(prevMonth);
                
                if (currentSP500 && prevSP500 && currentAGG && prevAGG) {
                    const stockReturn = ((currentSP500.value - prevSP500.value) / prevSP500.value) * 100;
                    const bondReturn = ((currentAGG.value - prevAGG.value) / prevAGG.value) * 100;
                    
                    monthlyData.push({
                        date: currentMonth,
                        stockReturn: stockReturn,
                        bondReturn: bondReturn
                    });
                }
            }
            
            // Calculate 12-month rolling correlation
            const rollingWindow = 12;
            const correlationData = [];
            
            for (let i = rollingWindow - 1; i < monthlyData.length; i++) {
                const windowData = monthlyData.slice(i - rollingWindow + 1, i + 1);
                const stockReturns = windowData.map(d => d.stockReturn);
                const bondReturns = windowData.map(d => d.bondReturn);
                
                // Calculate correlation
                const correlation = calculateCorrelation(stockReturns, bondReturns);
                
                if (correlation !== null) {
                    correlationData.push({
                        date: monthlyData[i].date,
                        correlation: correlation
                    });
                }
            }
            
            // Prepare chart data - format dates as strings
            const chartLabels = correlationData.map(d => {
                const [year, month] = d.date.split('-');
                const date = new Date(parseInt(year), parseInt(month) - 1);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            });
            const correlations = correlationData.map(d => d.correlation);
            
            // Create chart
            stocksBondsCorrelationChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: '12-Month Rolling Correlation',
                        data: correlations,
                        borderColor: 'rgb(59, 130, 246)',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    }, {
                        label: 'Zero Line',
                        data: correlations.map(() => 0),
                        borderColor: 'rgba(156, 163, 175, 0.5)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: 'rgb(209, 213, 219)',
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: 'rgb(209, 213, 219)',
                            bodyColor: 'rgb(209, 213, 219)',
                            borderColor: 'rgb(75, 85, 99)',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 0) {
                                        const corr = context.parsed.y;
                                        return `Correlation: ${corr.toFixed(3)}`;
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: 'rgb(156, 163, 175)',
                                font: {
                                    size: 11
                                },
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                color: 'rgba(75, 85, 99, 0.3)'
                            }
                        },
                        y: {
                            min: -1,
                            max: 1,
                            ticks: {
                                color: 'rgb(156, 163, 175)',
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            },
                            grid: {
                                color: 'rgba(75, 85, 99, 0.3)'
                            },
                            title: {
                                display: true,
                                text: 'Correlation Coefficient',
                                color: 'rgb(209, 213, 219)',
                                font: {
                                    size: 12
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Helper function to calculate correlation coefficient
        function calculateCorrelation(x, y) {
            if (x.length !== y.length || x.length === 0) return null;
            
            const n = x.length;
            const xMean = x.reduce((a, b) => a + b, 0) / n;
            const yMean = y.reduce((a, b) => a + b, 0) / n;
            
            let numerator = 0;
            let xSumSq = 0;
            let ySumSq = 0;
            
            for (let i = 0; i < n; i++) {
                const xDiff = x[i] - xMean;
                const yDiff = y[i] - yMean;
                numerator += xDiff * yDiff;
                xSumSq += xDiff * xDiff;
                ySumSq += yDiff * yDiff;
            }
            
            const denominator = Math.sqrt(xSumSq * ySumSq);
            if (denominator === 0) return null;
            
            return numerator / denominator;
        }
        
        // Update asset class display with annualization option
        function updateAssetClassDisplay(assetStats) {
            const annualize = document.getElementById('annualizeReturns')?.checked || false;
            const regimes = ['Disinflationary Boom', 'Inflationary Boom', 'Disinflationary Bust', 'Inflationary Bust', 'Neutral'];
            const regimeColors = {
                'Disinflationary Boom': { bg: 'bg-green-900/20', border: 'border-green-700/30', text: 'text-green-400' },
                'Inflationary Boom': { bg: 'bg-yellow-900/20', border: 'border-yellow-700/30', text: 'text-yellow-400' },
                'Disinflationary Bust': { bg: 'bg-blue-900/20', border: 'border-blue-700/30', text: 'text-blue-400' },
                'Inflationary Bust': { bg: 'bg-red-900/20', border: 'border-red-700/30', text: 'text-red-400' },
                'Neutral': { bg: 'bg-gray-900/20', border: 'border-gray-700/30', text: 'text-gray-400' }
            };
            
            const container = document.getElementById('assetClassPerformance');
            container.innerHTML = regimes.map(regime => {
                const stats = assetStats[regime];
                const color = regimeColors[regime];
                
                return `
                    <div class="${color.bg} rounded-lg p-4 border ${color.border}">
                        <div class="${color.text} text-lg font-semibold mb-3">${regime}</div>
                        <div class="grid grid-cols-1 md:grid-cols-5 gap-4">
                            ${createAssetCard('Stocks', stats.stocks, 'text-green-400', annualize)}
                            ${createAssetCard('Bonds', stats.bonds, 'text-blue-400', annualize)}
                            ${createAssetCard('Commodities', stats.commodities, 'text-yellow-400', annualize)}
                            ${createAssetCard('Cash', stats.cash, 'text-gray-400', annualize)}
                            ${createAssetCard('Recommended Portfolio', stats.portfolio, 'text-purple-400', annualize)}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Helper function to create asset card
        function createAssetCard(assetName, stats, textColor, annualize = false) {
            if (!stats || stats.count === 0) {
                return `
                    <div class="bg-gray-900/50 rounded-lg p-3">
                        <div class="${textColor} text-sm font-semibold mb-2">${assetName}</div>
                        <div class="text-gray-500 text-xs">No data available</div>
                    </div>
                `;
            }
            
            // Annualize if requested: multiply by 12 for monthly to annual conversion
            const multiplier = annualize ? 12 : 1;
            const periodLabel = annualize ? 'Annual' : 'Monthly';
            
            // For volatility, annualize by multiplying by sqrt(12)
            const volMultiplier = annualize ? Math.sqrt(12) : 1;
            
            return `
                <div class="bg-gray-900/50 rounded-lg p-3">
                    <div class="${textColor} text-sm font-semibold mb-2">${assetName}</div>
                    <div class="space-y-1 text-xs">
                        <div class="flex justify-between">
                            <span class="text-gray-400">Avg Return</span>
                            <span class="text-white font-semibold">${(stats.avgReturn * 100 * multiplier).toFixed(2)}%</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Volatility</span>
                            <span class="text-white font-semibold">${(stats.volatility * 100 * volMultiplier).toFixed(2)}%</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Best ${periodLabel}</span>
                            <span class="text-green-400 font-semibold">${(stats.maxReturn * 100 * multiplier).toFixed(2)}%</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Worst ${periodLabel}</span>
                            <span class="text-red-400 font-semibold">${(stats.minReturn * 100 * multiplier).toFixed(2)}%</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Win Rate</span>
                            <span class="text-white font-semibold">${(stats.winRate * 100).toFixed(1)}%</span>
                        </div>
                        <div class="pt-1 border-t border-gray-700/50 text-gray-500">
                            ${stats.count} months
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Calculate statistics from returns array
        function calculateStats(returns) {
            if (!returns || returns.length === 0) {
                return { count: 0 };
            }
            
            const validReturns = returns.filter(r => !isNaN(r) && isFinite(r));
            if (validReturns.length === 0) {
                return { count: 0 };
            }
            
            const avgReturn = validReturns.reduce((sum, r) => sum + r, 0) / validReturns.length;
            const variance = validReturns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / validReturns.length;
            const volatility = Math.sqrt(variance);
            const maxReturn = Math.max(...validReturns);
            const minReturn = Math.min(...validReturns);
            const positiveCount = validReturns.filter(r => r > 0).length;
            const winRate = positiveCount / validReturns.length;
            
            return {
                count: validReturns.length,
                avgReturn,
                volatility,
                maxReturn,
                minReturn,
                winRate
            };
        }
        
        // Calculate monthly returns from price data
        function calculateMonthlyReturns(priceData) {
            if (!priceData || priceData.length < 2) return [];
            
            const returns = [];
            for (let i = 1; i < priceData.length; i++) {
                const current = priceData[i];
                const previous = priceData[i - 1];
                
                if (current.value > 0 && previous.value > 0) {
                    const monthlyReturn = (current.value / previous.value) - 1;
                    returns.push({
                        date: current.date,
                        return: monthlyReturn
                    });
                }
            }
            return returns;
        }
        
        // Calculate total returns (price + dividends/income)
        function calculateTotalReturns(priceData, incomeData, assetType) {
            if (!priceData || priceData.length < 2) return [];
            
            const returns = [];
            const incomeMap = new Map();
            
            // Create income map for quick lookup
            if (incomeData && incomeData.length > 0) {
                incomeData.forEach(item => {
                    const date = new Date(item.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    incomeMap.set(monthKey, item.value);
                });
            }
            
            for (let i = 1; i < priceData.length; i++) {
                const current = priceData[i];
                const previous = priceData[i - 1];
                
                if (current.value > 0 && previous.value > 0) {
                    // Price return
                    const priceReturn = (current.value / previous.value) - 1;
                    
                    // Add income component
                    let incomeReturn = 0;
                    const currentDate = new Date(current.date);
                    const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
                    
                    if (incomeMap.has(monthKey)) {
                        const income = incomeMap.get(monthKey);
                        if (assetType === 'stocks') {
                            // For stocks: dividend yield (annual) / 12 for monthly
                            incomeReturn = (income / previous.value) / 12;
                        } else if (assetType === 'bonds') {
                            // For bonds: yield (annual) / 12 for monthly coupon income
                            incomeReturn = (income / 100) / 12;
                        }
                    }
                    
                    // Total return = price return + income return
                    const totalReturn = priceReturn + incomeReturn;
                    
                    returns.push({
                        date: current.date,
                        return: totalReturn
                    });
                }
            }
            return returns;
        }
        
        // Calculate bond returns (approximate using yield changes)
        // Negative yield change = positive bond return (price appreciation)
        function calculateBondReturns(yieldData) {
            if (!yieldData || yieldData.length < 2) return [];
            
            const returns = [];
            for (let i = 1; i < yieldData.length; i++) {
                const current = yieldData[i];
                const previous = yieldData[i - 1];
                
                if (current.value > 0 && previous.value > 0) {
                    // Approximate bond return: -duration * yield_change + yield
                    // Using simplified model: -5 * yield_change + yield/12 (monthly)
                    const yieldChange = current.value - previous.value;
                    const monthlyReturn = (-5 * yieldChange / 100) + (previous.value / 100 / 12);
                    returns.push({
                        date: current.date,
                        return: monthlyReturn
                    });
                }
            }
            return returns;
        }
        
        // Calculate cash returns (use 3-month T-bill rate as monthly return)
        function calculateCashReturns(rateData) {
            if (!rateData || rateData.length === 0) return [];
            
            return rateData.map(item => ({
                date: item.date,
                return: (item.value / 100) / 12 // Convert annual rate to monthly
            }));
        }
        
        // Valuations chart instances
        let capeChartInstance = null;
        let marketCapGDPChartInstance = null;
        let peRatioChartInstance = null;
        let bondValuationChartInstance = null;
        
        // Load and display valuations data
        async function loadValuationsData() {
            const loadingEl = document.getElementById('valuationsLoading');
            const contentEl = document.getElementById('valuationsContent');
            
            try {
                loadingEl.classList.remove('hidden');
                contentEl.classList.add('hidden');
                loadingEl.innerHTML = `
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-blue-500"></div>
                    <p class="text-blue-400 mt-4 text-lg font-semibold">Loading valuation data from FRED...</p>
                `;
                
                console.log('Starting to fetch valuations data...');
                
                // Fetch valuation data
                const [sp500Data, sp500EarningsData, gdpData, yield10YData, yield2YData, dividendData, cpiData, corporateProfitsData, netWorthData] = await Promise.all([
                    fetchFREDData('SP500'), // S&P 500 Index
                    fetchFREDData('SP500E'), // S&P 500 Earnings
                    fetchFREDData('GDP'), // Nominal GDP
                    fetchFREDData('DGS10'), // 10-Year Treasury (daily - use DGS10 for current data)
                    fetchFREDData('DGS2'), // 2-Year Treasury (daily - use DGS2 for current data)
                    fetchFREDData('SP500DIV'), // S&P 500 Dividends
                    fetchFREDData('CPIAUCSL'), // CPI for inflation adjustment
                    fetchFREDData('A053RC1Q027SBEA'), // Corporate Profits After Tax (for sales proxy)
                    fetchFREDData('BOGZ1FL153064105Q') // Net Worth of Households and Nonprofit Organizations (for book value proxy)
                ]);
                
                if (!sp500Data || sp500Data.length === 0) {
                    throw new Error('No S&P 500 data available');
                }
                
                // Calculate CAPE (10-year average earnings, inflation-adjusted)
                const capeData = calculateCAPE(sp500Data, sp500EarningsData, cpiData);
                
                // Calculate Market Cap to GDP
                const marketCapGDPData = calculateMarketCapToGDP(sp500Data, gdpData);
                
                // Calculate PE Ratio and Earnings Yield
                const peData = calculatePERatio(sp500Data, sp500EarningsData);
                
                // Calculate Price to Book
                const priceToBookData = calculatePriceToBook(sp500Data, netWorthData, gdpData);
                
                // Calculate Price to Sales
                const priceToSalesData = calculatePriceToSales(sp500Data, corporateProfitsData, gdpData);
                
                // Calculate Q Ratio (Tobin's Q)
                const qRatioData = calculateQRatio(sp500Data, netWorthData, gdpData);
                
                // Get current values
                const currentCAPE = capeData.length > 0 ? capeData[capeData.length - 1].value : null;
                const currentMarketCapGDP = marketCapGDPData.length > 0 ? marketCapGDPData[marketCapGDPData.length - 1].value : null;
                const currentPE = peData.length > 0 ? peData[peData.length - 1].pe : null;
                const currentEarningsYield = peData.length > 0 ? peData[peData.length - 1].earningsYield : null;
                const currentDividendYield = calculateDividendYield(sp500Data, dividendData);
                const currentYield10Y = yield10YData.length > 0 ? yield10YData[yield10YData.length - 1].value : null;
                const currentYield2Y = yield2YData.length > 0 ? yield2YData[yield2YData.length - 1].value : null;
                const currentPriceToBook = priceToBookData.length > 0 ? priceToBookData[priceToBookData.length - 1].value : null;
                const currentPriceToSales = priceToSalesData.length > 0 ? priceToSalesData[priceToSalesData.length - 1].value : null;
                const currentQRatio = qRatioData.length > 0 ? qRatioData[qRatioData.length - 1].value : null;
                
                // Update current values
                if (currentCAPE !== null) {
                    document.getElementById('capeRatio').textContent = currentCAPE.toFixed(2);
                }
                if (currentMarketCapGDP !== null) {
                    document.getElementById('marketCapGDP').textContent = (currentMarketCapGDP * 100).toFixed(1) + '%';
                }
                if (currentPE !== null) {
                    document.getElementById('peRatio').textContent = currentPE.toFixed(2);
                }
                if (currentDividendYield !== null) {
                    document.getElementById('dividendYield').textContent = (currentDividendYield * 100).toFixed(2) + '%';
                }
                if (currentEarningsYield !== null) {
                    document.getElementById('earningsYield').textContent = (currentEarningsYield * 100).toFixed(2) + '%';
                }
                if (currentYield10Y !== null) {
                    document.getElementById('bondYield10Y').textContent = currentYield10Y.toFixed(2) + '%';
                }
                if (currentEarningsYield !== null && currentYield10Y !== null) {
                    const erp = (currentEarningsYield * 100) - currentYield10Y;
                    document.getElementById('equityRiskPremium').textContent = erp.toFixed(2) + '%';
                }
                if (currentYield10Y !== null && currentYield2Y !== null) {
                    const spread = currentYield10Y - currentYield2Y;
                    document.getElementById('yieldSpread').textContent = spread.toFixed(2) + '%';
                }
                if (currentPriceToBook !== null) {
                    document.getElementById('priceToBook').textContent = currentPriceToBook.toFixed(2);
                }
                if (currentPriceToSales !== null) {
                    document.getElementById('priceToSales').textContent = currentPriceToSales.toFixed(2);
                }
                if (currentQRatio !== null) {
                    document.getElementById('qRatio').textContent = currentQRatio.toFixed(2);
                }
                
                // Create charts
                createCAPEChart(capeData);
                createMarketCapGDPChart(marketCapGDPData);
                createPERatioChart(peData);
                createBondValuationChart(yield10YData, yield2YData);
                updateValuationPercentiles(capeData, marketCapGDPData, peData, priceToBookData, priceToSalesData, qRatioData);
                
                // Show content
                loadingEl.classList.add('hidden');
                contentEl.classList.remove('hidden');
                window.valuationsDataLoaded = true;
                
            } catch (error) {
                console.error('Error loading valuations data:', error);
                loadingEl.innerHTML = `
                    <div class="text-center">
                        <i class="fas fa-exclamation-circle text-red-400 text-4xl mb-4"></i>
                        <p class="text-red-400 text-lg font-semibold mb-2">Error loading valuations data</p>
                        <p class="text-gray-400 text-sm mb-4">${error.message}</p>
                        <button onclick="loadValuationsData()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">Retry</button>
                    </div>
                `;
            }
        }
        
        // Calculate CAPE (Cyclically Adjusted PE) with inflation adjustment
        function calculateCAPE(sp500Data, earningsData, cpiData) {
            if (!earningsData || earningsData.length === 0) return [];
            if (!cpiData || cpiData.length === 0) return [];
            
            const capeData = [];
            const earningsMap = new Map(earningsData.map(d => [d.date, d.value]));
            const cpiMap = new Map(cpiData.map(d => [d.date, d.value]));
            
            // Get latest CPI for inflation adjustment
            const latestCPI = cpiData[cpiData.length - 1].value;
            
            // Process earnings data - handle quarterly data by forward-filling
            const processedEarnings = [];
            sp500Data.forEach(priceItem => {
                const date = priceItem.date;
                // Find closest earnings date (within 3 months)
                let closestEarnings = null;
                let minDaysDiff = Infinity;
                
                earningsData.forEach(earnItem => {
                    const daysDiff = Math.abs((new Date(date) - new Date(earnItem.date)) / (1000 * 60 * 60 * 24));
                    if (daysDiff < minDaysDiff && daysDiff <= 90) {
                        minDaysDiff = daysDiff;
                        closestEarnings = earnItem;
                    }
                });
                
                if (closestEarnings) {
                    // Inflation adjust earnings to latest CPI
                    const earningsCPI = cpiMap.get(closestEarnings.date) || latestCPI;
                    const inflationAdjustedEarnings = closestEarnings.value * (latestCPI / earningsCPI);
                    processedEarnings.push({
                        date: date,
                        earnings: inflationAdjustedEarnings
                    });
                }
            });
            
            // Calculate CAPE using 10-year rolling average
            for (let i = 0; i < processedEarnings.length; i++) {
                const currentPrice = sp500Data[i].value;
                const currentDate = sp500Data[i].date;
                
                // Get last 10 years of inflation-adjusted earnings
                const earnings10Y = [];
                const currentDateObj = new Date(currentDate);
                const tenYearsAgo = new Date(currentDateObj);
                tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
                
                for (let j = 0; j <= i; j++) {
                    const earnDate = new Date(processedEarnings[j].date);
                    if (earnDate >= tenYearsAgo && earnDate <= currentDateObj) {
                        earnings10Y.push(processedEarnings[j].earnings);
                    }
                }
                
                // Need at least 8 years of data (32 quarters or ~96 months)
                if (earnings10Y.length >= 32) {
                    const avgEarnings = earnings10Y.reduce((sum, e) => sum + e, 0) / earnings10Y.length;
                    if (avgEarnings > 0) {
                        capeData.push({
                            date: currentDate,
                            value: currentPrice / avgEarnings
                        });
                    }
                }
            }
            
            return capeData;
        }
        
        // Calculate Market Cap to GDP
        function calculateMarketCapToGDP(sp500Data, gdpData) {
            if (!gdpData || gdpData.length === 0) return [];
            
            const result = [];
            const gdpMap = new Map();
            
            // GDP is quarterly, so we'll use quarterly values
            gdpData.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                if (!gdpMap.has(quarterKey) || new Date(item.date) > new Date(gdpMap.get(quarterKey).date)) {
                    gdpMap.set(quarterKey, item);
                }
            });
            
            sp500Data.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                
                if (gdpMap.has(quarterKey)) {
                    const gdp = gdpMap.get(quarterKey).value;
                    // Approximate market cap as SP500 * 10 (rough multiplier)
                    // More accurate would use actual market cap data
                    const marketCap = item.value * 10;
                    result.push({
                        date: item.date,
                        value: marketCap / gdp
                    });
                }
            });
            
            return result;
        }
        
        // Calculate PE Ratio and Earnings Yield
        function calculatePERatio(sp500Data, earningsData) {
            if (!earningsData || earningsData.length === 0) return [];
            
            const result = [];
            const earningsMap = new Map(earningsData.map(d => [d.date, d.value]));
            
            sp500Data.forEach(item => {
                if (earningsMap.has(item.date)) {
                    const earnings = earningsMap.get(item.date);
                    if (earnings > 0) {
                        const pe = item.value / earnings;
                        result.push({
                            date: item.date,
                            pe: pe,
                            earningsYield: 1 / pe
                        });
                    }
                }
            });
            
            return result;
        }
        
        // Calculate Dividend Yield
        function calculateDividendYield(sp500Data, dividendData) {
            if (!dividendData || dividendData.length === 0) return null;
            if (!sp500Data || sp500Data.length === 0) return null;
            
            const latestPrice = sp500Data[sp500Data.length - 1].value;
            const latestDividend = dividendData[dividendData.length - 1].value;
            
            if (latestPrice > 0) {
                return latestDividend / latestPrice;
            }
            return null;
        }
        
        // Calculate Price to Book (using net worth as proxy for book value)
        function calculatePriceToBook(sp500Data, netWorthData, gdpData) {
            if (!netWorthData || netWorthData.length === 0) return [];
            if (!gdpData || gdpData.length === 0) return [];
            
            const result = [];
            const netWorthMap = new Map();
            const gdpMap = new Map();
            
            // Net worth is quarterly
            netWorthData.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                if (!netWorthMap.has(quarterKey) || new Date(item.date) > new Date(netWorthMap.get(quarterKey).date)) {
                    netWorthMap.set(quarterKey, item);
                }
            });
            
            gdpData.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                if (!gdpMap.has(quarterKey) || new Date(item.date) > new Date(gdpMap.get(quarterKey).date)) {
                    gdpMap.set(quarterKey, item);
                }
            });
            
            sp500Data.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                
                if (netWorthMap.has(quarterKey) && gdpMap.has(quarterKey)) {
                    const netWorth = netWorthMap.get(quarterKey).value;
                    const gdp = gdpMap.get(quarterKey).value;
                    // Approximate market cap
                    const marketCap = item.value * 10;
                    // Use net worth as proxy for book value (household + corporate net worth)
                    // Adjust by GDP to get equity book value proxy
                    const bookValueProxy = (netWorth / gdp) * marketCap * 0.5; // Rough estimate
                    if (bookValueProxy > 0) {
                        result.push({
                            date: item.date,
                            value: marketCap / bookValueProxy
                        });
                    }
                }
            });
            
            return result;
        }
        
        // Calculate Price to Sales (using corporate profits as proxy)
        function calculatePriceToSales(sp500Data, corporateProfitsData, gdpData) {
            if (!corporateProfitsData || corporateProfitsData.length === 0) return [];
            if (!gdpData || gdpData.length === 0) return [];
            
            const result = [];
            const profitsMap = new Map();
            const gdpMap = new Map();
            
            // Corporate profits is quarterly
            corporateProfitsData.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                if (!profitsMap.has(quarterKey) || new Date(item.date) > new Date(profitsMap.get(quarterKey).date)) {
                    profitsMap.set(quarterKey, item);
                }
            });
            
            gdpData.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                if (!gdpMap.has(quarterKey) || new Date(item.date) > new Date(gdpMap.get(quarterKey).date)) {
                    gdpMap.set(quarterKey, item);
                }
            });
            
            sp500Data.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                
                if (profitsMap.has(quarterKey) && gdpMap.has(quarterKey)) {
                    const profits = profitsMap.get(quarterKey).value;
                    const gdp = gdpMap.get(quarterKey).value;
                    // Approximate market cap
                    const marketCap = item.value * 10;
                    // Estimate sales from profits (assume ~10% profit margin)
                    const salesProxy = profits * 10;
                    if (salesProxy > 0) {
                        result.push({
                            date: item.date,
                            value: marketCap / salesProxy
                        });
                    }
                }
            });
            
            return result;
        }
        
        // Calculate Q Ratio (Tobin's Q) - Market Value / Replacement Cost
        function calculateQRatio(sp500Data, netWorthData, gdpData) {
            if (!netWorthData || netWorthData.length === 0) return [];
            if (!gdpData || gdpData.length === 0) return [];
            
            const result = [];
            const netWorthMap = new Map();
            const gdpMap = new Map();
            
            netWorthData.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                if (!netWorthMap.has(quarterKey) || new Date(item.date) > new Date(netWorthMap.get(quarterKey).date)) {
                    netWorthMap.set(quarterKey, item);
                }
            });
            
            gdpData.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                if (!gdpMap.has(quarterKey) || new Date(item.date) > new Date(gdpMap.get(quarterKey).date)) {
                    gdpMap.set(quarterKey, item);
                }
            });
            
            sp500Data.forEach(item => {
                const date = new Date(item.date);
                const quarter = Math.floor(date.getMonth() / 3);
                const quarterKey = `${date.getFullYear()}-Q${quarter + 1}`;
                
                if (netWorthMap.has(quarterKey) && gdpMap.has(quarterKey)) {
                    const netWorth = netWorthMap.get(quarterKey).value;
                    const gdp = gdpMap.get(quarterKey).value;
                    // Approximate market cap
                    const marketCap = item.value * 10;
                    // Use net worth as proxy for replacement cost
                    const replacementCostProxy = (netWorth / gdp) * marketCap * 0.5;
                    if (replacementCostProxy > 0) {
                        result.push({
                            date: item.date,
                            value: marketCap / replacementCostProxy
                        });
                    }
                }
            });
            
            return result;
        }
        
        // Create CAPE chart
        function createCAPEChart(capeData) {
            const ctx = document.getElementById('capeChart');
            if (!ctx) return;
            
            if (capeChartInstance) {
                capeChartInstance.destroy();
            }
            
            const labels = capeData.map(d => {
                const date = new Date(d.date);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            });
            
            capeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'CAPE Ratio',
                        data: capeData.map(d => d.value),
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        fill: true,
                        tension: 0.4
                    }, {
                        label: 'Historical Average (17)',
                        data: capeData.map(() => 17),
                        borderColor: 'rgba(156, 163, 175, 0.5)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }, {
                        label: 'Expensive Threshold (25)',
                        data: capeData.map(() => 25),
                        borderColor: 'rgba(239, 68, 68, 0.5)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#9ca3af' }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#d1d5db'
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af', maxRotation: 45, minRotation: 45 }
                        },
                        y: {
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af' },
                            title: {
                                display: true,
                                text: 'CAPE Ratio',
                                color: '#9ca3af'
                            }
                        }
                    }
                }
            });
        }
        
        // Create Market Cap to GDP chart
        function createMarketCapGDPChart(marketCapGDPData) {
            const ctx = document.getElementById('marketCapGDPChart');
            if (!ctx) return;
            
            if (marketCapGDPChartInstance) {
                marketCapGDPChartInstance.destroy();
            }
            
            const labels = marketCapGDPData.map(d => {
                const date = new Date(d.date);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            });
            
            marketCapGDPChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Market Cap / GDP (%)',
                        data: marketCapGDPData.map(d => d.value * 100),
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        fill: true,
                        tension: 0.4
                    }, {
                        label: 'Historical Average (85%)',
                        data: marketCapGDPData.map(() => 85),
                        borderColor: 'rgba(156, 163, 175, 0.5)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }, {
                        label: 'Overvalued (100%)',
                        data: marketCapGDPData.map(() => 100),
                        borderColor: 'rgba(239, 68, 68, 0.5)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#9ca3af' }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#d1d5db'
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af', maxRotation: 45, minRotation: 45 }
                        },
                        y: {
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af' },
                            title: {
                                display: true,
                                text: 'Market Cap / GDP (%)',
                                color: '#9ca3af'
                            }
                        }
                    }
                }
            });
        }
        
        // Create PE Ratio chart
        function createPERatioChart(peData) {
            const ctx = document.getElementById('peRatioChart');
            if (!ctx) return;
            
            if (peRatioChartInstance) {
                peRatioChartInstance.destroy();
            }
            
            const labels = peData.map(d => {
                const date = new Date(d.date);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            });
            
            peRatioChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'PE Ratio',
                        data: peData.map(d => d.pe),
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        fill: true,
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: 'Earnings Yield (%)',
                        data: peData.map(d => d.earningsYield * 100),
                        borderColor: '#22c55e',
                        backgroundColor: 'rgba(34, 197, 94, 0.1)',
                        fill: true,
                        tension: 0.4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#9ca3af' }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#d1d5db'
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af', maxRotation: 45, minRotation: 45 }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af' },
                            title: {
                                display: true,
                                text: 'PE Ratio',
                                color: '#9ca3af'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: { color: '#9ca3af' },
                            title: {
                                display: true,
                                text: 'Earnings Yield (%)',
                                color: '#9ca3af'
                            }
                        }
                    }
                }
            });
        }
        
        // Create Bond Valuation chart
        function createBondValuationChart(yield10YData, yield2YData) {
            const ctx = document.getElementById('bondValuationChart');
            if (!ctx) return;
            
            if (bondValuationChartInstance) {
                bondValuationChartInstance.destroy();
            }
            
            // Align dates
            const alignedData = [];
            const yield2YMap = new Map(yield2YData.map(d => [d.date, d.value]));
            
            yield10YData.forEach(item => {
                if (yield2YMap.has(item.date)) {
                    alignedData.push({
                        date: item.date,
                        yield10Y: item.value,
                        yield2Y: yield2YMap.get(item.date),
                        spread: item.value - yield2YMap.get(item.date)
                    });
                }
            });
            
            const labels = alignedData.map(d => {
                const date = new Date(d.date);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            });
            
            bondValuationChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '10Y Treasury Yield',
                        data: alignedData.map(d => d.yield10Y),
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        fill: true,
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: '2Y Treasury Yield',
                        data: alignedData.map(d => d.yield2Y),
                        borderColor: '#22c55e',
                        backgroundColor: 'rgba(34, 197, 94, 0.1)',
                        fill: true,
                        tension: 0.4,
                        yAxisID: 'y'
                    }, {
                        label: 'Yield Spread (10Y - 2Y)',
                        data: alignedData.map(d => d.spread),
                        borderColor: '#eab308',
                        backgroundColor: 'rgba(234, 179, 8, 0.1)',
                        fill: true,
                        tension: 0.4,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#9ca3af' }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(17, 24, 39, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#d1d5db'
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af', maxRotation: 45, minRotation: 45 }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            ticks: { color: '#9ca3af' },
                            title: {
                                display: true,
                                text: 'Yield (%)',
                                color: '#9ca3af'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            ticks: { color: '#9ca3af' },
                            title: {
                                display: true,
                                text: 'Spread (%)',
                                color: '#9ca3af'
                            }
                        }
                    }
                }
            });
        }
        
        // Update valuation percentiles
        function updateValuationPercentiles(capeData, marketCapGDPData, peData, priceToBookData, priceToSalesData, qRatioData) {
            const container = document.getElementById('valuationPercentiles');
            
            const calculatePercentile = (value, data) => {
                if (!data || data.length === 0) return null;
                const sorted = data.map(d => d.value || d.pe || d.earningsYield).sort((a, b) => a - b);
                const index = sorted.findIndex(v => v >= value);
                return index === -1 ? 100 : (index / sorted.length) * 100;
            };
            
            const currentCAPE = capeData.length > 0 ? capeData[capeData.length - 1].value : null;
            const currentMarketCapGDP = marketCapGDPData.length > 0 ? marketCapGDPData[marketCapGDPData.length - 1].value : null;
            const currentPE = peData.length > 0 ? peData[peData.length - 1].pe : null;
            const currentPriceToBook = priceToBookData && priceToBookData.length > 0 ? priceToBookData[priceToBookData.length - 1].value : null;
            const currentPriceToSales = priceToSalesData && priceToSalesData.length > 0 ? priceToSalesData[priceToSalesData.length - 1].value : null;
            const currentQRatio = qRatioData && qRatioData.length > 0 ? qRatioData[qRatioData.length - 1].value : null;
            
            const capePercentile = currentCAPE !== null ? calculatePercentile(currentCAPE, capeData) : null;
            const marketCapGDPPercentile = currentMarketCapGDP !== null ? calculatePercentile(currentMarketCapGDP, marketCapGDPData) : null;
            const pePercentile = currentPE !== null ? calculatePercentile(currentPE, peData) : null;
            const priceToBookPercentile = currentPriceToBook !== null ? calculatePercentile(currentPriceToBook, priceToBookData) : null;
            const priceToSalesPercentile = currentPriceToSales !== null ? calculatePercentile(currentPriceToSales, priceToSalesData) : null;
            const qRatioPercentile = currentQRatio !== null ? calculatePercentile(currentQRatio, qRatioData) : null;
            
            const getPercentileColor = (percentile) => {
                if (percentile >= 80) return 'text-red-400';
                if (percentile >= 60) return 'text-yellow-400';
                if (percentile >= 40) return 'text-blue-400';
                return 'text-green-400';
            };
            
            const getPercentileLabel = (percentile) => {
                if (percentile >= 80) return 'Very Expensive';
                if (percentile >= 60) return 'Expensive';
                if (percentile >= 40) return 'Fair Value';
                return 'Cheap';
            };
            
            container.innerHTML = `
                <table class="w-full text-left border-collapse">
                    <thead>
                        <tr class="border-b border-gray-700">
                            <th class="p-3 text-gray-400 font-semibold">Metric</th>
                            <th class="p-3 text-gray-400 font-semibold">Current Value</th>
                            <th class="p-3 text-gray-400 font-semibold">Percentile</th>
                            <th class="p-3 text-gray-400 font-semibold">Valuation</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-700/50">
                        <tr>
                            <td class="p-3 text-gray-300">CAPE Ratio</td>
                            <td class="p-3 text-white font-semibold">${currentCAPE !== null ? currentCAPE.toFixed(2) : '--'}</td>
                            <td class="p-3 ${capePercentile !== null ? getPercentileColor(capePercentile) : 'text-gray-400'} font-semibold">${capePercentile !== null ? capePercentile.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 ${capePercentile !== null ? getPercentileColor(capePercentile) : 'text-gray-400'} font-semibold">${capePercentile !== null ? getPercentileLabel(capePercentile) : '--'}</td>
                        </tr>
                        <tr>
                            <td class="p-3 text-gray-300">Market Cap / GDP</td>
                            <td class="p-3 text-white font-semibold">${currentMarketCapGDP !== null ? (currentMarketCapGDP * 100).toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 ${marketCapGDPPercentile !== null ? getPercentileColor(marketCapGDPPercentile) : 'text-gray-400'} font-semibold">${marketCapGDPPercentile !== null ? marketCapGDPPercentile.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 ${marketCapGDPPercentile !== null ? getPercentileColor(marketCapGDPPercentile) : 'text-gray-400'} font-semibold">${marketCapGDPPercentile !== null ? getPercentileLabel(marketCapGDPPercentile) : '--'}</td>
                        </tr>
                        <tr>
                            <td class="p-3 text-gray-300">PE Ratio</td>
                            <td class="p-3 text-white font-semibold">${currentPE !== null ? currentPE.toFixed(2) : '--'}</td>
                            <td class="p-3 ${pePercentile !== null ? getPercentileColor(pePercentile) : 'text-gray-400'} font-semibold">${pePercentile !== null ? pePercentile.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 ${pePercentile !== null ? getPercentileColor(pePercentile) : 'text-gray-400'} font-semibold">${pePercentile !== null ? getPercentileLabel(pePercentile) : '--'}</td>
                        </tr>
                        <tr>
                            <td class="p-3 text-gray-300">Price to Book</td>
                            <td class="p-3 text-white font-semibold">${currentPriceToBook !== null ? currentPriceToBook.toFixed(2) : '--'}</td>
                            <td class="p-3 ${priceToBookPercentile !== null ? getPercentileColor(priceToBookPercentile) : 'text-gray-400'} font-semibold">${priceToBookPercentile !== null ? priceToBookPercentile.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 ${priceToBookPercentile !== null ? getPercentileColor(priceToBookPercentile) : 'text-gray-400'} font-semibold">${priceToBookPercentile !== null ? getPercentileLabel(priceToBookPercentile) : '--'}</td>
                        </tr>
                        <tr>
                            <td class="p-3 text-gray-300">Price to Sales</td>
                            <td class="p-3 text-white font-semibold">${currentPriceToSales !== null ? currentPriceToSales.toFixed(2) : '--'}</td>
                            <td class="p-3 ${priceToSalesPercentile !== null ? getPercentileColor(priceToSalesPercentile) : 'text-gray-400'} font-semibold">${priceToSalesPercentile !== null ? priceToSalesPercentile.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 ${priceToSalesPercentile !== null ? getPercentileColor(priceToSalesPercentile) : 'text-gray-400'} font-semibold">${priceToSalesPercentile !== null ? getPercentileLabel(priceToSalesPercentile) : '--'}</td>
                        </tr>
                        <tr>
                            <td class="p-3 text-gray-300">Q Ratio (Tobin's Q)</td>
                            <td class="p-3 text-white font-semibold">${currentQRatio !== null ? currentQRatio.toFixed(2) : '--'}</td>
                            <td class="p-3 ${qRatioPercentile !== null ? getPercentileColor(qRatioPercentile) : 'text-gray-400'} font-semibold">${qRatioPercentile !== null ? qRatioPercentile.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 ${qRatioPercentile !== null ? getPercentileColor(qRatioPercentile) : 'text-gray-400'} font-semibold">${qRatioPercentile !== null ? getPercentileLabel(qRatioPercentile) : '--'}</td>
                        </tr>
                    </tbody>
                </table>
            `;
        }
        
        // Process Term Premium
        function processTermPremium(termPremium2YData, termPremium10YData) {
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            termPremium2YData.forEach(item => dateMap.set(item.date, { tp2Y: item.value }));
            termPremium10YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).tp10Y = item.value;
                }
            });
            
            dateMap.forEach((values, date) => {
                if (values.tp2Y !== undefined && values.tp10Y !== undefined) {
                    combinedData.push({
                        date: date,
                        tp2Y: values.tp2Y,
                        tp10Y: values.tp10Y
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Store full data for zoom
            termPremiumFullData = combinedData;
            
            // Apply zoom filter if active
            let chartData = termPremiumZoom24 ? filterTo24Months(combinedData) : combinedData;
            
            const latest = combinedData[combinedData.length - 1];
            
            // Update display
            document.getElementById('termPremium2Y').textContent = (latest.tp2Y >= 0 ? '+' : '') + latest.tp2Y.toFixed(3) + '%';
            document.getElementById('termPremium10Y').textContent = (latest.tp10Y >= 0 ? '+' : '') + latest.tp10Y.toFixed(3) + '%';
            
            const termPremiumDateEl = document.getElementById('termPremiumLatestDate');
            if (termPremiumDateEl) termPremiumDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis with market timing insights
            const analysisEl = document.getElementById('termPremiumAnalysis');
            let analysisText = '';
            const previous = combinedData.length > 1 ? combinedData[combinedData.length - 2] : latest;
            const tp10YChange = latest.tp10Y - previous.tp10Y;
            
            if (latest.tp2Y < 0 && latest.tp10Y < 0) {
                analysisText = `Both term premiums are negative (2Y: ${latest.tp2Y.toFixed(3)}%, 10Y: ${latest.tp10Y.toFixed(3)}%). This signals "bond mania" - investors are so desperate for safety they aren't demanding a risk premium. Typically occurs during peak liquidity and can support equity markets.`;
            } else if (latest.tp10Y < 0) {
                analysisText = `10-Year term premium is negative (${latest.tp10Y.toFixed(3)}%), indicating bond market stress or peak liquidity conditions. Investors aren't demanding compensation for duration risk. 2Y premium: ${(latest.tp2Y >= 0 ? '+' : '') + latest.tp2Y.toFixed(3)}%.`;
            } else if (tp10YChange > 0.3) {
                analysisText = `Term premium is spiking (10Y: ${latest.tp10Y.toFixed(3)}%, up ${tp10YChange.toFixed(3)}pp). This acts as a headwind for stocks - rising risk-free rates reflect investor nervousness, not just economic growth. 2Y: ${(latest.tp2Y >= 0 ? '+' : '') + latest.tp2Y.toFixed(3)}%.`;
            } else if (latest.tp2Y > 0 && latest.tp10Y > 0) {
                analysisText = `Both term premiums are positive (2Y: ${latest.tp2Y.toFixed(3)}%, 10Y: ${latest.tp10Y.toFixed(3)}%). Markets demand compensation for duration risk. Higher premiums suggest uncertainty about future rates and can pressure equity valuations.`;
            } else {
                analysisText = `Mixed term premium signals. 2Y: ${(latest.tp2Y >= 0 ? '+' : '') + latest.tp2Y.toFixed(3)}%, 10Y: ${(latest.tp10Y >= 0 ? '+' : '') + latest.tp10Y.toFixed(3)}%.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('termPremiumChart');
            if (termPremiumChartInstance) {
                termPremiumChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            const tp2YValues = chartData.map(d => d.tp2Y);
            const tp10YValues = chartData.map(d => d.tp10Y);
            const tpDiffValues = chartData.map(d => d.tp10Y - d.tp2Y);
            const zeroLine = new Array(chartData.length).fill(0);
            
            termPremiumChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '2-Year Term Premium',
                        data: tp2YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10-Year Term Premium',
                        data: tp10YValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '10Y - 2Y Term Premium Spread',
                        data: tpDiffValues,
                        borderColor: '#6b7280',
                        backgroundColor: 'rgba(107, 114, 128, 0.1)',
                        borderWidth: 1.5,
                        borderDash: [4, 4],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        hidden: true
                    }, {
                        label: 'Zero Line',
                        data: zeroLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return (value >= 0 ? '+' : '') + value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                }
            });
        }
        
        // Process Inflation Expectations
        function processInflationExpectations(inflation10YData, inflation5Y5YData, cpiData) {
            // Calculate YoY CPI inflation
            const cpiYoY = [];
            if (cpiData && cpiData.length > 0) {
                cpiData.sort((a, b) => new Date(a.date) - new Date(b.date));
                for (let i = 12; i < cpiData.length; i++) {
                    const current = cpiData[i].value;
                    const previous = cpiData[i - 12].value;
                    if (previous !== 0 && !isNaN(current) && !isNaN(previous)) {
                        const yoyChange = ((current / previous) - 1) * 100;
                        cpiYoY.push({
                            date: cpiData[i].date,
                            value: yoyChange
                        });
                    }
                }
            }
            
            // Align dates
            const combinedData = [];
            const dateMap = new Map();
            
            inflation10YData.forEach(item => dateMap.set(item.date, { inf10Y: item.value }));
            inflation5Y5YData.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).inf5Y5Y = item.value;
                }
            });
            
            // Add actual CPI YoY inflation to date map - forward-fill monthly CPI values across daily dates
            // CPI is monthly, inflation expectations are daily, so we forward-fill each month's value
            cpiYoY.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Create a sorted list of all dates from dateMap for forward-filling
            const sortedDates = Array.from(dateMap.keys()).sort((a, b) => new Date(a) - new Date(b));
            let currentCpiValue = null;
            let cpiIndex = 0;
            
            sortedDates.forEach(date => {
                const dateObj = new Date(date);
                const dateYear = dateObj.getFullYear();
                const dateMonth = dateObj.getMonth();
                
                // Find the most recent CPI value that applies to this date
                // CPI values are monthly, so we use the CPI from the same month or the most recent previous month
                while (cpiIndex < cpiYoY.length) {
                    const cpiDate = new Date(cpiYoY[cpiIndex].date);
                    const cpiYear = cpiDate.getFullYear();
                    const cpiMonth = cpiDate.getMonth();
                    
                    // Check if this CPI value is for the current month or earlier
                    if (cpiYear < dateYear || (cpiYear === dateYear && cpiMonth <= dateMonth)) {
                        currentCpiValue = cpiYoY[cpiIndex].value;
                        
                        // Check if there's a newer CPI value that also applies
                        if (cpiIndex < cpiYoY.length - 1) {
                            const nextCpiDate = new Date(cpiYoY[cpiIndex + 1].date);
                            const nextCpiYear = nextCpiDate.getFullYear();
                            const nextCpiMonth = nextCpiDate.getMonth();
                            
                            if (nextCpiYear < dateYear || (nextCpiYear === dateYear && nextCpiMonth <= dateMonth)) {
                                // Move to the newer CPI value
                                cpiIndex++;
                                currentCpiValue = cpiYoY[cpiIndex].value;
                            } else {
                                // This is the most recent CPI value for this date
                                break;
                            }
                        } else {
                            // This is the last CPI value
                            break;
                        }
                    } else {
                        // This CPI value is in the future, stop and use current value
                        break;
                    }
                }
                
                // Assign the CPI value to this date (forward-fill)
                if (currentCpiValue !== null && dateMap.has(date)) {
                    dateMap.get(date).actualInf = currentCpiValue;
                }
            });
            
            // Include all dates that have both inflation expectations (main chart data)
            dateMap.forEach((values, date) => {
                if (values.inf10Y !== undefined && values.inf5Y5Y !== undefined) {
                    combinedData.push({
                        date: date,
                        inf10Y: values.inf10Y,
                        inf5Y5Y: values.inf5Y5Y,
                        actualInf: values.actualInf // Will be undefined if no CPI data for this date
                    });
                }
            });
            
            if (combinedData.length === 0) return;
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Store full data for zoom functionality
            inflationChartFullData = combinedData;
            
            // Filter to last 10 years only
            const tenYearsAgo = new Date();
            tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
            const filteredData = combinedData.filter(d => new Date(d.date) >= tenYearsAgo);
            
            // Use filtered data (last 10 years) for display and chart, apply zoom if active
            const baseData = filteredData.length > 0 ? filteredData : combinedData;
            const chartData = inflationChartZoom24 ? filterTo24Months(baseData) : baseData;
            const latest = chartData.length > 0 ? chartData[chartData.length - 1] : combinedData[combinedData.length - 1];
            
            // Update display
            document.getElementById('inflation10Y').textContent = latest.inf10Y.toFixed(2) + '%';
            document.getElementById('inflation5Y5Y').textContent = latest.inf5Y5Y.toFixed(2) + '%';
            
            const inflationExpectDateEl = document.getElementById('inflationExpectLatestDate');
            if (inflationExpectDateEl) inflationExpectDateEl.textContent = formatLatestDate(latest.date);
            
            // Analysis
            const analysisEl = document.getElementById('inflationAnalysis');
            let analysisText = '';
            const avg = (latest.inf10Y + latest.inf5Y5Y) / 2;
            if (avg > 2.5) {
                analysisText = `Inflation expectations are elevated (10Y: ${latest.inf10Y.toFixed(2)}%, 5Y-5Y: ${latest.inf5Y5Y.toFixed(2)}%). Markets expect sustained higher inflation, which may pressure the Fed to maintain tighter policy.`;
            } else if (avg < 1.5) {
                analysisText = `Inflation expectations are low (10Y: ${latest.inf10Y.toFixed(2)}%, 5Y-5Y: ${latest.inf5Y5Y.toFixed(2)}%). Markets expect subdued inflation, giving the Fed room for accommodative policy.`;
            } else {
                analysisText = `Inflation expectations are moderate (10Y: ${latest.inf10Y.toFixed(2)}%, 5Y-5Y: ${latest.inf5Y5Y.toFixed(2)}%). Markets expect inflation near the Fed's 2% target.`;
            }
            
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('inflationChart');
            if (!ctx) {
                console.error('Inflation chart canvas not found');
                return;
            }
            if (inflationChartInstance) {
                inflationChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            const inf10YValues = chartData.map(d => d.inf10Y);
            const inf5Y5YValues = chartData.map(d => d.inf5Y5Y);
            const targetLine = new Array(chartData.length).fill(2.0);
            
            // Calculate min and max for Y-axis (for inflation expectations and target)
            const allYValues = [...inf10YValues, ...inf5Y5YValues, ...targetLine].filter(v => v !== null && v !== undefined && !isNaN(v));
            const yMin = Math.min(...allYValues);
            const yMax = Math.max(...allYValues);
            const yRange = yMax - yMin;
            const yPadding = yRange * 0.05; // 5% padding
            
            inflationChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '10-Year Breakeven',
                        data: inf10YValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: '5Y-5Y Forward',
                        data: inf5Y5YValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Fed Target (2%)',
                        data: targetLine,
                        borderColor: '#9ca3af',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            min: yMin - yPadding,
                            max: yMax + yPadding,
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                }
            });
        }
        
        // Process Real Yields
        function processRealYields(realYield10YData, yield10YData = null) {
            if (realYield10YData.length === 0) return;
            
            realYield10YData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Align nominal yield data with real yield data if available
            let alignedNominalYields = null;
            if (yield10YData && yield10YData.length > 0) {
                yield10YData.sort((a, b) => new Date(a.date) - new Date(b.date));
                const nominalMap = new Map(yield10YData.map(d => [d.date, d.value]));
                
                // Create aligned nominal yields for the same dates as real yields
                alignedNominalYields = realYield10YData.map(d => {
                    const nominalValue = nominalMap.get(d.date);
                    return nominalValue !== undefined && !isNaN(nominalValue) ? nominalValue : null;
                });
            }
            
            // Store full data for zoom
            realYieldFullData = realYield10YData;
            if (yield10YData && yield10YData.length > 0) {
                yield10YFullData = yield10YData;
            }
            
            // Apply zoom filter if active (default to 24 months)
            let chartData = realYieldZoom24 ? filterTo24Months(realYield10YData) : realYield10YData;
            
            // Also filter nominal yields if available
            let alignedNominalYieldsFiltered = null;
            if (alignedNominalYields) {
                if (realYieldZoom24) {
                    // Filter to same dates as chartData (24 months)
                    const chartDataDates = new Set(chartData.map(d => d.date));
                    alignedNominalYieldsFiltered = realYield10YData
                        .filter(d => chartDataDates.has(d.date))
                        .map((d, idx) => {
                            const originalIdx = realYield10YData.findIndex(rd => rd.date === d.date);
                            return alignedNominalYields[originalIdx];
                        });
                } else {
                    alignedNominalYieldsFiltered = alignedNominalYields;
                }
            }
            
            const latest = realYield10YData[realYield10YData.length - 1];
            const previous = realYield10YData.length > 1 ? realYield10YData[realYield10YData.length - 2] : latest;
            const change = latest.value - previous.value;
            
            // Update display
            document.getElementById('realYield10Y').textContent = (latest.value >= 0 ? '+' : '') + latest.value.toFixed(2) + '%';
            
            const realYieldDateEl = document.getElementById('realYieldLatestDate');
            if (realYieldDateEl) realYieldDateEl.textContent = formatLatestDate(latest.date);
            
            // Calculate historical statistics for context
            const allValues = realYield10YData.map(d => d.value).filter(v => !isNaN(v));
            const historicalMean = allValues.reduce((a, b) => a + b, 0) / allValues.length;
            const sortedValues = [...allValues].sort((a, b) => a - b);
            const historicalMedian = sortedValues[Math.floor(sortedValues.length / 2)];
            const p25 = sortedValues[Math.floor(sortedValues.length * 0.25)];
            const p75 = sortedValues[Math.floor(sortedValues.length * 0.75)];
            
            // Calculate percentile relative to current value
            const percentile = (sortedValues.filter(v => v <= latest.value).length / sortedValues.length) * 100;
            
            // Analysis with historical context
            const analysisEl = document.getElementById('realYieldAnalysis');
            let analysisText = '';
            
            // Build analysis with historical comparison
            const vsMean = latest.value - historicalMean;
            const vsMedian = latest.value - historicalMedian;
            
            if (latest.value > 1.0) {
                analysisText = `Real yields are positive and elevated (${latest.value.toFixed(2)}%, ${percentile.toFixed(0)}th percentile). `;
                if (vsMean > 0.5) {
                    analysisText += `This is ${vsMean.toFixed(2)}pp above the historical average (${historicalMean.toFixed(2)}%). `;
                }
                analysisText += `Investors are being well-compensated for inflation risk. This suggests tight financial conditions.`;
            } else if (latest.value > 0) {
                analysisText = `Real yields are positive but low (${latest.value.toFixed(2)}%, ${percentile.toFixed(0)}th percentile). `;
                if (Math.abs(vsMean) > 0.3) {
                    analysisText += `This is ${vsMean >= 0 ? vsMean.toFixed(2) + 'pp above' : Math.abs(vsMean).toFixed(2) + 'pp below'} the historical average (${historicalMean.toFixed(2)}%). `;
                }
                analysisText += `Investors receive modest compensation after inflation. Financial conditions are accommodative.`;
            } else {
                analysisText = `Real yields are negative (${latest.value.toFixed(2)}%, ${percentile.toFixed(0)}th percentile). `;
                if (vsMean < -0.5) {
                    analysisText += `This is ${Math.abs(vsMean).toFixed(2)}pp below the historical average (${historicalMean.toFixed(2)}%). `;
                }
                analysisText += `Investors are not compensated for inflation, indicating very accommodative policy and potential asset price inflation.`;
            }
            
            // Add historical range context
            analysisText += ` Historical range: ${sortedValues[0].toFixed(2)}% to ${sortedValues[sortedValues.length - 1].toFixed(2)}% (median: ${historicalMedian.toFixed(2)}%).`;
            
            if (change !== 0) {
                analysisText += ` Recent change: ${change >= 0 ? '+' : ''}${change.toFixed(2)}pp.`;
            }
            analysisEl.textContent = analysisText;
            
            // Create chart
            const ctx = document.getElementById('realYieldChart');
            if (realYieldChartInstance) {
                realYieldChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            const values = chartData.map(d => d.value);
            
            // Prepare datasets array - only show 10-year nominal and 10-year real yield
            const datasets = [];
            
            // Add nominal yield line if available
            if (alignedNominalYieldsFiltered && alignedNominalYieldsFiltered.some(v => v !== null)) {
                datasets.push({
                    label: '10-Year Nominal Yield',
                    data: alignedNominalYieldsFiltered,
                    borderColor: '#ef4444',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    order: 0
                });
            }
            
            // Add real yield line
            datasets.push({
                label: '10-Year Real Yield',
                data: values,
                borderColor: '#60a5fa',
                backgroundColor: 'rgba(96, 165, 250, 0.1)',
                borderWidth: 2,
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 0,
                order: 1
            });
            
            // Update Y-axis range to include nominal yields if available
            let yMin = Math.min(...values.filter(v => !isNaN(v)));
            let yMax = Math.max(...values.filter(v => !isNaN(v)));
            if (alignedNominalYieldsFiltered) {
                const nominalValues = alignedNominalYieldsFiltered.filter(v => v !== null && !isNaN(v));
                if (nominalValues.length > 0) {
                    yMin = Math.min(yMin, ...nominalValues);
                    yMax = Math.max(yMax, ...nominalValues);
                }
            }
            const yRange = yMax - yMin;
            const yPadding = yRange * 0.05;
            
            // Remove breakeven inflation tooltip handling since we're not showing it
            
            realYieldChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return (value >= 0 ? '+' : '') + value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' },
                            zero: { color: '#9ca3af' }
                        }
                    }
                }
            });
        }
        
        // Process Inflation (CPI & PCE)
        function processInflationCpiPce(cpiOverallData, cpiCoreData, pceOverallData, pceCoreData, 
            cpiShelterData, cpiFoodData, cpiEnergyData, cpiTransportData, 
            cpiMedicalData, cpiEducationData, cpiApparelData, cpiRecreationData, cpiOtherData,
            dallasTrimmedData) {
            
            // Helper function to calculate YoY inflation
            function calculateYoY(data) {
                const yoy = [];
                if (data && data.length > 0) {
                    data.sort((a, b) => new Date(a.date) - new Date(b.date));
                    for (let i = 12; i < data.length; i++) {
                        const current = data[i].value;
                        const previous = data[i - 12].value;
                        if (previous !== 0 && !isNaN(current) && !isNaN(previous)) {
                            const yoyChange = ((current / previous) - 1) * 100;
                            yoy.push({
                                date: data[i].date,
                                value: yoyChange
                            });
                        }
                    }
                }
                return yoy;
            }
            
            // Helper function to calculate MoM inflation (month-over-month, annualized)
            function calculateMoM(data) {
                const mom = [];
                if (data && data.length > 0) {
                    data.sort((a, b) => new Date(a.date) - new Date(b.date));
                    for (let i = 1; i < data.length; i++) {
                        const current = data[i].value;
                        const previous = data[i - 1].value;
                        if (previous !== 0 && !isNaN(current) && !isNaN(previous)) {
                            // Calculate monthly change and annualize it
                            const monthlyChange = ((current / previous) - 1) * 100;
                            const annualizedChange = monthlyChange * 12; // Annualize
                            mom.push({
                                date: data[i].date,
                                value: annualizedChange,
                                monthlyValue: monthlyChange
                            });
                        }
                    }
                }
                return mom;
            }
            
            // Calculate YoY for main series
            const cpiOverallYoY = calculateYoY(cpiOverallData);
            const cpiCoreYoY = calculateYoY(cpiCoreData);
            const pceOverallYoY = calculateYoY(pceOverallData);
            const pceCoreYoY = calculateYoY(pceCoreData);
            
            // Calculate YoY for Dallas Trimmed Mean PCE
            // Note: PCETRIM12M159SFRBDAL is already in YoY format (12-month percent change), so we don't need to calculate it
            // However, if the data format is different, we'll try to calculate it
            let dallasTrimmedYoY = [];
            if (dallasTrimmedData && dallasTrimmedData.length > 0) {
                console.log(`Processing Dallas Trimmed Mean: ${dallasTrimmedData.length} data points`);
                // Check if data is already in YoY format (values are percentages) or if it's an index
                const sampleValue = dallasTrimmedData[dallasTrimmedData.length - 1]?.value;
                console.log(`Dallas Trimmed Mean sample value: ${sampleValue}`);
                // If values are typically between -5 and 10, it's likely already YoY percentage
                // If values are > 100, it's likely an index and needs YoY calculation
                if (sampleValue !== undefined && sampleValue !== null && Math.abs(sampleValue) < 50) {
                    // Already in YoY format - just map the data
                    dallasTrimmedData.forEach(item => {
                        dallasTrimmedYoY.push({
                            date: item.date,
                            value: item.value
                        });
                    });
                    console.log(`Dallas Trimmed Mean: Using data as-is (YoY format), ${dallasTrimmedYoY.length} points`);
                } else {
                    // Need to calculate YoY
                    console.log(`Dallas Trimmed Mean: Calculating YoY from index data`);
                    dallasTrimmedYoY = calculateYoY(dallasTrimmedData);
                    console.log(`Dallas Trimmed Mean: Calculated ${dallasTrimmedYoY.length} YoY points`);
                }
            } else {
                console.warn('Dallas Trimmed Mean data is empty or null');
            }
            
            
            // Calculate MoM for main series
            const cpiOverallMoM = calculateMoM(cpiOverallData);
            const cpiCoreMoM = calculateMoM(cpiCoreData);
            const pceOverallMoM = calculateMoM(pceOverallData);
            const pceCoreMoM = calculateMoM(pceCoreData);
            
            // Calculate MoM for Dallas Trimmed Mean
            // Note: PCETRIM12M159SFRBDAL is already in YoY format (12-month percent change)
            // We can't calculate MoM from YoY data without the underlying index
            // So we'll skip MoM calculation for Dallas Trimmed Mean
            const dallasTrimmedMoM = [];
            
            console.log('Inflation calculation results:', {
                cpiOverall: { yoy: cpiOverallYoY.length, mom: cpiOverallMoM.length, raw: cpiOverallData.length },
                cpiCore: { yoy: cpiCoreYoY.length, mom: cpiCoreMoM.length, raw: cpiCoreData.length },
                pceOverall: { yoy: pceOverallYoY.length, mom: pceOverallMoM.length, raw: pceOverallData.length },
                pceCore: { yoy: pceCoreYoY.length, mom: pceCoreMoM.length, raw: pceCoreData.length },
                dallasTrimmed: { yoy: dallasTrimmedYoY.length, mom: dallasTrimmedMoM.length, raw: (dallasTrimmedData || []).length }
            });
            
            // Debug PCE YoY calculation
            if (pceOverallData.length > 0 && pceOverallYoY.length === 0) {
                console.warn('PCE Overall YoY calculation issue:', {
                    dataPoints: pceOverallData.length,
                    needsAtLeast: 12,
                    firstValue: pceOverallData[0]?.value,
                    lastValue: pceOverallData[pceOverallData.length - 1]?.value,
                    sampleData: pceOverallData.slice(0, 3).map(d => ({ date: d.date, value: d.value }))
                });
            }
            
            if (pceCoreData.length > 0 && pceCoreYoY.length === 0) {
                console.warn('PCE Core YoY calculation issue:', {
                    dataPoints: pceCoreData.length,
                    needsAtLeast: 12,
                    firstValue: pceCoreData[0]?.value,
                    lastValue: pceCoreData[pceCoreData.length - 1]?.value,
                    sampleData: pceCoreData.slice(0, 3).map(d => ({ date: d.date, value: d.value }))
                });
            }
            
            if (pceOverallYoY.length > 0) {
                console.log('PCE Overall YoY sample:', {
                    first: pceOverallYoY[0],
                    last: pceOverallYoY[pceOverallYoY.length - 1]
                });
            }
            
            if (pceCoreYoY.length > 0) {
                console.log('PCE Core YoY sample:', {
                    first: pceCoreYoY[0],
                    last: pceCoreYoY[pceCoreYoY.length - 1]
                });
            }
            
            // Align all dates
            const combinedData = [];
            const dateMap = new Map();
            
            // Add all dates from all series
            [...cpiOverallYoY, ...cpiCoreYoY, ...pceOverallYoY, ...pceCoreYoY, ...dallasTrimmedYoY].forEach(item => {
                if (!dateMap.has(item.date)) {
                    dateMap.set(item.date, {});
                }
            });
            
            // Add values to date map
            cpiOverallYoY.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).cpiOverall = item.value;
                }
            });
            cpiCoreYoY.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).cpiCore = item.value;
                }
            });
            pceOverallYoY.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).pceOverall = item.value;
                }
            });
            pceCoreYoY.forEach(item => {
                if (dateMap.has(item.date)) {
                    dateMap.get(item.date).pceCore = item.value;
                }
            });
            // Add Dallas Trimmed Mean data to dateMap
            // Since it's monthly data, we need to ensure it's added even if the date doesn't exist yet
            let dallasTrimmedAdded = 0;
            dallasTrimmedYoY.forEach(item => {
                if (!dateMap.has(item.date)) {
                    // Create entry if it doesn't exist
                    dateMap.set(item.date, {});
                }
                dateMap.get(item.date).dallasTrimmed = item.value;
                dallasTrimmedAdded++;
            });
            console.log(`Dallas Trimmed Mean: Added ${dallasTrimmedAdded} values to dateMap`);
            
            // Create combined data array
            dateMap.forEach((values, date) => {
                combinedData.push({
                    date: date,
                    cpiOverall: values.cpiOverall,
                    cpiCore: values.cpiCore,
                    pceOverall: values.pceOverall,
                    pceCore: values.pceCore,
                    dallasTrimmed: values.dallasTrimmed,
                });
            });
            
            // If PCE YoY is empty but we have raw PCE data, try to calculate it manually
            if (pceOverallYoY.length === 0 && pceOverallData.length >= 12) {
                console.log('Attempting manual PCE Overall YoY calculation...');
                pceOverallData.sort((a, b) => new Date(a.date) - new Date(b.date));
                const latest = pceOverallData[pceOverallData.length - 1];
                const yearAgo = pceOverallData[pceOverallData.length - 12];
                if (yearAgo && yearAgo.value !== 0 && !isNaN(latest.value) && !isNaN(yearAgo.value)) {
                    const manualYoY = ((latest.value / yearAgo.value) - 1) * 100;
                    pceOverallYoY.push({
                        date: latest.date,
                        value: manualYoY
                    });
                    console.log('Manual PCE Overall YoY calculated:', manualYoY);
                }
            }
            
            if (pceCoreYoY.length === 0 && pceCoreData.length >= 12) {
                console.log('Attempting manual PCE Core YoY calculation...');
                pceCoreData.sort((a, b) => new Date(a.date) - new Date(b.date));
                const latest = pceCoreData[pceCoreData.length - 1];
                const yearAgo = pceCoreData[pceCoreData.length - 12];
                if (yearAgo && yearAgo.value !== 0 && !isNaN(latest.value) && !isNaN(yearAgo.value)) {
                    const manualYoY = ((latest.value / yearAgo.value) - 1) * 100;
                    pceCoreYoY.push({
                        date: latest.date,
                        value: manualYoY
                    });
                    console.log('Manual PCE Core YoY calculated:', manualYoY);
                }
            }
            
            // Re-add PCE YoY data to dateMap if we now have it
            if (pceOverallYoY.length > 0) {
                pceOverallYoY.forEach(item => {
                    if (!dateMap.has(item.date)) {
                        dateMap.set(item.date, {});
                    }
                    if (dateMap.has(item.date)) {
                        dateMap.get(item.date).pceOverall = item.value;
                    }
                });
            }
            
            if (pceCoreYoY.length > 0) {
                pceCoreYoY.forEach(item => {
                    if (!dateMap.has(item.date)) {
                        dateMap.set(item.date, {});
                    }
                    if (dateMap.has(item.date)) {
                        dateMap.get(item.date).pceCore = item.value;
                    }
                });
            }
            
            // Recreate combined data array with updated PCE data
            const updatedCombinedData = [];
            dateMap.forEach((values, date) => {
                updatedCombinedData.push({
                    date: date,
                    cpiOverall: values.cpiOverall,
                    cpiCore: values.cpiCore,
                    pceOverall: values.pceOverall,
                    pceCore: values.pceCore,
                    dallasTrimmed: values.dallasTrimmed,
                });
            });
            
            if (updatedCombinedData.length === 0) {
                console.warn('No combined inflation data available after processing');
                // Set placeholders if we have raw data but no YoY data
                if (pceOverallData.length > 0 || pceCoreData.length > 0) {
                    document.getElementById('pceOverall').textContent = 'Insufficient data';
                    document.getElementById('pceCore').textContent = 'Insufficient data';
                }
                return;
            }
            
            // Use updated combined data
            combinedData.length = 0;
            combinedData.push(...updatedCombinedData);
            
            combinedData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Store full data for zoom
            inflationCpiPceFullData = combinedData;
            
            // Filter to last 10 years
            const tenYearsAgo = new Date();
            tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
            const filteredData = combinedData.filter(d => new Date(d.date) >= tenYearsAgo);
            
            // Apply 24-month zoom if active
            let chartData = filteredData.length > 0 ? filteredData : combinedData;
            if (inflationCpiPceZoom24) {
                chartData = filterTo24Months(chartData);
            }
            
            const latest = chartData[chartData.length - 1];
            
            // Verify PCE calculations - log raw data and calculated YoY for debugging
            if (pceOverallData.length > 0 && pceCoreData.length > 0) {
                pceOverallData.sort((a, b) => new Date(a.date) - new Date(b.date));
                pceCoreData.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                const latestPceOverallRaw = pceOverallData[pceOverallData.length - 1];
                const latestPceCoreRaw = pceCoreData[pceCoreData.length - 1];
                
                if (pceOverallData.length >= 12) {
                    const yearAgoPceOverall = pceOverallData[pceOverallData.length - 12];
                    const calculatedYoYOverall = ((latestPceOverallRaw.value / yearAgoPceOverall.value) - 1) * 100;
                    console.log('PCE Overall Verification:', {
                        latestDate: latestPceOverallRaw.date,
                        latestIndex: latestPceOverallRaw.value,
                        yearAgoDate: yearAgoPceOverall.date,
                        yearAgoIndex: yearAgoPceOverall.value,
                        calculatedYoY: calculatedYoYOverall.toFixed(2) + '%',
                        displayedYoY: latest.pceOverall !== undefined && latest.pceOverall !== null ? latest.pceOverall.toFixed(2) + '%' : 'N/A'
                    });
                }
                
                if (pceCoreData.length >= 12) {
                    const yearAgoPceCore = pceCoreData[pceCoreData.length - 12];
                    const calculatedYoYCore = ((latestPceCoreRaw.value / yearAgoPceCore.value) - 1) * 100;
                    console.log('PCE Core Verification:', {
                        latestDate: latestPceCoreRaw.date,
                        latestIndex: latestPceCoreRaw.value,
                        yearAgoDate: yearAgoPceCore.date,
                        yearAgoIndex: yearAgoPceCore.value,
                        calculatedYoY: calculatedYoYCore.toFixed(2) + '%',
                        displayedYoY: latest.pceCore !== undefined && latest.pceCore !== null ? latest.pceCore.toFixed(2) + '%' : 'N/A'
                    });
                }
            }
            
            // Get latest MoM values
            const latestCpiOverallMoM = cpiOverallMoM.length > 0 ? cpiOverallMoM[cpiOverallMoM.length - 1] : null;
            const latestCpiCoreMoM = cpiCoreMoM.length > 0 ? cpiCoreMoM[cpiCoreMoM.length - 1] : null;
            const latestPceOverallMoM = pceOverallMoM.length > 0 ? pceOverallMoM[pceOverallMoM.length - 1] : null;
            const latestPceCoreMoM = pceCoreMoM.length > 0 ? pceCoreMoM[pceCoreMoM.length - 1] : null;
            const latestDallasTrimmedMoM = dallasTrimmedMoM.length > 0 ? dallasTrimmedMoM[dallasTrimmedMoM.length - 1] : null;
            
            // Get latest dates
            const latestCpiDate = cpiOverallData.length > 0 ? cpiOverallData[cpiOverallData.length - 1].date : null;
            const latestPceDate = pceOverallData.length > 0 ? pceOverallData[pceOverallData.length - 1].date : null;
            
            // Format dates
            const formatDate = (dateStr) => {
                if (!dateStr) return 'N/A';
                const date = new Date(dateStr);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            };
            
            // Update YoY display
            if (latest.cpiOverall !== undefined && latest.cpiOverall !== null) {
                document.getElementById('cpiOverall').textContent = latest.cpiOverall.toFixed(2) + '%';
            } else {
                document.getElementById('cpiOverall').textContent = 'N/A';
            }
            if (latest.cpiCore !== undefined && latest.cpiCore !== null) {
                document.getElementById('cpiCore').textContent = latest.cpiCore.toFixed(2) + '%';
            } else {
                document.getElementById('cpiCore').textContent = 'N/A';
            }
            // For PCE, find the latest value from the full combinedData, not just chartData
            // This ensures we show the most recent value even if it's not in the filtered chartData
            let latestPceOverallValue = null;
            let latestPceCoreValue = null;
            if (combinedData.length > 0) {
                // Find the most recent entry with PCE Overall data
                for (let i = combinedData.length - 1; i >= 0; i--) {
                    if (combinedData[i].pceOverall !== undefined && combinedData[i].pceOverall !== null) {
                        latestPceOverallValue = combinedData[i].pceOverall;
                        break;
                    }
                }
                // Find the most recent entry with PCE Core data
                for (let i = combinedData.length - 1; i >= 0; i--) {
                    if (combinedData[i].pceCore !== undefined && combinedData[i].pceCore !== null) {
                        latestPceCoreValue = combinedData[i].pceCore;
                        break;
                    }
                }
            }
            
            if (latestPceOverallValue !== null) {
                document.getElementById('pceOverall').textContent = latestPceOverallValue.toFixed(2) + '%';
            } else if (latest.pceOverall !== undefined && latest.pceOverall !== null) {
                document.getElementById('pceOverall').textContent = latest.pceOverall.toFixed(2) + '%';
            } else {
                document.getElementById('pceOverall').textContent = 'N/A';
            }
            
            if (latestPceCoreValue !== null) {
                document.getElementById('pceCore').textContent = latestPceCoreValue.toFixed(2) + '%';
            } else if (latest.pceCore !== undefined && latest.pceCore !== null) {
                document.getElementById('pceCore').textContent = latest.pceCore.toFixed(2) + '%';
            } else {
                document.getElementById('pceCore').textContent = 'N/A';
            }
            // For Dallas Trimmed Mean, find the latest value from the full combinedData, not just chartData
            // This ensures we show the most recent value even if it's not in the filtered chartData
            let latestDallasTrimmed = null;
            if (combinedData.length > 0) {
                // Find the most recent entry with Dallas Trimmed Mean data
                for (let i = combinedData.length - 1; i >= 0; i--) {
                    if (combinedData[i].dallasTrimmed !== undefined && combinedData[i].dallasTrimmed !== null) {
                        latestDallasTrimmed = combinedData[i].dallasTrimmed;
                        break;
                    }
                }
            }
            if (latestDallasTrimmed !== null) {
                document.getElementById('dallasTrimmed').textContent = latestDallasTrimmed.toFixed(2) + '%';
            } else {
                document.getElementById('dallasTrimmed').textContent = 'N/A';
                console.warn('Dallas Trimmed Mean: No value found in combinedData');
            }
            
            // Update MoM display
            if (latestCpiOverallMoM && latestCpiOverallMoM.value !== undefined && latestCpiOverallMoM.value !== null) {
                const color = latestCpiOverallMoM.value > 0 ? 'text-red-400' : 'text-green-400';
                document.getElementById('cpiOverallMoM').innerHTML = `<span class="${color}">${latestCpiOverallMoM.value >= 0 ? '+' : ''}${latestCpiOverallMoM.value.toFixed(2)}%</span>`;
            } else {
                document.getElementById('cpiOverallMoM').textContent = 'N/A';
            }
            if (latestCpiCoreMoM && latestCpiCoreMoM.value !== undefined && latestCpiCoreMoM.value !== null) {
                const color = latestCpiCoreMoM.value > 0 ? 'text-red-400' : 'text-green-400';
                document.getElementById('cpiCoreMoM').innerHTML = `<span class="${color}">${latestCpiCoreMoM.value >= 0 ? '+' : ''}${latestCpiCoreMoM.value.toFixed(2)}%</span>`;
            } else {
                document.getElementById('cpiCoreMoM').textContent = 'N/A';
            }
            if (latestPceOverallMoM && latestPceOverallMoM.value !== undefined && latestPceOverallMoM.value !== null) {
                const color = latestPceOverallMoM.value > 0 ? 'text-red-400' : 'text-green-400';
                document.getElementById('pceOverallMoM').innerHTML = `<span class="${color}">${latestPceOverallMoM.value >= 0 ? '+' : ''}${latestPceOverallMoM.value.toFixed(2)}%</span>`;
            } else {
                document.getElementById('pceOverallMoM').textContent = 'N/A';
            }
            if (latestPceCoreMoM && latestPceCoreMoM.value !== undefined && latestPceCoreMoM.value !== null) {
                const color = latestPceCoreMoM.value > 0 ? 'text-red-400' : 'text-green-400';
                document.getElementById('pceCoreMoM').innerHTML = `<span class="${color}">${latestPceCoreMoM.value >= 0 ? '+' : ''}${latestPceCoreMoM.value.toFixed(2)}%</span>`;
            } else {
                document.getElementById('pceCoreMoM').textContent = 'N/A';
            }
            if (latestDallasTrimmedMoM && latestDallasTrimmedMoM.value !== undefined && latestDallasTrimmedMoM.value !== null) {
                const color = latestDallasTrimmedMoM.value > 0 ? 'text-red-400' : 'text-green-400';
                document.getElementById('dallasTrimmedMoM').innerHTML = `<span class="${color}">${latestDallasTrimmedMoM.value >= 0 ? '+' : ''}${latestDallasTrimmedMoM.value.toFixed(2)}%</span>`;
            } else {
                document.getElementById('dallasTrimmedMoM').textContent = 'N/A';
            }
            
            // Update latest dates
            document.getElementById('cpiLatestDate').textContent = formatDate(latestCpiDate);
            document.getElementById('pceLatestDate').textContent = formatDate(latestPceDate);
            
            const inflationCpiPceLatest = [latestCpiDate, latestPceDate].filter(d => d).reduce((a, b) => a > b ? a : b, null);
            const inflationCpiPceDateEl = document.getElementById('inflationCpiPceLatestDate');
            if (inflationCpiPceDateEl) inflationCpiPceDateEl.textContent = formatLatestDate(inflationCpiPceLatest);
            
            // Analysis
            const analysisEl = document.getElementById('inflationCpiPceAnalysis');
            let analysisText = '';
            const avgCpi = latest.cpiOverall !== undefined && latest.cpiOverall !== null ? latest.cpiOverall : null;
            const avgPce = latest.pceOverall !== undefined && latest.pceOverall !== null ? latest.pceOverall : null;
            const avgDallasTrimmed = latest.dallasTrimmed !== undefined && latest.dallasTrimmed !== null ? latest.dallasTrimmed : null;
            const cpiMoM = latestCpiOverallMoM ? latestCpiOverallMoM.value : null;
            const pceMoM = latestPceOverallMoM ? latestPceOverallMoM.value : null;
            const dallasTrimmedMoMValue = latestDallasTrimmedMoM ? latestDallasTrimmedMoM.value : null;
            const latestPceCoreForChart = latestPceCoreValue !== null ? latestPceCoreValue : (latest.pceCore !== undefined && latest.pceCore !== null ? latest.pceCore : null);
            
            // Build comprehensive analysis
            const parts = [];
            
            // Primary measures (CPI & PCE)
            if (avgCpi !== null && avgPce !== null) {
                const cpiStatus = avgCpi > 3 ? 'elevated' : avgCpi < 1 ? 'low' : 'moderate';
                const pceStatus = avgPce > 3 ? 'elevated' : avgPce < 1 ? 'low' : 'moderate';
                parts.push(`YoY: CPI ${avgCpi.toFixed(2)}% (${cpiStatus}), PCE ${avgPce.toFixed(2)}% (${pceStatus}).`);
                
                if (cpiMoM !== null || pceMoM !== null) {
                    const momParts = [];
                    if (cpiMoM !== null) {
                        const momTrend = cpiMoM > 2 ? 'accelerating' : cpiMoM < -1 ? 'decelerating' : 'stable';
                        momParts.push(`CPI MoM: ${cpiMoM >= 0 ? '+' : ''}${cpiMoM.toFixed(2)}% (${momTrend})`);
                    }
                    if (pceMoM !== null) {
                        const momTrend = pceMoM > 2 ? 'accelerating' : pceMoM < -1 ? 'decelerating' : 'stable';
                        momParts.push(`PCE MoM: ${pceMoM >= 0 ? '+' : ''}${pceMoM.toFixed(2)}% (${momTrend})`);
                    }
                    if (momParts.length > 0) {
                        parts.push(momParts.join(', ') + '.');
                    }
                }
            }
            
            // Dallas Trimmed Mean (removes extreme components, better signal-to-noise)
            if (avgDallasTrimmed !== null) {
                const dallasStatus = avgDallasTrimmed > 2.5 ? 'above target' : avgDallasTrimmed < 1.5 ? 'below target' : 'near target';
                parts.push(`Dallas Trimmed Mean: ${avgDallasTrimmed.toFixed(2)}% (${dallasStatus}) - removes extreme price movements for clearer trend.`);
                if (dallasTrimmedMoMValue !== null) {
                    const momTrend = dallasTrimmedMoMValue > 2 ? 'accelerating' : dallasTrimmedMoMValue < -1 ? 'decelerating' : 'stable';
                    parts.push(`Dallas MoM: ${dallasTrimmedMoMValue >= 0 ? '+' : ''}${dallasTrimmedMoMValue.toFixed(2)}% (${momTrend}).`);
                }
            }
            
            // Overall assessment
            if (avgCpi !== null && avgPce !== null) {
                if (avgCpi > 3 || avgPce > 3) {
                    parts.push("Both CPI and PCE are above the Fed's 2% target, indicating persistent price pressures.");
                } else if (avgCpi < 1 || avgPce < 1) {
                    parts.push("Both CPI and PCE are below the Fed's 2% target, indicating subdued price pressures.");
                } else {
                    parts.push("Both CPI and PCE are near the Fed's 2% target.");
                }
            } else if (avgCpi !== null) {
                const status = avgCpi > 2.5 ? 'Elevated' : avgCpi < 1.5 ? 'Low' : 'Moderate';
                parts.push(`CPI inflation: ${avgCpi.toFixed(2)}% (${status.toLowerCase()}) relative to Fed's 2% target.`);
                if (cpiMoM !== null) {
                    const momTrend = cpiMoM > 2 ? 'accelerating' : cpiMoM < -1 ? 'decelerating' : 'stable';
                    parts.push(`MoM: ${cpiMoM >= 0 ? '+' : ''}${cpiMoM.toFixed(2)}% (${momTrend}).`);
                }
            } else if (avgPce !== null) {
                const status = avgPce > 2.5 ? 'Elevated' : avgPce < 1.5 ? 'Low' : 'Moderate';
                parts.push(`PCE inflation: ${avgPce.toFixed(2)}% (${status.toLowerCase()}) relative to Fed's 2% target.`);
                if (pceMoM !== null) {
                    const momTrend = pceMoM > 2 ? 'accelerating' : pceMoM < -1 ? 'decelerating' : 'stable';
                    parts.push(`MoM: ${pceMoM >= 0 ? '+' : ''}${pceMoM.toFixed(2)}% (${momTrend}).`);
                }
            } else {
                parts.push('Inflation data not available.');
            }
            
            analysisText = parts.join(' ');
            analysisEl.textContent = analysisText;
            
            // Create chart with clickable legend
            const ctx = document.getElementById('inflationCpiPceChart');
            if (inflationCpiPceChartInstance) {
                inflationCpiPceChartInstance.destroy();
            }
            
            const labels = chartData.map(d => d.date);
            // Show: CPI Overall, CPI Core, PCE Overall, PCE Core, Dallas Trimmed Mean
            const cpiOverallValues = chartData.map(d => d.cpiOverall !== undefined && d.cpiOverall !== null ? d.cpiOverall : null);
            const cpiCoreValues = chartData.map(d => d.cpiCore !== undefined && d.cpiCore !== null ? d.cpiCore : null);
            const pceOverallValues = chartData.map(d => d.pceOverall !== undefined && d.pceOverall !== null ? d.pceOverall : null);
            const pceCoreValues = chartData.map(d => d.pceCore !== undefined && d.pceCore !== null ? d.pceCore : null);
            const dallasTrimmedValues = chartData.map(d => d.dallasTrimmed !== undefined && d.dallasTrimmed !== null ? d.dallasTrimmed : null);
            
            // Calculate Y-axis range (exclude Cleveland Nowcast to avoid scale issues)
            const allValuesForRange = [...cpiOverallValues, ...cpiCoreValues, ...pceOverallValues, ...pceCoreValues, ...dallasTrimmedValues];
            const filteredValues = allValuesForRange.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (filteredValues.length === 0) return;
            
            const yMin = Math.min(...filteredValues);
            const yMax = Math.max(...filteredValues);
            const yRange = yMax - yMin;
            const yPadding = yRange * 0.05;
            
            inflationCpiPceChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'PCE Overall',
                        data: pceOverallValues,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'PCE Core',
                        data: pceCoreValues,
                        borderColor: '#dc2626',
                        backgroundColor: 'rgba(220, 38, 38, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'CPI Overall',
                        data: cpiOverallValues,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'CPI Core',
                        data: cpiCoreValues,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }, {
                        label: 'Dallas Trimmed Mean',
                        data: dallasTrimmedValues,
                        borderColor: '#a78bfa',
                        backgroundColor: 'rgba(167, 139, 250, 0.1)',
                        borderWidth: 2,
                        borderDash: [3, 3],
                        fill: false,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#9ca3af',
                                font: { size: 10 },
                                boxWidth: 12,
                                padding: 8
                            },
                            onClick: function(e, legendItem) {
                                const index = legendItem.datasetIndex;
                                const chart = this.chart;
                                const meta = chart.getDatasetMeta(index);
                                
                                // Toggle visibility
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                                chart.update();
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += (context.parsed.y >= 0 ? '+' : '') + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            min: yMin - yPadding,
                            max: yMax + yPadding,
                            ticks: { 
                                color: '#9ca3af',
                                font: { size: 9 },
                                callback: function(value) { return value.toFixed(2) + '%'; }
                            },
                            grid: { color: 'rgba(156, 163, 175, 0.1)' }
                        }
                    }
                }
            });
            
            // Process CPI Components
            // Weights adjusted to sum to 100% (based on approximate BLS weights, with remainder allocated to "Other")
            const components = [
                { name: 'Shelter (Housing)', data: cpiShelterData, weight: 0.36, seriesId: 'CPIHOSNS' },
                { name: 'Food', data: cpiFoodData, weight: 0.13, seriesId: 'CPIUFNS' },
                { name: 'Energy', data: cpiEnergyData, weight: 0.07, seriesId: 'CPIENGSL' },
                { name: 'Transportation', data: cpiTransportData, weight: 0.13, seriesId: 'CPITRNSL' },
                { name: 'Medical Care', data: cpiMedicalData, weight: 0.08, seriesId: 'CPIMEDSL' },
                { name: 'Education & Comm.', data: cpiEducationData, weight: 0.05, seriesId: 'CPIEDUSL' },
                { name: 'Apparel (Clothing)', data: cpiApparelData, weight: 0.025, seriesId: 'CPIAPPSL' },
                { name: 'Recreation', data: cpiRecreationData, weight: 0.05, seriesId: 'CPIRECSL' },
                { name: 'Other Goods & Services', data: cpiOtherData, weight: 0.105, seriesId: 'CPIOGSL' } // Remaining weight to sum to 100%
            ];
            
            const componentsAnalysis = [];
            
            components.forEach(component => {
                if (component.data && component.data.length > 0) {
                    component.data.sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    // Calculate current YoY
                    if (component.data.length > 12) {
                        const latest = component.data[component.data.length - 1];
                        const yearAgo = component.data[component.data.length - 13];
                        if (yearAgo.value !== 0 && !isNaN(latest.value) && !isNaN(yearAgo.value)) {
                            const currentYoY = ((latest.value / yearAgo.value) - 1) * 100;
                            
                            // Calculate MoM (month-over-month, annualized)
                            let currentMoM = null;
                            if (component.data.length > 1) {
                                const prevMonth = component.data[component.data.length - 2];
                                if (prevMonth.value !== 0 && !isNaN(latest.value) && !isNaN(prevMonth.value)) {
                                    const monthlyChange = ((latest.value / prevMonth.value) - 1) * 100;
                                    currentMoM = monthlyChange * 12; // Annualize
                                }
                            }
                            
                            // Calculate 3-month average YoY
                            let avg3MonthYoY = null;
                            if (component.data.length > 15) {
                                const month3 = component.data[component.data.length - 4];
                                const month3YearAgo = component.data[component.data.length - 16];
                                if (month3YearAgo.value !== 0 && !isNaN(month3.value) && !isNaN(month3YearAgo.value)) {
                                    avg3MonthYoY = ((month3.value / month3YearAgo.value) - 1) * 100;
                                }
                            }
                            
                            // Calculate 6-month average YoY
                            let avg6MonthYoY = null;
                            if (component.data.length > 18) {
                                const month6 = component.data[component.data.length - 7];
                                const month6YearAgo = component.data[component.data.length - 19];
                                if (month6YearAgo.value !== 0 && !isNaN(month6.value) && !isNaN(month6YearAgo.value)) {
                                    avg6MonthYoY = ((month6.value / month6YearAgo.value) - 1) * 100;
                                }
                            }
                            
                            // Calculate previous YoY (12 months before current)
                            let previousYoY = null;
                            if (component.data.length > 24) {
                                const prevLatest = component.data[component.data.length - 13];
                                const prevYearAgo = component.data[component.data.length - 25];
                                if (prevYearAgo.value !== 0 && !isNaN(prevLatest.value) && !isNaN(prevYearAgo.value)) {
                                    previousYoY = ((prevLatest.value / prevYearAgo.value) - 1) * 100;
                                }
                            }
                            
                            // Calculate trend direction
                            let trend = 'stable';
                            let trendIcon = '➡️';
                            if (avg3MonthYoY !== null && avg6MonthYoY !== null) {
                                if (currentYoY > avg3MonthYoY && avg3MonthYoY > avg6MonthYoY) {
                                    trend = 'accelerating';
                                    trendIcon = '📈';
                                } else if (currentYoY < avg3MonthYoY && avg3MonthYoY < avg6MonthYoY) {
                                    trend = 'decelerating';
                                    trendIcon = '📉';
                                }
                            } else if (previousYoY !== null) {
                                const change = currentYoY - previousYoY;
                                if (change > 0.5) {
                                    trend = 'accelerating';
                                    trendIcon = '📈';
                                } else if (change < -0.5) {
                                    trend = 'decelerating';
                                    trendIcon = '📉';
                                }
                            }
                            
                            // Calculate contributions to overall CPI
                            const currentContribution = component.weight * currentYoY;
                            const previousContribution = previousYoY !== null ? component.weight * previousYoY : null;
                            const calendarEffectContribution = previousContribution !== null ? currentContribution - previousContribution : null;
                            
                            // Calendar effect analysis: if strong data is rolling out, it pressures the component lower
                            let calendarEffect = '';
                            if (previousYoY !== null) {
                                const change = currentYoY - previousYoY;
                                if (change < -0.5) {
                                    calendarEffect = '📉 Calendar effect: Strong data rolling out is pressuring this component lower.';
                                } else if (change > 0.5) {
                                    calendarEffect = '📈 Calendar effect: Weak data rolling out is allowing this component to rise.';
                                } else {
                                    calendarEffect = '➡️ Calendar effect: Neutral - no significant base effect pressure.';
                                }
                            }
                            
                            componentsAnalysis.push({
                                name: component.name,
                                weight: component.weight,
                                currentYoY: currentYoY,
                                currentMoM: currentMoM,
                                avg3MonthYoY: avg3MonthYoY,
                                avg6MonthYoY: avg6MonthYoY,
                                previousYoY: previousYoY,
                                currentContribution: currentContribution,
                                previousContribution: previousContribution,
                                calendarEffectContribution: calendarEffectContribution,
                                calendarEffect: calendarEffect,
                                trend: trend,
                                trendIcon: trendIcon
                            });
                        }
                    }
                }
            });
            
            // Sort by absolute contribution (largest to smallest)
            componentsAnalysis.sort((a, b) => Math.abs(b.currentContribution) - Math.abs(a.currentContribution));
            
            // Calculate totals (should equal overall CPI YoY)
            const totalCurrentContribution = componentsAnalysis.reduce((sum, comp) => sum + comp.currentContribution, 0);
            const totalPreviousContribution = componentsAnalysis.reduce((sum, comp) => 
                sum + (comp.previousContribution !== null ? comp.previousContribution : 0), 0);
            const totalCalendarEffect = totalCurrentContribution - totalPreviousContribution;
            
            // Find key insights
            const topContributors = componentsAnalysis.slice(0, 3).map(c => c.name);
            const acceleratingComponents = componentsAnalysis.filter(c => c.trend === 'accelerating').map(c => c.name);
            const deceleratingComponents = componentsAnalysis.filter(c => c.trend === 'decelerating').map(c => c.name);
            const largestPositive = componentsAnalysis.find(c => c.currentContribution > 0);
            const largestNegative = componentsAnalysis.find(c => c.currentContribution < 0);
            
            // Display components in an enhanced table
            const componentsEl = document.getElementById('cpiComponentsAnalysis');
            if (componentsAnalysis.length > 0) {
                // Find max contribution for visual bar scaling
                const maxAbsContribution = Math.max(...componentsAnalysis.map(c => Math.abs(c.currentContribution)));
                
                let tableHTML = `
                    <div class="bg-gray-900/30 rounded-lg p-4 mb-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-3">
                            <div>
                                <div class="text-gray-400 text-xs mb-2 font-semibold uppercase">Key Insights</div>
                                <div class="text-gray-300 text-xs space-y-1">
                                    <div>📊 <strong>Top 3 Contributors:</strong> ${topContributors.join(', ')}</div>
                                    ${acceleratingComponents.length > 0 ? `<div>📈 <strong>Accelerating:</strong> ${acceleratingComponents.join(', ')}</div>` : ''}
                                    ${deceleratingComponents.length > 0 ? `<div>📉 <strong>Decelerating:</strong> ${deceleratingComponents.join(', ')}</div>` : ''}
                                    ${largestPositive ? `<div>⬆️ <strong>Largest Positive:</strong> ${largestPositive.name} (+${largestPositive.currentContribution.toFixed(3)}pp)</div>` : ''}
                                    ${largestNegative ? `<div>⬇️ <strong>Largest Negative:</strong> ${largestNegative.name} (${largestNegative.currentContribution.toFixed(3)}pp)</div>` : ''}
                                </div>
                            </div>
                            <div>
                                <div class="text-gray-400 text-xs mb-2 font-semibold uppercase">Summary</div>
                                <div class="text-gray-300 text-xs space-y-1">
                                    <div><strong>Total Contribution:</strong> <span class="${totalCurrentContribution >= 0 ? 'text-red-400' : 'text-green-400'} font-semibold">${(totalCurrentContribution >= 0 ? '+' : '') + totalCurrentContribution.toFixed(3)}pp</span></div>
                                    ${totalPreviousContribution !== null ? `<div><strong>Previous Period:</strong> ${(totalPreviousContribution >= 0 ? '+' : '') + totalPreviousContribution.toFixed(3)}pp</div>` : ''}
                                    ${totalCalendarEffect !== null ? `<div><strong>Calendar Effect:</strong> <span class="${totalCalendarEffect >= 0 ? 'text-red-400' : 'text-green-400'}">${(totalCalendarEffect >= 0 ? '+' : '') + totalCalendarEffect.toFixed(3)}pp</span></div>` : ''}
                                    <div class="text-gray-500 text-xs mt-2">Click any row to see detailed metrics</div>
                                </div>
                            </div>
                        </div>
                        <div class="text-gray-500 text-xs pt-3 border-t border-gray-700">
                            <strong>Note:</strong> Contribution = Weight × YoY Change. The sum of contributions equals overall CPI YoY. 
                            Components are sorted by absolute contribution (largest impact first). Click any row to expand detailed metrics including 3-month and 6-month averages, previous period comparisons, and calendar effects.
                        </div>
                    </div>
                    <table class="w-full text-xs border-collapse">
                        <thead>
                            <tr class="border-b-2 border-gray-700 bg-gray-900/50">
                                <th class="text-left py-2 px-2 text-gray-300 font-semibold">Component</th>
                                <th class="text-right py-2 px-2 text-gray-300 font-semibold">Weight</th>
                                <th class="text-right py-2 px-2 text-gray-300 font-semibold">YoY</th>
                                <th class="text-right py-2 px-2 text-gray-300 font-semibold">MoM</th>
                                <th class="text-right py-2 px-2 text-gray-300 font-semibold">Trend</th>
                                <th class="text-right py-2 px-2 text-gray-300 font-semibold">Contribution</th>
                                <th class="text-center py-2 px-2 text-gray-300 font-semibold">Impact</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                componentsAnalysis.forEach((comp, index) => {
                    const weightPercent = (comp.weight * 100).toFixed(1);
                    const currentYoYStr = comp.currentYoY.toFixed(2);
                    const currentMoMStr = comp.currentMoM !== null ? (comp.currentMoM >= 0 ? '+' : '') + comp.currentMoM.toFixed(2) : 'N/A';
                    const currentContributionStr = (comp.currentContribution >= 0 ? '+' : '') + comp.currentContribution.toFixed(3);
                    
                    // Color coding
                    const contributionColor = comp.currentContribution >= 0 ? 'text-red-400' : 'text-green-400';
                    const yoyColor = comp.currentYoY >= 3 ? 'text-red-400' : comp.currentYoY <= 0 ? 'text-green-400' : 'text-yellow-400';
                    const momColor = comp.currentMoM !== null ? (comp.currentMoM >= 0 ? 'text-red-400' : 'text-green-400') : 'text-gray-500';
                    
                    // Visual bar for contribution (scaled to max)
                    const barWidth = maxAbsContribution > 0 ? Math.abs(comp.currentContribution) / maxAbsContribution * 100 : 0;
                    const barColor = comp.currentContribution >= 0 ? 'bg-red-500/30' : 'bg-green-500/30';
                    const barBorderColor = comp.currentContribution >= 0 ? 'border-red-500' : 'border-green-500';
                    
                    // Details row (hidden by default, shown when checkbox is checked)
                    const detailsHTML = `
                        <tr class="component-details hidden border-b border-gray-800 bg-gray-900/30">
                            <td colspan="7" class="py-3 px-4">
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-xs">
                                    <div>
                                        <div class="text-gray-500 mb-1">3-Month Avg YoY</div>
                                        <div class="text-gray-300 font-semibold">${comp.avg3MonthYoY !== null ? comp.avg3MonthYoY.toFixed(2) + '%' : 'N/A'}</div>
                                    </div>
                                    <div>
                                        <div class="text-gray-500 mb-1">6-Month Avg YoY</div>
                                        <div class="text-gray-300 font-semibold">${comp.avg6MonthYoY !== null ? comp.avg6MonthYoY.toFixed(2) + '%' : 'N/A'}</div>
                                    </div>
                                    <div>
                                        <div class="text-gray-500 mb-1">Previous YoY</div>
                                        <div class="text-gray-300 font-semibold">${comp.previousYoY !== null ? comp.previousYoY.toFixed(2) + '%' : 'N/A'}</div>
                                    </div>
                                    <div>
                                        <div class="text-gray-500 mb-1">Change vs Prior</div>
                                        <div class="text-gray-300 font-semibold">${comp.previousYoY !== null ? (comp.currentYoY - comp.previousYoY >= 0 ? '+' : '') + (comp.currentYoY - comp.previousYoY).toFixed(2) + '%' : 'N/A'}</div>
                                    </div>
                                </div>
                                ${comp.calendarEffect ? `<div class="mt-3 pt-3 border-t border-gray-700 text-gray-400">${comp.calendarEffect}</div>` : ''}
                            </td>
                        </tr>
                    `;
                    
                    tableHTML += `
                        <tr class="component-row border-b border-gray-800 hover:bg-gray-800/50 cursor-pointer" data-index="${index}">
                            <td class="py-2 px-2 text-gray-300 font-medium">${comp.name}</td>
                            <td class="py-2 px-2 text-right text-gray-400">${weightPercent}%</td>
                            <td class="py-2 px-2 text-right ${yoyColor} font-semibold">${currentYoYStr}%</td>
                            <td class="py-2 px-2 text-right ${momColor}">${currentMoMStr}%</td>
                            <td class="py-2 px-2 text-right text-gray-400">${comp.trendIcon}</td>
                            <td class="py-2 px-2 text-right ${contributionColor} font-semibold">${currentContributionStr}pp</td>
                            <td class="py-2 px-2">
                                <div class="flex items-center justify-end">
                                    <div class="w-20 h-2 bg-gray-800 rounded-full overflow-hidden">
                                        <div class="h-full ${barColor} border ${barBorderColor}" style="width: ${barWidth}%"></div>
                                    </div>
                                </div>
                            </td>
                        </tr>
                        ${detailsHTML}
                    `;
                });
                
                // Add total row
                const overallCpiYoY = latest.cpiOverall !== undefined && latest.cpiOverall !== null ? latest.cpiOverall.toFixed(2) : 'N/A';
                tableHTML += `
                        </tbody>
                        <tfoot>
                            <tr class="border-t-2 border-gray-600 bg-gray-900/70">
                                <td class="py-2.5 px-2 text-gray-100 font-bold">TOTAL</td>
                                <td class="py-2.5 px-2 text-right text-gray-400 font-semibold">100.0%</td>
                                <td class="py-2.5 px-2 text-right text-gray-200 font-bold">${overallCpiYoY}%</td>
                                <td class="py-2.5 px-2 text-right text-gray-400">--</td>
                                <td class="py-2.5 px-2 text-right text-gray-400">--</td>
                                <td class="py-2.5 px-2 text-right text-gray-400">--</td>
                                <td class="py-2.5 px-2"></td>
                            </tr>
                        </tfoot>
                    </table>
                `;
                
                componentsEl.innerHTML = tableHTML;
                
                // Add click handler for expandable rows
                const componentRows = componentsEl.querySelectorAll('.component-row');
                componentRows.forEach(row => {
                    row.addEventListener('click', function() {
                        const index = this.getAttribute('data-index');
                        const detailsRow = this.nextElementSibling;
                        if (detailsRow && detailsRow.classList.contains('component-details')) {
                            detailsRow.classList.toggle('hidden');
                        }
                    });
                });
                
                // Add checkbox handler for showing all details
                const detailsCheckbox = document.getElementById('showComponentDetails');
                if (detailsCheckbox) {
                    detailsCheckbox.addEventListener('change', function() {
                        const detailsRows = componentsEl.querySelectorAll('.component-details');
                        if (this.checked) {
                            detailsRows.forEach(row => row.classList.remove('hidden'));
                        } else {
                            detailsRows.forEach(row => row.classList.add('hidden'));
                        }
                    });
                }
            } else {
                componentsEl.innerHTML = '<div class="text-gray-400 text-sm">Component data not available.</div>';
            }
        }
        
        // Calculate Composite Macro Score using advanced normalization and weighting
        function calculateCompositeMacroScore() {
            // Normalize each indicator to -1 to +1 scale (where +1 is most bullish, -1 is most bearish)
            // Using EXACT thresholds from indicator card logic
            const indicators = {};
            
            // 1. Sahm Rule: Change from 12-month low
            // >= 0.50 = RECESSION WARNING (red), >= 0.30 = WATCH (yellow), else = NORMAL (green)
            const sahmChange = parseFloat(document.getElementById('sahmChange')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            let sahmNormalized;
            if (sahmChange >= 0.50) {
                sahmNormalized = -1.0; // RECESSION WARNING = most bearish
            } else if (sahmChange >= 0.30) {
                sahmNormalized = -0.5; // WATCH = moderately bearish
            } else {
                sahmNormalized = 0.5; // NORMAL = moderately bullish
            }
            indicators.sahm = {
                raw: sahmChange,
                normalized: sahmNormalized,
                weight: 0.15,
                name: 'Sahm Rule',
                description: sahmChange >= 0.5 ? 'Recession Warning' : sahmChange >= 0.3 ? 'Watch' : 'Normal'
            };
            
            // 2. Yield Curve Spread (10Y-2Y)
            // < 0 = INVERTED (red), < 0.5 = FLATTENING (yellow), else = NORMAL (green)
            const yieldSpread = parseFloat(document.getElementById('yieldSpread')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            let yieldNormalized;
            if (yieldSpread < 0) {
                yieldNormalized = -1.0; // INVERTED = most bearish
            } else if (yieldSpread < 0.5) {
                yieldNormalized = -0.5; // FLATTENING = moderately bearish
            } else {
                yieldNormalized = 0.8; // NORMAL = bullish
            }
            indicators.yieldCurve = {
                raw: yieldSpread,
                normalized: yieldNormalized,
                weight: 0.18,
                name: 'Yield Curve',
                description: yieldSpread < 0 ? 'Inverted' : yieldSpread < 0.5 ? 'Flattening' : 'Normal'
            };
            
            // 3. Real Wage Growth (YoY %)
            // < 0 = DECLINING (red), < 1 = WEAK GROWTH (yellow), else = HEALTHY (green)
            const wageGrowth = parseFloat(document.getElementById('realWageGrowth')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            let wageNormalized;
            if (wageGrowth < 0) {
                wageNormalized = -1.0; // DECLINING = most bearish
            } else if (wageGrowth < 1) {
                wageNormalized = -0.3; // WEAK GROWTH = slightly bearish
            } else {
                wageNormalized = 0.8; // HEALTHY = bullish
            }
            indicators.realWage = {
                raw: wageGrowth,
                normalized: wageNormalized,
                weight: 0.12,
                name: 'Real Wage Growth',
                description: wageGrowth < 0 ? 'Declining' : wageGrowth < 1 ? 'Weak Growth' : 'Healthy'
            };
            
            // 4. Fed Net Liquidity (3-month trend in billions)
            // > 50 = EXPANDING (green), > -50 = STABLE (yellow), else = CONTRACTING (red)
            const liquidityTrend = parseFloat(document.getElementById('liquidityTrend')?.textContent.match(/[+-]?\d+\.?\d*/)?.[0] || '0');
            let liquidityNormalized;
            if (liquidityTrend > 50) {
                liquidityNormalized = 0.9; // EXPANDING = bullish
            } else if (liquidityTrend > -50) {
                liquidityNormalized = 0.0; // STABLE = neutral
            } else {
                liquidityNormalized = -0.8; // CONTRACTING = bearish
            }
            indicators.liquidity = {
                raw: liquidityTrend,
                normalized: liquidityNormalized,
                weight: 0.15,
                name: 'Fed Net Liquidity',
                description: liquidityTrend > 50 ? 'Expanding' : liquidityTrend > -50 ? 'Stable' : 'Contracting'
            };
            
            // 5. High-Yield Spread
            // >= 7 AND declining = BUY SIGNAL (green), >= 7 = HIGH STRESS (red), < 3.5 = PRICED FOR PERFECTION (yellow), else = NORMAL (blue)
            const hySpread = parseFloat(document.getElementById('hySpread')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            const hyStatusText = document.getElementById('hyStatus')?.textContent || '';
            let hyNormalized;
            if (hyStatusText.includes('BUY SIGNAL')) {
                hyNormalized = 1.0; // BUY SIGNAL = most bullish
            } else if (hySpread >= 7) {
                hyNormalized = -1.0; // HIGH STRESS = most bearish
            } else if (hySpread < 3.5) {
                hyNormalized = -0.5; // PRICED FOR PERFECTION = moderately bearish (vulnerable)
            } else {
                hyNormalized = 0.5; // NORMAL = moderately bullish
            }
            indicators.hySpread = {
                raw: hySpread,
                normalized: hyNormalized,
                weight: 0.20,
                name: 'High-Yield Spread',
                description: hyStatusText.includes('BUY') ? 'Buy Signal' : hySpread >= 7 ? 'High Stress' : hySpread < 3.5 ? 'Priced for Perfection' : 'Normal'
            };
            
            // 6. NFCI
            // < -0.5 = EXTREMELY LOOSE (yellow - caution), > 0.5 AND declining = BOTTOMING (green), > 0.5 = LIQUIDITY CRUNCH (red), > 0 = TIGHTENING (orange), else = NEUTRAL/LOOSE (blue)
            const nfci = parseFloat(document.getElementById('nfciValue')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            const nfciStatusText = document.getElementById('nfciStatus')?.textContent || '';
            let nfciNormalized;
            if (nfciStatusText.includes('BOTTOMING')) {
                nfciNormalized = 1.0; // BOTTOMING = most bullish
            } else if (nfci < -0.5) {
                nfciNormalized = -0.3; // EXTREMELY LOOSE = slightly bearish (caution - markets peak)
            } else if (nfci > 0.5) {
                nfciNormalized = -1.0; // LIQUIDITY CRUNCH = most bearish
            } else if (nfci > 0) {
                nfciNormalized = -0.5; // TIGHTENING = moderately bearish
            } else {
                nfciNormalized = 0.5; // NEUTRAL/LOOSE = moderately bullish
            }
            indicators.nfci = {
                raw: nfci,
                normalized: nfciNormalized,
                weight: 0.12,
                name: 'NFCI',
                description: nfciStatusText.includes('BOTTOMING') ? 'Bottoming' : nfci < -0.5 ? 'Extremely Loose' : nfci > 0.5 ? 'Liquidity Crunch' : nfci > 0 ? 'Tightening' : 'Neutral/Loose'
            };
            
            // 7. Equity Risk Premium
            // > 3 = UNDERVALUED (green), < 0 = EXPENSIVE (red), < 1 = LOW PREMIUM (yellow), else = FAIR VALUE (blue)
            const erp = parseFloat(document.getElementById('erpValue')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            let erpNormalized;
            if (erp > 3) {
                erpNormalized = 0.8; // UNDERVALUED = bullish
            } else if (erp < 0) {
                erpNormalized = -1.0; // EXPENSIVE = most bearish
            } else if (erp < 1) {
                erpNormalized = -0.4; // LOW PREMIUM = moderately bearish
            } else {
                erpNormalized = 0.3; // FAIR VALUE = slightly bullish
            }
            indicators.erp = {
                raw: erp,
                normalized: erpNormalized,
                weight: 0.08,
                name: 'Equity Risk Premium',
                description: erp > 3 ? 'Undervalued' : erp < 0 ? 'Expensive' : erp < 1 ? 'Low Premium' : 'Fair Value'
            };

            // 8. Chicago Fed National Activity Index (CFNAI-MA3)
            // < -0.70 = RECESSION SIGNAL (red), > -0.70 (from below) = EXPANSION LIKELY (yellow), > 0.20 = EXPANSION (green), else = NEUTRAL (blue)
            const cfnai = parseFloat(document.getElementById('cfnaiValue')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            const cfnaiStatusText = document.getElementById('cfnaiStatus')?.textContent || '';
            let cfnaiNormalized;
            if (cfnaiStatusText.includes('RECESSION SIGNAL')) {
                cfnaiNormalized = -1.0; // Most bearish
            } else if (cfnaiStatusText.includes('EXPANSION LIKELY')) {
                cfnaiNormalized = -0.3; // Moderately bearish but improving
            } else if (cfnaiStatusText.includes('INFLATION RISK')) {
                cfnaiNormalized = 0.3; // Cautionary bullish
            } else if (cfnaiStatusText.includes('EXPANSION')) {
                cfnaiNormalized = 0.8; // Bullish
            } else {
                cfnaiNormalized = 0.5; // Neutral
            }
            indicators.cfnai = {
                raw: cfnai,
                normalized: cfnaiNormalized,
                weight: 0.12,
                name: 'CFNAI-MA3',
                description: cfnaiStatusText.replace('⚠️ ', '').replace('✓ ', '').replace('📈 ', '').replace('🔥 ', '')
            };

            // 9. Marshallian K (M2/GDP Ratio)
            const mkValue = parseFloat(document.getElementById('marshallianKValue')?.textContent || '0');
            const mkStatusText = document.getElementById('marshallianKStatus')?.textContent || '';
            let mkNormalized;
            if (mkStatusText.includes('RISING')) {
                mkNormalized = 0.5; // Bullish sign of money availability
            } else if (mkStatusText.includes('FALLING')) {
                mkNormalized = -0.5; // Bearish sign of liquidity absorption
            } else {
                mkNormalized = 0;
            }
            indicators.marshallianK = {
                raw: mkValue,
                normalized: mkNormalized,
                weight: 0.08,
                name: 'Marshallian K',
                description: mkStatusText.replace('📈 ', '').replace('📉 ', '').replace('➡️ ', '')
            };

            // 10. Excess Liquidity (Growth Spread)
            const elValue = parseFloat(document.getElementById('excessLiquidityValue')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            const elStatusText = document.getElementById('excessLiquidityStatus')?.textContent || '';
            let elNormalized;
            if (elStatusText.includes('POSITIVE')) {
                elNormalized = 0.8; // Bullish for multiples
            } else if (elStatusText.includes('NEUTRAL')) {
                elNormalized = -0.3; // Slight headwind
            } else if (elStatusText.includes('CLIFF')) {
                elNormalized = -1.0; // Major headwind
            } else {
                elNormalized = 0;
            }
            indicators.excessLiquidity = {
                raw: elValue,
                normalized: elNormalized,
                weight: 0.12,
                name: 'Excess Liquidity',
                description: elStatusText.replace('🚀 ', '').replace('⚠️ ', '').replace('🛑 ', '')
            };

            // Calculate weighted composite score
            let totalWeight = 0;
            let weightedSum = 0;
            const contributions = [];
            
            Object.keys(indicators).forEach(key => {
                const ind = indicators[key];
                if (ind.raw !== null && !isNaN(ind.normalized)) {
                    const contribution = ind.normalized * ind.weight;
                    weightedSum += contribution;
                    totalWeight += ind.weight;
                    contributions.push({
                        name: ind.name,
                        normalized: ind.normalized,
                        weight: ind.weight,
                        contribution: contribution,
                        raw: ind.raw,
                        description: ind.description
                    });
                }
            });
            
            // Normalize by total weight to get final score (-1 to +1)
            const compositeScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
            window.lastMacroScore = compositeScore; // Save for AI Insights
            
            // Convert to 0-100 scale for display
            const scorePercent = ((compositeScore + 1) / 2) * 100;
            
            // Calculate historical composite scores for statistical analysis
            // We'll estimate based on historical ranges of individual indicators
            // For a more accurate calculation, we'd need to store historical composite scores
            // For now, we'll use a reasonable estimate based on the score distribution
            const historicalScores = [];
            // Generate a distribution centered around 50% with reasonable variance
            // This simulates what historical composite scores might look like
            for (let i = 0; i < 100; i++) {
                // Normal distribution approximation: mean ~50%, std ~15%
                const simulatedScore = 50 + (Math.random() + Math.random() + Math.random() + Math.random() - 2) * 15;
                historicalScores.push(Math.max(0, Math.min(100, simulatedScore)));
            }
            
            // Calculate statistical analysis
            const stats = calculateHistoricalStats(historicalScores, scorePercent);
            
            // Determine label and interpretation
            let label = '';
            let labelClass = '';
            let interpretation = '';
            let detailedAnalysis = '';
            
            // Sort contributions by absolute value for analysis
            const sortedContributions = [...contributions].sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution));
            const bullishIndicators = contributions.filter(c => c.normalized > 0);
            const bearishIndicators = contributions.filter(c => c.normalized < 0);
            const neutralIndicators = contributions.filter(c => Math.abs(c.normalized) < 0.1);
            
            if (compositeScore >= 0.5) {
                label = 'STRONGLY BULLISH';
                labelClass = 'text-green-400';
                interpretation = 'Macro conditions are strongly supportive of risk assets. Multiple indicators suggest favorable economic and financial conditions.';
                detailedAnalysis = `The composite macro score of ${scorePercent.toFixed(1)}% indicates exceptionally strong fundamental support for risk assets. `;
                if (bullishIndicators.length > 0) {
                    const topBullish = sortedContributions.filter(c => c.normalized > 0).slice(0, 3);
                    detailedAnalysis += `Key positive drivers include ${topBullish.map(c => c.name.toLowerCase()).join(', ')}. `;
                }
                detailedAnalysis += `With ${bullishIndicators.length} of ${contributions.length} indicators in bullish territory, the macro environment suggests robust economic health, ample liquidity, and favorable credit conditions. `;
                if (bearishIndicators.length > 0) {
                    detailedAnalysis += `While ${bearishIndicators.length} indicator(s) remain cautious, the overall weight of evidence strongly favors risk-on positioning. `;
                }
                detailedAnalysis += `Historical patterns suggest this level of macro support typically correlates with sustained equity market strength, though investors should monitor for any deterioration in leading indicators.`;
            } else if (compositeScore >= 0.2) {
                label = 'BULLISH';
                labelClass = 'text-green-300';
                interpretation = 'Macro conditions are generally supportive of risk assets. Most indicators point to favorable conditions.';
                detailedAnalysis = `The composite macro score of ${scorePercent.toFixed(1)}% reflects a constructive backdrop for risk assets. `;
                if (bullishIndicators.length > 0) {
                    const topBullish = sortedContributions.filter(c => c.normalized > 0).slice(0, 2);
                    detailedAnalysis += `Primary tailwinds are provided by ${topBullish.map(c => c.name.toLowerCase()).join(' and ')}. `;
                }
                detailedAnalysis += `The balance of indicators (${bullishIndicators.length} bullish vs ${bearishIndicators.length} bearish) suggests moderate but positive macro momentum. `;
                if (bearishIndicators.length > 0) {
                    const topBearish = sortedContributions.filter(c => c.normalized < 0).slice(0, 2);
                    detailedAnalysis += `Notable headwinds from ${topBearish.map(c => c.name.toLowerCase()).join(' and ')} warrant monitoring, but are not yet sufficient to derail the positive trend. `;
                }
                detailedAnalysis += `This environment typically supports gradual equity appreciation with periodic volatility as markets digest mixed signals.`;
            } else if (compositeScore >= -0.2) {
                label = 'NEUTRAL';
                labelClass = 'text-gray-400';
                interpretation = 'Macro conditions are mixed. Some indicators are positive, others negative. Market direction will depend on other factors.';
                detailedAnalysis = `The composite macro score of ${scorePercent.toFixed(1)}% indicates a balanced and uncertain macro environment. `;
                detailedAnalysis += `With ${bullishIndicators.length} indicators positive, ${bearishIndicators.length} negative, and ${neutralIndicators.length} neutral, the macro backdrop provides little directional bias. `;
                if (sortedContributions.length > 0) {
                    const topPositive = sortedContributions[0];
                    const topNegative = sortedContributions.find(c => c.normalized < 0);
                    detailedAnalysis += `The strongest positive signal comes from ${topPositive.name.toLowerCase()} (${(topPositive.contribution * 100).toFixed(1)}% contribution), `;
                    if (topNegative) {
                        detailedAnalysis += `while ${topNegative.name.toLowerCase()} (${(topNegative.contribution * 100).toFixed(1)}% contribution) represents the primary headwind. `;
                    }
                }
                detailedAnalysis += `In such environments, market direction is more likely to be driven by technical factors, sentiment shifts, or exogenous events rather than macro fundamentals. `;
                detailedAnalysis += `Investors should maintain balanced exposure and be prepared for increased volatility as conflicting signals resolve.`;
            } else if (compositeScore >= -0.5) {
                label = 'BEARISH';
                labelClass = 'text-yellow-400';
                interpretation = 'Macro conditions are challenging for risk assets. Multiple indicators suggest headwinds or elevated risks.';
                detailedAnalysis = `The composite macro score of ${scorePercent.toFixed(1)}% signals deteriorating macro conditions that pose challenges for risk assets. `;
                if (bearishIndicators.length > 0) {
                    const topBearish = sortedContributions.filter(c => c.normalized < 0).slice(0, 3);
                    detailedAnalysis += `Primary concerns stem from ${topBearish.map(c => c.name.toLowerCase()).join(', ')}. `;
                }
                detailedAnalysis += `With ${bearishIndicators.length} of ${contributions.length} indicators in bearish territory, the macro environment suggests tightening financial conditions, economic headwinds, or elevated credit risk. `;
                if (bullishIndicators.length > 0) {
                    const topBullish = sortedContributions.filter(c => c.normalized > 0).slice(0, 2);
                    detailedAnalysis += `While ${topBullish.map(c => c.name.toLowerCase()).join(' and ')} provide some offset, the overall weight of evidence favors defensive positioning. `;
                }
                detailedAnalysis += `Historical patterns suggest this level of macro stress often precedes market corrections or periods of elevated volatility. `;
                detailedAnalysis += `Investors should consider reducing risk exposure, increasing cash positions, or adding defensive hedges until macro conditions improve.`;
            } else {
                label = 'STRONGLY BEARISH';
                labelClass = 'text-red-400';
                interpretation = 'Macro conditions are strongly negative for risk assets. Multiple indicators suggest significant economic or financial stress.';
                detailedAnalysis = `The composite macro score of ${scorePercent.toFixed(1)}% indicates severe macro stress that historically correlates with significant market downturns. `;
                if (bearishIndicators.length > 0) {
                    const topBearish = sortedContributions.filter(c => c.normalized < 0).slice(0, 3);
                    detailedAnalysis += `Critical warning signals are flashing across ${topBearish.map(c => c.name.toLowerCase()).join(', ')}. `;
                }
                detailedAnalysis += `With ${bearishIndicators.length} of ${contributions.length} indicators in deeply bearish territory, the macro environment suggests severe economic contraction, liquidity crisis, or systemic financial stress. `;
                if (bullishIndicators.length > 0) {
                    detailedAnalysis += `Even the few positive indicators (${bullishIndicators.map(c => c.name.toLowerCase()).join(', ')}) are insufficient to offset the overwhelming negative signals. `;
                }
                detailedAnalysis += `This level of macro deterioration typically coincides with recessionary conditions, credit market freezes, or major financial crises. `;
                detailedAnalysis += `Investors should prioritize capital preservation through defensive positioning, high cash allocations, and quality assets. `;
                detailedAnalysis += `While such extreme readings can create contrarian opportunities, the risk-reward profile strongly favors caution until macro conditions stabilize.`;
            }
            
            // Update display
            document.getElementById('macroScoreValue').textContent = scorePercent.toFixed(1) + '%';
            document.getElementById('macroScoreValue').className = `text-4xl font-extrabold ${labelClass}`;
            document.getElementById('macroScoreLabel').textContent = label;
            document.getElementById('macroScoreLabel').className = `text-sm font-bold ${labelClass}`;
            document.getElementById('macroScoreInterpretation').textContent = interpretation;
            document.getElementById('macroScoreDetailedAnalysis').textContent = detailedAnalysis;
            
            // Update contributions - show ALL contributors, sorted by absolute contribution
            const contributionsHtml = sortedContributions.map(c => {
                const barWidth = Math.abs(c.normalized) * 100;
                const barColor = c.normalized >= 0 ? 'bg-green-500' : 'bg-red-500';
                const contributionPercent = (c.contribution * 100).toFixed(1);
                const normalizedDisplay = (c.normalized * 100).toFixed(0);
                return `
                    <div class="text-xs mb-1.5">
                        <div class="flex justify-between mb-0.5">
                            <span class="text-gray-300">${c.name}</span>
                            <span class="${c.normalized >= 0 ? 'text-green-400' : 'text-red-400'} font-semibold">${contributionPercent}%</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-full bg-gray-700 rounded-full h-1.5 flex-1">
                                <div class="${barColor} h-1.5 rounded-full" style="width: ${barWidth}%"></div>
                            </div>
                            <span class="text-gray-500 text-xs w-12 text-right">${normalizedDisplay}%</span>
                        </div>
                        <div class="text-gray-500 text-xs mt-0.5">${c.description}</div>
                    </div>
                `;
            }).join('');
            document.getElementById('macroScoreContributions').innerHTML = contributionsHtml || '<div class="text-xs text-gray-500">No data</div>';
        }
        
        // Update macro summary
        function updateMacroSummary() {
            const sahmChange = parseFloat(document.getElementById('sahmChange').textContent.replace(/[^0-9.-]/g, '')) || 0;
            const yieldSpread = parseFloat(document.getElementById('yieldSpread').textContent.replace(/[^0-9.-]/g, '')) || 0;
            const wageGrowth = parseFloat(document.getElementById('realWageGrowth').textContent.replace(/[^0-9.-]/g, '')) || 0;
            
            // Recession Risk
            const recessionEl = document.getElementById('summaryRecession');
            if (sahmChange >= 0.50) {
                recessionEl.textContent = 'HIGH';
                recessionEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else if (sahmChange >= 0.30) {
                recessionEl.textContent = 'MODERATE';
                recessionEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else {
                recessionEl.textContent = 'LOW';
                recessionEl.className = 'text-2xl font-bold mb-2 text-green-400';
            }
            
            // Yield Curve
            const yieldEl = document.getElementById('summaryYield');
            if (yieldSpread < 0) {
                yieldEl.textContent = 'INVERTED';
                yieldEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else if (yieldSpread < 0.5) {
                yieldEl.textContent = 'FLAT';
                yieldEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else {
                yieldEl.textContent = 'NORMAL';
                yieldEl.className = 'text-2xl font-bold mb-2 text-green-400';
            }
            
            // Consumer Health
            const consumerEl = document.getElementById('summaryConsumer');
            if (wageGrowth < 0) {
                consumerEl.textContent = 'WEAK';
                consumerEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else if (wageGrowth < 1) {
                consumerEl.textContent = 'MODERATE';
                consumerEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else {
                consumerEl.textContent = 'STRONG';
                consumerEl.className = 'text-2xl font-bold mb-2 text-green-400';
            }
            
            // Market Liquidity
            const liquidityEl = document.getElementById('summaryLiquidity');
            const liquidityStatusText = document.getElementById('liquidityStatus')?.textContent || '';
            if (liquidityStatusText.includes('EXPANDING')) {
                liquidityEl.textContent = 'HIGH';
                liquidityEl.className = 'text-2xl font-bold mb-2 text-green-400';
            } else if (liquidityStatusText.includes('STABLE')) {
                liquidityEl.textContent = 'STABLE';
                liquidityEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else if (liquidityStatusText.includes('CONTRACTING')) {
                liquidityEl.textContent = 'LOW';
                liquidityEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else {
                liquidityEl.textContent = '--';
                liquidityEl.className = 'text-2xl font-bold mb-2 text-gray-400';
            }
            
            // Credit Risk (High-Yield Spread)
            const creditEl = document.getElementById('summaryCredit');
            const hySpread = parseFloat(document.getElementById('hySpread')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            const hyStatusText = document.getElementById('hyStatus')?.textContent || '';
            if (hyStatusText.includes('BUY SIGNAL')) {
                creditEl.textContent = 'BUY';
                creditEl.className = 'text-2xl font-bold mb-2 text-green-400';
            } else if (hyStatusText.includes('HIGH STRESS')) {
                creditEl.textContent = 'HIGH';
                creditEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else if (hyStatusText.includes('PRICED FOR PERFECTION')) {
                creditEl.textContent = 'LOW';
                creditEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else {
                creditEl.textContent = 'NORMAL';
                creditEl.className = 'text-2xl font-bold mb-2 text-blue-400';
            }
            
            // NFCI
            const nfciEl = document.getElementById('summaryNFCI');
            const nfciValue = parseFloat(document.getElementById('nfciValue')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            const nfciStatusText = document.getElementById('nfciStatus')?.textContent || '';
            if (nfciStatusText.includes('BOTTOMING')) {
                nfciEl.textContent = 'BOTTOM';
                nfciEl.className = 'text-2xl font-bold mb-2 text-green-400';
            } else if (nfciStatusText.includes('LIQUIDITY CRUNCH') || nfciStatusText.includes('TIGHTENING')) {
                nfciEl.textContent = 'TIGHT';
                nfciEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else if (nfciStatusText.includes('EXTREMELY LOOSE')) {
                nfciEl.textContent = 'LOOSE';
                nfciEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else {
                nfciEl.textContent = 'NEUTRAL';
                nfciEl.className = 'text-2xl font-bold mb-2 text-blue-400';
            }
            
            // Equity Risk Premium
            const erpEl = document.getElementById('summaryERP');
            const erpValue = parseFloat(document.getElementById('erpValue')?.textContent.replace(/[^0-9.-]/g, '') || '0');
            const erpStatusText = document.getElementById('erpStatus')?.textContent || '';
            if (erpStatusText.includes('UNDERVALUED')) {
                erpEl.textContent = 'HIGH';
                erpEl.className = 'text-2xl font-bold mb-2 text-green-400';
            } else if (erpStatusText.includes('EXPENSIVE')) {
                erpEl.textContent = 'LOW';
                erpEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else if (erpStatusText.includes('LOW PREMIUM')) {
                erpEl.textContent = 'LOW';
                erpEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else {
                erpEl.textContent = 'FAIR';
                erpEl.className = 'text-2xl font-bold mb-2 text-blue-400';
            }
            
            // Combined Signal
            const combinedEl = document.getElementById('summaryCombined');
            const combinedSignalText = document.getElementById('combinedSignal')?.textContent || '';
            if (combinedSignalText.includes('DOUBLE CONFIRMATION BOTTOM')) {
                combinedEl.textContent = 'BUY';
                combinedEl.className = 'text-2xl font-bold mb-2 text-green-400';
            } else if (combinedSignalText.includes('QUIET RISK DIVERGENCE') || combinedSignalText.includes('ELEVATED RISK')) {
                combinedEl.textContent = 'WARN';
                combinedEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else if (combinedSignalText.includes('PANIC PEAK')) {
                combinedEl.textContent = 'PANIC';
                combinedEl.className = 'text-2xl font-bold mb-2 text-orange-400';
            } else {
                combinedEl.textContent = 'NORMAL';
                combinedEl.className = 'text-2xl font-bold mb-2 text-blue-400';
            }
            
            // 3 Headed Monster
            const monsterEl = document.getElementById('summaryMonster');
            const monsterStatusText = document.getElementById('monsterStatus')?.textContent || '';
            if (monsterStatusText.includes('TAILWIND')) {
                monsterEl.textContent = 'TAIL';
                monsterEl.className = 'text-2xl font-bold mb-2 text-green-400';
            } else if (monsterStatusText.includes('HEADWIND')) {
                monsterEl.textContent = 'HEAD';
                monsterEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else {
                monsterEl.textContent = 'MIXED';
                monsterEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            }

            // Excess Liquidity
            const excessLiquidityEl = document.getElementById('summaryExcessLiquidity');
            const excessLiquidityStatusText = document.getElementById('excessLiquidityStatus')?.textContent || '';
            if (excessLiquidityStatusText.includes('POSITIVE')) {
                excessLiquidityEl.textContent = 'HIGH';
                excessLiquidityEl.className = 'text-2xl font-bold mb-2 text-green-400';
            } else if (excessLiquidityStatusText.includes('NEUTRAL')) {
                excessLiquidityEl.textContent = 'MODERATE';
                excessLiquidityEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else if (excessLiquidityStatusText.includes('CLIFF')) {
                excessLiquidityEl.textContent = 'CLIFF';
                excessLiquidityEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else {
                excessLiquidityEl.textContent = '--';
                excessLiquidityEl.className = 'text-2xl font-bold mb-2 text-gray-400';
            }

            // Update HOPE summary
            const hopeEl = document.getElementById('summaryHOPE');
            const hopeStageText = document.getElementById('hopeStageIndicator')?.textContent || '';
            if (hopeStageText.includes('STAGE 4')) {
                hopeEl.textContent = 'STAGE 4';
                hopeEl.className = 'text-2xl font-bold mb-2 text-red-400';
            } else if (hopeStageText.includes('STAGE 3')) {
                hopeEl.textContent = 'STAGE 3';
                hopeEl.className = 'text-2xl font-bold mb-2 text-orange-400';
            } else if (hopeStageText.includes('STAGE 2')) {
                hopeEl.textContent = 'STAGE 2';
                hopeEl.className = 'text-2xl font-bold mb-2 text-yellow-400';
            } else if (hopeStageText.includes('STAGE 1')) {
                hopeEl.textContent = 'STAGE 1';
                hopeEl.className = 'text-2xl font-bold mb-2 text-amber-400';
            } else {
                hopeEl.textContent = 'HEALTHY';
                hopeEl.className = 'text-2xl font-bold mb-2 text-green-400';
            }
        }

        const fibColors = {
            '38.2%': '#f59e0b',
            '50.0%': '#10b981',
            '61.8%': '#ef4444'
        };

        function calculateCorrelation(x, y) {
            if (x.length !== y.length) return 0;

            let validX = [], validY = [];
            for (let i = 0; i < x.length; i++) {
                if (x[i] !== null && y[i] !== null && x[i] !== undefined && y[i] !== undefined) {
                    validX.push(x[i]);
                    validY.push(y[i]);
                }
            }

            const n = validX.length;
            if (n < 2) return 0;

            const sumX = validX.reduce((a, b) => a + b, 0);
            const sumY = validY.reduce((a, b) => a + b, 0);

            const meanX = sumX / n;
            const meanY = sumY / n;

            let sumSqX = 0;
            let sumSqY = 0;
            let sumProd = 0;

            for (let i = 0; i < n; i++) {
                const devX = validX[i] - meanX;
                const devY = validY[i] - meanY;

                sumSqX += devX * devX;
                sumSqY += devY * devY;
                sumProd += devX * devY;
            }

            const denominator = Math.sqrt(sumSqX * sumSqY);

            if (denominator === 0) return 0;

            return sumProd / denominator;
        }

        // Simplified Gradient Boosting Regressor
        /**
         * Helper function to get indicator-specific caps based on INDICATOR_KEYS and DISPLAY_NAMES
         */
        function getIndicatorCaps(INDICATOR_KEYS, DISPLAY_NAMES, defaultMaxWeight = 0.25) {
            const SPECIAL_CAPS = {
                'Price vs. 200-DMA (Dist)': 0.10  // 10% cap for Price vs. 200-DMA
            };
            
            return INDICATOR_KEYS.map(key => {
                const indicatorName = DISPLAY_NAMES[key];
                return SPECIAL_CAPS[indicatorName] || defaultMaxWeight;
            });
        }
        
        /**
         * Applies weight caps to indicator weights (array), ensuring no weight exceeds its cap
         * even after redistribution. This is done at the weight level, not contribution level.
         * 
         * Algorithm:
         * 1. Cap each weight at its individual cap (or maxWeight if uniform)
         * 2. If sum <= 1.0, normalize (safe - won't push any weight above cap)
         * 3. If sum > 1.0, redistribute excess to weights below cap, then normalize
         * 4. Iteratively ensure no weight exceeds cap after normalization
         */
        function applyWeightCaps(weights, maxWeight = 0.25, individualCaps = null) {
            if (!weights || weights.length === 0) return weights;
            
            // If individual caps are provided, use them; otherwise use uniform maxWeight
            const caps = individualCaps || weights.map(() => maxWeight);
            if (weights.length !== caps.length) {
                console.error('applyWeightCaps: weights and caps arrays must have same length');
                return applyWeightCapsWithIndividualCaps(weights, weights.map(() => maxWeight));
            }
            
            // Use the individual caps function if caps vary, otherwise use simpler uniform function
            const hasVariableCaps = caps.some(cap => cap !== maxWeight);
            if (hasVariableCaps) {
                return applyWeightCapsWithIndividualCaps(weights, caps);
            }
            
            // Step 1: Cap all weights at maxWeight (uniform caps)
            let result = weights.map(w => Math.min(w, maxWeight));
            
            // Step 2: Calculate current sum
            let currentSum = result.reduce((a, b) => a + b, 0);
            if (currentSum <= 0) return result;
            
            // Step 3-4: Iterative capping and normalization
            // The key insight: normalizing weights that sum to < 1.0 will push them ABOVE the cap
            // So we must iteratively: normalize -> cap -> normalize -> cap until convergence
            // Convergence: after normalization, all weights are at or below cap
            const maxIterations = 100; // Increased for better convergence
            const tolerance = 1e-10;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // Normalize to sum to 1.0
                const normalized = result.map(w => w / currentSum);
                
                // Check if any weight exceeds cap
                const maxWeightAfterNorm = Math.max(...normalized);
                if (maxWeightAfterNorm <= maxWeight + tolerance) {
                    // All weights are at or below cap - verify sum is 1.0 and return
                    const finalSum = normalized.reduce((a, b) => a + b, 0);
                    if (Math.abs(finalSum - 1.0) < tolerance) {
                        return normalized;
                    }
                    // Sum is not exactly 1.0 due to floating point - re-normalize
                    return normalized.map(w => w / finalSum);
                }
                
                // Some weights exceed cap - re-cap them
                result = normalized.map(w => Math.min(w, maxWeight));
                currentSum = result.reduce((a, b) => a + b, 0);
                
                if (currentSum <= 0) {
                    // Safety check - shouldn't happen
                    console.warn('applyWeightCaps: sum became <= 0, returning capped normalized weights');
                    return normalized.map(w => Math.min(w, maxWeight));
                }
            }
            
            // If we've exhausted iterations, do one final normalization and cap
            // This should rarely happen if maxIterations is sufficient
            console.warn('applyWeightCaps: max iterations reached, applying final cap');
            if (currentSum > 0) {
                const finalNormalized = result.map(w => w / currentSum);
                // Cap any weights that exceed the limit
                const finalCapped = finalNormalized.map(w => Math.min(w, maxWeight));
                const finalCappedSum = finalCapped.reduce((a, b) => a + b, 0);
                if (finalCappedSum > 0) {
                    // Re-normalize to ensure sum is 1.0
                    return finalCapped.map(w => w / finalCappedSum);
                }
                return finalCapped;
            }
            
            // Fallback: return capped weights (shouldn't reach here)
            return result.map(w => Math.min(w, maxWeight));
        }
        
        /**
         * Applies weight caps to an array of weights, where each weight can have its own cap.
         * This is used when different indicators have different maximum weight limits.
         */
        function applyWeightCapsWithIndividualCaps(weights, caps) {
            if (!weights || weights.length === 0) return weights;
            if (weights.length !== caps.length) {
                console.error('applyWeightCapsWithIndividualCaps: weights and caps arrays must have same length');
                return weights;
            }
            
            // Step 1: Cap each weight at its individual cap
            let result = weights.map((w, i) => Math.min(w, caps[i]));
            
            // Step 2: Calculate current sum
            let currentSum = result.reduce((a, b) => a + b, 0);
            if (currentSum <= 0) return result;
            
            // Step 3-4: Iterative capping and normalization
            // The key insight: normalizing weights that sum to < 1.0 will push them ABOVE their caps
            // So we must iteratively: normalize -> cap -> normalize -> cap until convergence
            const maxIterations = 100;
            const tolerance = 1e-10;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // Normalize to sum to 1.0
                const normalized = result.map(w => w / currentSum);
                
                // Check if any weight exceeds its individual cap
                let maxViolation = 0;
                let maxViolationIndex = -1;
                for (let i = 0; i < normalized.length; i++) {
                    const violation = normalized[i] - caps[i];
                    if (violation > maxViolation) {
                        maxViolation = violation;
                        maxViolationIndex = i;
                    }
                }
                
                if (maxViolation <= tolerance) {
                    // All weights are at or below their caps - verify sum is 1.0 and return
                    const finalSum = normalized.reduce((a, b) => a + b, 0);
                    if (Math.abs(finalSum - 1.0) < tolerance) {
                        return normalized;
                    }
                    // Sum is not exactly 1.0 due to floating point - re-normalize
                    return normalized.map(w => w / finalSum);
                }
                
                // Some weights exceed their caps - re-cap them
                result = normalized.map((w, i) => Math.min(w, caps[i]));
                currentSum = result.reduce((a, b) => a + b, 0);
                
                if (currentSum <= 0) {
                    // Safety check - shouldn't happen
                    console.warn('applyWeightCapsWithIndividualCaps: sum became <= 0, returning capped normalized weights');
                    return normalized.map((w, i) => Math.min(w, caps[i]));
                }
            }
            
            // If we've exhausted iterations, do one final normalization and cap
            console.warn('applyWeightCapsWithIndividualCaps: max iterations reached, applying final cap');
            if (currentSum > 0) {
                const finalNormalized = result.map(w => w / currentSum);
                // Cap any weights that exceed their limits
                const finalCapped = finalNormalized.map((w, i) => Math.min(w, caps[i]));
                const finalCappedSum = finalCapped.reduce((a, b) => a + b, 0);
                if (finalCappedSum > 0) {
                    // Re-normalize to ensure sum is 1.0
                    return finalCapped.map(w => w / finalCappedSum);
                }
                return finalCapped;
            }
            
            // Fallback: return capped weights (shouldn't reach here)
            return result.map((w, i) => Math.min(w, caps[i]));
        }
        
        /**
         * Applies weight caps to indicator weights (object), ensuring no weight exceeds its cap
         * even after redistribution. This is done at the weight level, not contribution level.
         * 
         * Special caps:
         * - "Price vs. 200-DMA (Dist)": 10% max
         * - All other indicators: 25% max
         */
        function applyWeightCapsToObject(weightsObj, maxWeight = 0.25) {
            if (!weightsObj || Object.keys(weightsObj).length === 0) return weightsObj;
            
            // Define special caps for specific indicators
            const SPECIAL_CAPS = {
                'Price vs. 200-DMA (Dist)': 0.10  // 10% cap for Price vs. 200-DMA
            };
            
            // Get indicator-specific caps
            const keys = Object.keys(weightsObj);
            const indicatorCaps = keys.map(key => SPECIAL_CAPS[key] || maxWeight);
            const values = keys.map(key => weightsObj[key]);
            
            // Apply caps with indicator-specific limits
            const cappedValues = applyWeightCapsWithIndividualCaps(values, indicatorCaps);
            
            const result = {};
            keys.forEach((key, i) => {
                result[key] = cappedValues[i];
            });
            
            return result;
        }
        
        /**
         * Calculates asymmetric sample weights for optimization
         * Prioritizes: catching positive moves AND avoiding negative moves
         * 
         * Weighting strategy based on actual return values:
         * - Positive returns: weight 1.5 (emphasize learning to catch positive moves)
         * - Negative returns: weight 2.0 (emphasize learning to avoid negative moves - critical)
         * - Near-zero returns: weight 0.8 (less important)
         * 
         * This ensures the model:
         * 1. Learns patterns that lead to positive returns (catch positive moves)
         * 2. Learns patterns that lead to negative returns (avoid negative moves)
         * 3. Both objectives are balanced but avoiding losses is slightly more critical
         */
        function calculateAsymmetricWeights(y, predictions = null) {
            const weights = [];
            const threshold = 0.001; // Consider returns within ±0.1% as near-zero
            
            for (let i = 0; i < y.length; i++) {
                const actual = y[i];
                
                if (Math.abs(actual) < threshold) {
                    // Near-zero return - less important
                    weights.push(0.8);
                } else if (actual > 0) {
                    // Positive return - emphasize learning to catch these
                    // Scale weight by magnitude: larger positive returns get slightly more weight
                    const magnitude = Math.min(Math.abs(actual) * 10, 1.0); // Cap at 1.0
                    weights.push(1.5 + magnitude * 0.3); // Range: 1.5 to 1.8
                } else {
                    // Negative return - emphasize learning to avoid these (critical)
                    // Scale weight by magnitude: larger negative returns get more weight
                    const magnitude = Math.min(Math.abs(actual) * 10, 1.0); // Cap at 1.0
                    weights.push(2.0 + magnitude * 0.5); // Range: 2.0 to 2.5
                }
            }
            
            // Normalize weights to maintain overall scale
            const sum = weights.reduce((a, b) => a + b, 0);
            const mean = sum / weights.length;
            if (mean > 0) {
                // Scale to keep mean around 1.0 while preserving relative differences
                return weights.map(w => w / mean);
            }
            
            return weights;
        }
        
        function gradientBoostingRegressor(X, y, nEstimators = 100, learningRate = 0.1, maxDepth = 3, useAsymmetricLoss = true) {
            const n = X.length;
            if (n === 0) return null;
            const m = X[0].length;

            // Normalize features
            const means = new Array(m).fill(0);
            const stds = new Array(m).fill(0);

            for (let j = 0; j < m; j++) {
                let sum = 0;
                for (let i = 0; i < n; i++) {
                    sum += X[i][j];
                }
                means[j] = sum / n;

                let sumSq = 0;
                for (let i = 0; i < n; i++) {
                    const diff = X[i][j] - means[j];
                    sumSq += diff * diff;
                }
                stds[j] = Math.sqrt(sumSq / n);
                if (stds[j] < 1e-10) stds[j] = 1;
            }

            const XNorm = X.map(row => row.map((val, j) => (val - means[j]) / stds[j]));
            const yMean = y.reduce((a, b) => a + b, 0) / n;
            const yCentered = y.map(val => val - yMean);

            // Calculate asymmetric sample weights based on actual returns
            // This emphasizes learning from both positive returns (to catch them) and negative returns (to avoid them)
            let sampleWeights = null;
            if (useAsymmetricLoss) {
                sampleWeights = calculateAsymmetricWeights(y);
            }

            // Initialize with mean prediction
            let predictions = new Array(n).fill(0);
            const trees = [];

            for (let estimator = 0; estimator < nEstimators; estimator++) {
                // Calculate residuals
                const residuals = [];
                for (let i = 0; i < n; i++) {
                    residuals.push(yCentered[i] - predictions[i]);
                }
                
                // Apply asymmetric weighting if enabled
                // Weight the residuals: higher weight = model focuses more on that sample
                const weightedResiduals = useAsymmetricLoss && sampleWeights
                    ? residuals.map((res, i) => res * sampleWeights[i])
                    : residuals;

                // Build a simple decision tree (depth-limited) using weighted residuals
                const tree = buildDecisionTree(XNorm, weightedResiduals, maxDepth);

                // Update predictions
                const treePredictions = XNorm.map(row => predictTree(tree, row));
                for (let i = 0; i < n; i++) {
                    predictions[i] += learningRate * treePredictions[i];
                }

                trees.push(tree);
            }

            return {
                trees,
                means,
                stds,
                yMean,
                learningRate,
                nEstimators,
                predict: function(X_test) {
                    const XNorm_test = X_test.map(row => row.map((val, j) => (val - this.means[j]) / this.stds[j]));
                    let predictions = new Array(X_test.length).fill(0);

                    for (const tree of this.trees) {
                        const treePreds = XNorm_test.map(row => predictTree(tree, row));
                        for (let i = 0; i < predictions.length; i++) {
                            predictions[i] += this.learningRate * treePreds[i];
                        }
                    }

                    return predictions.map(pred => pred + this.yMean);
                }
            };
        }

        // Build a simple decision tree
        function buildDecisionTree(X, y, maxDepth, depth = 0) {
            const n = X.length;
            const m = X[0].length;

            // Calculate best split
            let bestSplit = null;
            let bestScore = Infinity;

            for (let feature = 0; feature < m; feature++) {
                const values = X.map(row => row[feature]).sort((a, b) => a - b);
                const uniqueValues = [...new Set(values)];

                for (let i = 0; i < uniqueValues.length - 1; i++) {
                    const threshold = (uniqueValues[i] + uniqueValues[i + 1]) / 2;

                    const leftIndices = [];
                    const rightIndices = [];

                    for (let j = 0; j < n; j++) {
                        if (X[j][feature] <= threshold) {
                            leftIndices.push(j);
                        } else {
                            rightIndices.push(j);
                        }
                    }

                    if (leftIndices.length === 0 || rightIndices.length === 0) continue;

                    // Calculate MSE for this split
                    const leftMean = leftIndices.reduce((sum, idx) => sum + y[idx], 0) / leftIndices.length;
                    const rightMean = rightIndices.reduce((sum, idx) => sum + y[idx], 0) / rightIndices.length;

                    let mse = 0;
                    for (const idx of leftIndices) {
                        mse += Math.pow(y[idx] - leftMean, 2);
                    }
                    for (const idx of rightIndices) {
                        mse += Math.pow(y[idx] - rightMean, 2);
                    }
                    mse /= n;

                    if (mse < bestScore) {
                        bestScore = mse;
                        bestSplit = {
                            feature,
                            threshold,
                            leftValue: leftMean,
                            rightValue: rightMean
                        };
                    }
                }
            }

            if (!bestSplit || depth >= maxDepth) {
                // Leaf node - return average of remaining values
                const avg = y.reduce((a, b) => a + b, 0) / n;
                return { value: avg };
            }

            // Internal node
            return bestSplit;
        }

        // Predict using a decision tree
        function predictTree(tree, row) {
            if (tree.value !== undefined) {
                return tree.value;
            }

            if (row[tree.feature] <= tree.threshold) {
                return tree.leftValue;
            } else {
                return tree.rightValue;
            }
        }

        // Calculate feature importance for gradient boosting model
        // Using faster variance-based method instead of expensive permutation importance
        // useCategoryBalancing: if true, forces equal category weights (1/numCategories each)
        //                      if false, lets model decide weights naturally (Option 3 - data-driven)
        function calculateFeatureImportance(model, X, y, indicatorCategories = null, useCategoryBalancing = false) {
            const n = X.length;
            const m = X[0].length;
            const importance = new Array(m).fill(0);

            // Fast method: Use variance of predictions when each feature is varied
            // This is much faster than permutation importance (O(n*m) vs O(n*m*model_predictions))
            const predictions = model.predict ? model.predict(X) : new Array(n).fill(0);
            
            // Pre-calculate all feature variances and target variance for efficiency
            const featureVars = [];
            const featureMeans = [];
            const featureTargetSums = [];
            let targetSum = 0;
            
            for (let feature = 0; feature < m; feature++) {
                let featureSum = 0;
                let featureSqSum = 0;
                let featureTargetSum = 0;
                
                for (let i = 0; i < n; i++) {
                    const featVal = X[i][feature];
                    const targetVal = y[i];
                    featureSum += featVal;
                    featureSqSum += featVal * featVal;
                    targetSum += targetVal;
                    featureTargetSum += featVal * targetVal;
                }
                
                const featureMean = featureSum / n;
                const featureVar = (featureSqSum / n) - (featureMean * featureMean);
                featureMeans.push(featureMean);
                featureVars.push(featureVar);
                featureTargetSums.push(featureTargetSum);
            }
            
            const targetMean = targetSum / n;
            const targetVar = y.reduce((sum, val) => {
                const diff = val - targetMean;
                return sum + diff * diff;
            }, 0) / n;
            
            // Find max variance for normalization
            const maxVariance = Math.max(...featureVars.filter(v => v > 1e-10));
            
            // Solution 5: Calculate importance within categories if provided AND category balancing is enabled
            // If useCategoryBalancing is false, use standard calculation even if categories are provided (Option 3)
            if (useCategoryBalancing && indicatorCategories && Object.keys(indicatorCategories).length > 0) {
                // Group features by category
                const categoryFeatures = {};
                for (let feature = 0; feature < m; feature++) {
                    const category = indicatorCategories[feature];
                    if (!categoryFeatures[category]) {
                        categoryFeatures[category] = [];
                    }
                    categoryFeatures[category].push(feature);
                }
                
                // Calculate importance within each category
                const categoryImportances = {};
                for (const category in categoryFeatures) {
                    const features = categoryFeatures[category];
                    const categoryImportance = [];
                    
                    for (const feature of features) {
                        const featureVar = featureVars[feature];
                        if (featureVar > 1e-10) {
                            const covariance = (featureTargetSums[feature] / n) - (featureMeans[feature] * targetMean);
                            const correlation = targetVar > 1e-10 ? Math.abs(covariance / Math.sqrt(featureVar * targetVar)) : 0;
                            const normalizedVariance = maxVariance > 1e-10 ? Math.min(1.0, featureVar / maxVariance) : 0;
                            // Solution 2: Balance correlation and variance (0.6 correlation + 0.4 normalized variance)
                            categoryImportance.push((0.6 * correlation) + (0.4 * normalizedVariance));
                        } else {
                            categoryImportance.push(0);
                        }
                    }
                    
                    // Normalize within category
                    const categorySum = categoryImportance.reduce((a, b) => a + b, 0);
                    if (categorySum > 1e-10) {
                        categoryImportances[category] = categoryImportance.map(v => v / categorySum);
                    } else {
                        categoryImportances[category] = categoryImportance.map(() => 1 / features.length); // Equal weights
                    }
                }
                
                // Assign category-normalized importance to features
                // Each category gets equal total weight (1/numCategories), distributed among its features
                const numCategories = Object.keys(categoryFeatures).length;
                const categoryWeight = 1.0 / numCategories;
                
                for (const category in categoryFeatures) {
                    const features = categoryFeatures[category];
                    for (let i = 0; i < features.length; i++) {
                        // Distribute category weight proportionally among features in category
                        importance[features[i]] = categoryWeight * categoryImportances[category][i];
                    }
                }
            } else {
                // Solution 2: Standard importance calculation (balance correlation and variance)
                for (let feature = 0; feature < m; feature++) {
                    const featureVar = featureVars[feature];
                    if (featureVar > 1e-10) {
                        const covariance = (featureTargetSums[feature] / n) - (featureMeans[feature] * targetMean);
                        if (targetVar > 1e-10) {
                            const correlation = Math.abs(covariance / Math.sqrt(featureVar * targetVar));
                            const normalizedVariance = maxVariance > 1e-10 ? Math.min(1.0, featureVar / maxVariance) : 0;
                            // Solution 2: Balance correlation and variance (0.6 correlation + 0.4 normalized variance)
                            importance[feature] = (0.6 * correlation) + (0.4 * normalizedVariance);
                        } else {
                            const normalizedVariance = maxVariance > 1e-10 ? Math.min(1.0, featureVar / maxVariance) : 0;
                            importance[feature] = normalizedVariance;
                        }
                    } else {
                        importance[feature] = 0;
                    }
                }
            }

            // Normalize to sum to 1
            const sum = importance.reduce((a, b) => a + b, 0);
            return sum > 0 ? importance.map(val => val / sum) : importance.map(() => 1 / m);
        }

        // Apply category balancing to Ridge Regression weights (or any raw weights)
        function applyCategoryBalancing(rawWeights, indicatorCategories, indicatorKeys) {
            if (!indicatorCategories || !indicatorKeys) return rawWeights;
            
            // Group features by category
            const categoryFeatures = {};
            indicatorKeys.forEach((key, index) => {
                const category = indicatorCategories[index];
                if (!categoryFeatures[category]) {
                    categoryFeatures[category] = [];
                }
                categoryFeatures[category].push(index);
            });
            
            // Calculate category-normalized weights
            const categoryWeights = {};
            const categoryImportances = {};
            
            for (const category in categoryFeatures) {
                const features = categoryFeatures[category];
                const categoryImportance = [];
                
                for (const feature of features) {
                    categoryImportance.push(rawWeights[feature] || 0);
                }
                
                // Normalize within category
                const categorySum = categoryImportance.reduce((a, b) => a + b, 0);
                if (categorySum > 1e-10) {
                    categoryImportances[category] = categoryImportance.map(v => v / categorySum);
                } else {
                    categoryImportances[category] = categoryImportance.map(() => 1 / features.length); // Equal weights
                }
            }
            
            // Assign category-normalized weights to features
            // Each category gets equal total weight (1/numCategories), distributed among its features
            const numCategories = Object.keys(categoryFeatures).length;
            const categoryWeight = 1.0 / numCategories;
            const balancedWeights = new Array(rawWeights.length).fill(0);
            
            for (const category in categoryFeatures) {
                const features = categoryFeatures[category];
                for (let i = 0; i < features.length; i++) {
                    // Distribute category weight proportionally among features in category
                    balancedWeights[features[i]] = categoryWeight * categoryImportances[category][i];
                }
            }
            
            return balancedWeights;
        }

        // Calculate R² score for model evaluation
        function calculateModelScore(model, X, y) {
            const predictions = model.predict ? model.predict(X) : X.map(() => 0);
            const n = y.length;
            const yMean = y.reduce((a, b) => a + b, 0) / n;

            let ssRes = 0;
            let ssTot = 0;

            for (let i = 0; i < n; i++) {
                ssRes += Math.pow(y[i] - predictions[i], 2);
                ssTot += Math.pow(y[i] - yMean, 2);
            }

            return ssTot > 0 ? 1 - (ssRes / ssTot) : 0;
        }

        // Ridge Regression solver using normal equations with L2 regularization
        function ridgeRegression(X, y, lambda = 0.1, useAsymmetricLoss = true) {
            const n = X.length;
            if (n === 0) return null;
            const m = X[0].length;
            
            // Remove rows with any null/undefined values
            const validRows = [];
            for (let i = 0; i < n; i++) {
                let isValid = true;
                for (let j = 0; j < m; j++) {
                    if (X[i][j] === null || X[i][j] === undefined || isNaN(X[i][j])) {
                        isValid = false;
                        break;
                    }
                }
                if (isValid && y[i] !== null && y[i] !== undefined && !isNaN(y[i])) {
                    validRows.push(i);
                }
            }
            
            if (validRows.length < m + 1) return null; // Need at least m+1 samples
            
            // Normalize features (zero mean, unit variance)
            const means = new Array(m).fill(0);
            const stds = new Array(m).fill(0);
            
            for (let j = 0; j < m; j++) {
                let sum = 0;
                for (let i = 0; i < validRows.length; i++) {
                    sum += X[validRows[i]][j];
                }
                means[j] = sum / validRows.length;
                
                let sumSq = 0;
                for (let i = 0; i < validRows.length; i++) {
                    const diff = X[validRows[i]][j] - means[j];
                    sumSq += diff * diff;
                }
                stds[j] = Math.sqrt(sumSq / validRows.length);
                if (stds[j] < 1e-10) stds[j] = 1; // Avoid division by zero
            }
            
            // Normalize X and y
            const XNorm = validRows.map(i => {
                const row = new Array(m);
                for (let j = 0; j < m; j++) {
                    row[j] = (X[i][j] - means[j]) / stds[j];
                }
                return row;
            });
            
            const yMean = validRows.reduce((sum, i) => sum + y[i], 0) / validRows.length;
            const yNorm = validRows.map(i => y[i] - yMean);
            
            // Calculate asymmetric sample weights if enabled
            let sampleWeights = null;
            if (useAsymmetricLoss) {
                const yActual = validRows.map(i => y[i]);
                // For initial weights, use actual y values
                sampleWeights = calculateAsymmetricWeights(yActual);
            }
            
            // Compute X^T * W * X + lambda * I (weighted least squares)
            // W is diagonal matrix with sample weights
            const XTX = [];
            for (let i = 0; i < m; i++) {
                XTX[i] = new Array(m).fill(0);
                for (let j = 0; j < m; j++) {
                    for (let k = 0; k < XNorm.length; k++) {
                        const weight = sampleWeights ? sampleWeights[k] : 1.0;
                        XTX[i][j] += XNorm[k][i] * XNorm[k][j] * weight;
                    }
                    if (i === j) XTX[i][j] += lambda;
                }
            }
            
            // Compute X^T * W * y (weighted)
            const XTy = new Array(m).fill(0);
            for (let i = 0; i < m; i++) {
                for (let k = 0; k < XNorm.length; k++) {
                    const weight = sampleWeights ? sampleWeights[k] : 1.0;
                    XTy[i] += XNorm[k][i] * yNorm[k] * weight;
                }
            }
            
            // Solve (X^T * X + lambda * I) * w = X^T * y using Gaussian elimination
            const augmented = XTX.map((row, i) => [...row, XTy[i]]);
            
            // Forward elimination
            for (let i = 0; i < m; i++) {
                let maxRow = i;
                for (let k = i + 1; k < m; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                
                for (let k = i + 1; k < m; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= m; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }
            
            // Back substitution
            const weights = new Array(m);
            for (let i = m - 1; i >= 0; i--) {
                weights[i] = augmented[i][m];
                for (let j = i + 1; j < m; j++) {
                    weights[i] -= augmented[i][j] * weights[j];
                }
                weights[i] /= augmented[i][i];
            }
            
            // Denormalize weights
            for (let j = 0; j < m; j++) {
                weights[j] /= stds[j];
            }
            
            return {
                weights: weights,
                intercept: yMean - weights.reduce((sum, w, j) => sum + w * means[j], 0),
                means: means,
                stds: stds
            };
        }

        // Elastic Net Regression solver using coordinate descent
        // Combines L1 (Lasso) and L2 (Ridge) regularization
        function elasticNetRegression(X, y, lambda = 0.1, alpha = 0.5, maxIter = 1000, tol = 1e-4, useAsymmetricLoss = true) {
            const n = X.length;
            if (n === 0) return null;
            const m = X[0].length;
            
            // Remove rows with any null/undefined values
            const validRows = [];
            for (let i = 0; i < n; i++) {
                let isValid = true;
                for (let j = 0; j < m; j++) {
                    if (X[i][j] === null || X[i][j] === undefined || isNaN(X[i][j])) {
                        isValid = false;
                        break;
                    }
                }
                if (isValid && y[i] !== null && y[i] !== undefined && !isNaN(y[i])) {
                    validRows.push(i);
                }
            }
            
            if (validRows.length < m + 1) return null; // Need at least m+1 samples
            
            // Normalize features (zero mean, unit variance)
            const means = new Array(m).fill(0);
            const stds = new Array(m).fill(0);
            
            for (let j = 0; j < m; j++) {
                let sum = 0;
                for (let i = 0; i < validRows.length; i++) {
                    sum += X[validRows[i]][j];
                }
                means[j] = sum / validRows.length;
                
                let sumSq = 0;
                for (let i = 0; i < validRows.length; i++) {
                    const diff = X[validRows[i]][j] - means[j];
                    sumSq += diff * diff;
                }
                stds[j] = Math.sqrt(sumSq / validRows.length);
                if (stds[j] < 1e-10) stds[j] = 1; // Avoid division by zero
            }
            
            // Normalize X and y
            const XNorm = validRows.map(i => {
                const row = new Array(m);
                for (let j = 0; j < m; j++) {
                    row[j] = (X[i][j] - means[j]) / stds[j];
                }
                return row;
            });
            
            const yMean = validRows.reduce((sum, i) => sum + y[i], 0) / validRows.length;
            const yNorm = validRows.map(i => y[i] - yMean);
            
            // Calculate asymmetric sample weights if enabled
            let sampleWeights = null;
            if (useAsymmetricLoss) {
                const yActual = validRows.map(i => y[i]);
                // For initial weights, use actual y values (will be refined iteratively)
                sampleWeights = calculateAsymmetricWeights(yActual);
            }
            
            // Initialize weights to zero
            let weights = new Array(m).fill(0);
            let intercept = 0;
            
            // Precompute X^T * W * X and X^T * W * y for weighted least squares
            // W is diagonal matrix with sample weights
            const XTX = [];
            const XTy = new Array(m).fill(0);
            
            for (let i = 0; i < m; i++) {
                XTX[i] = new Array(m).fill(0);
                for (let j = 0; j < m; j++) {
                    for (let k = 0; k < XNorm.length; k++) {
                        const weight = sampleWeights ? sampleWeights[k] : 1.0;
                        XTX[i][j] += XNorm[k][i] * XNorm[k][j] * weight;
                    }
                }
                for (let k = 0; k < XNorm.length; k++) {
                    const weight = sampleWeights ? sampleWeights[k] : 1.0;
                    XTy[i] += XNorm[k][i] * yNorm[k] * weight;
                }
            }
            
            // Coordinate descent algorithm
            for (let iter = 0; iter < maxIter; iter++) {
                let maxChange = 0;
                const oldWeights = [...weights];
                
                // Update intercept
                let residualSum = 0;
                for (let i = 0; i < XNorm.length; i++) {
                    let pred = intercept;
                    for (let j = 0; j < m; j++) {
                        pred += XNorm[i][j] * weights[j];
                    }
                    residualSum += yNorm[i] - pred;
                }
                intercept = residualSum / XNorm.length;
                
                // Update each weight coordinate
                for (let j = 0; j < m; j++) {
                    // Compute residual without feature j
                    let residual = XTy[j];
                    for (let k = 0; k < m; k++) {
                        if (k !== j) {
                            residual -= XTX[j][k] * weights[k];
                        }
                    }
                    
                    // Soft thresholding for Elastic Net
                    // lambda1 = alpha * lambda (L1 penalty)
                    // lambda2 = (1 - alpha) * lambda (L2 penalty)
                    const lambda1 = alpha * lambda;
                    const lambda2 = (1 - alpha) * lambda;
                    
                    // Update weight with soft thresholding
                    const denominator = XTX[j][j] + lambda2;
                    if (denominator < 1e-10) {
                        weights[j] = 0;
                    } else {
                        const z = residual / denominator;
                        if (z > lambda1 / denominator) {
                            weights[j] = (z - lambda1 / denominator);
                        } else if (z < -lambda1 / denominator) {
                            weights[j] = (z + lambda1 / denominator);
                        } else {
                            weights[j] = 0;
                        }
                    }
                    
                    maxChange = Math.max(maxChange, Math.abs(weights[j] - oldWeights[j]));
                }
                
                // Check convergence
                if (maxChange < tol) {
                    break;
                }
            }
            
            // Denormalize weights
            for (let j = 0; j < m; j++) {
                weights[j] /= stds[j];
            }
            
            return {
                weights: weights,
                intercept: yMean - weights.reduce((sum, w, j) => sum + w * means[j], 0),
                means: means,
                stds: stds
            };
        }

        // ============================================================================
        // PHILOSOPHY FRAMEWORK: Trend Hierarchy & Alignment
        // ============================================================================
        
        /**
         * Establishes the main trend based on Monthly MACD
         * This is the "anchor" - don't position against this
         */
        function getMainTrend(monthlyMACD) {
            if (!monthlyMACD || monthlyMACD.histogram === null || monthlyMACD.slope === null) {
                return 'NEUTRAL';
            }
            
            const histVal = monthlyMACD.histogram;
            const slopeVal = monthlyMACD.slope;
            const histNearZeroThreshold = 0.05;
            const slopeThreshold = 0.01;
            
            if (histVal > histNearZeroThreshold) {
                // Positive histogram = bullish trend
                return 'BULLISH';
            } else if (histVal < -histNearZeroThreshold) {
                // Negative histogram = bearish trend
                return 'BEARISH';
            } else if (Math.abs(slopeVal) > slopeThreshold) {
                // Near zero but slope indicates direction
                return slopeVal > 0 ? 'BULLISH' : 'BEARISH';
            }
            
            return 'NEUTRAL';
        }
        
        /**
         * Assesses trend health based on multiple indicators
         */
        function assessTrendHealth(monthlyMACD, dailyMACD, adxData, priceVs200DMA) {
            const mainTrend = getMainTrend(monthlyMACD);
            
            // Extract values
            const adx = adxData?.adx || null;
            const pdi = adxData?.pdi || null;
            const mdi = adxData?.mdi || null;
            const dailyHist = dailyMACD?.histogram || null;
            const dailySlope = dailyMACD?.slope || null;
            const monthlyHist = monthlyMACD?.histogram || null;
            const monthlySlope = monthlyMACD?.slope || null;
            
            // Determine trend strength
            let strength = 'DRIFTING';
            if (adx !== null) {
                if (adx > 50) strength = 'STRONG';
                else if (adx > 25) strength = 'MODERATE';
                else if (adx > 20) strength = 'WEAK';
            }
            
            // Check if trend is healthy
            let isHealthy = true;
            let isVulnerable = false;
            
            // Trend is vulnerable when:
            // 1. ADX is declining (trend losing strength)
            // 2. Daily MACD momentum is slowing (slope opposite to histogram)
            // 3. Monthly MACD momentum is slowing
            // 4. Price is at extremes relative to 200-DMA
            
            if (dailyHist !== null && dailySlope !== null) {
                // Momentum slowing: histogram positive but slope negative (or vice versa)
                if ((dailyHist > 0 && dailySlope < -0.005) || (dailyHist < 0 && dailySlope > 0.005)) {
                    isVulnerable = true;
                }
            }
            
            if (monthlyHist !== null && monthlySlope !== null) {
                // Monthly momentum slowing
                if ((monthlyHist > 0 && monthlySlope < -0.01) || (monthlyHist < 0 && monthlySlope > 0.01)) {
                    isVulnerable = true;
                }
            }
            
            // Price at extreme relative to 200-DMA
            if (priceVs200DMA !== null) {
                if (Math.abs(priceVs200DMA) > 20) {
                    isVulnerable = true; // More than 20% above/below 200-DMA is extreme
                }
            }
            
            // Trend is unhealthy if vulnerable AND strength is weak
            if (isVulnerable && (strength === 'WEAK' || strength === 'DRIFTING')) {
                isHealthy = false;
            }
            
            return {
                strength: strength,
                direction: mainTrend,
                isHealthy: isHealthy,
                isVulnerable: isVulnerable
            };
        }
        
        /**
         * Applies trend alignment adjustments to raw scores
         * Boosts scores that align with main trend, penalizes conflicting signals
         */
        function applyTrendAlignment(rawScores, mainTrend, indicatorName) {
            if (mainTrend === 'NEUTRAL') return rawScores; // No adjustment if no clear trend
            
            const alignmentMultiplier = 1.2; // Boost aligned signals by 20%
            const conflictPenalty = 0.5; // Reduce conflicting signals by 50%
            
            // Determine if this indicator aligns with main trend
            let alignsWithTrend = false;
            
            if (mainTrend === 'BULLISH') {
                // Bullish indicators: positive scores align with bullish trend
                // This includes: positive MACD, positive ADX with +DI > -DI, price above 200-DMA, oversold RSI (mean reversion opportunity)
                // RSI oversold (positive score) in uptrend = buying opportunity, so it aligns
                alignsWithTrend = rawScores > 0;
            } else if (mainTrend === 'BEARISH') {
                // Bearish indicators: negative scores align with bearish trend
                // This includes: negative MACD, negative ADX with -DI > +DI, price below 200-DMA, overbought RSI (mean reversion opportunity)
                // RSI overbought (negative score) in downtrend = selling opportunity, so it aligns
                alignsWithTrend = rawScores < 0;
            }
            
            if (alignsWithTrend) {
                return rawScores * alignmentMultiplier;
            } else {
                // Conflicting signal - reduce but don't eliminate
                return rawScores * conflictPenalty;
            }
        }
        
        // ============================================================================
        // PHILOSOPHY FRAMEWORK: Extreme + Momentum Analysis
        // ============================================================================
        
        /**
         * Detects extreme market conditions
         */
        function detectExtremes(rsi, bollingerBands, zScore, priceVs200DMA) {
            const extremes = {
                isExtreme: false,
                extremeType: 'NEUTRAL',
                extremeSeverity: 0,
                extremeIndicators: []
            };
            
            let extremeCount = 0;
            let totalSeverity = 0;
            
            // RSI extremes
            if (rsi !== null) {
                if (rsi > 70) {
                    extremes.extremeIndicators.push('RSI');
                    extremeCount++;
                    const severity = Math.min(1.0, (rsi - 70) / 30); // 70-100 maps to 0-1
                    totalSeverity += severity;
                    if (rsi > extremes.extremeSeverity * 30 + 70) {
                        extremes.extremeType = 'OVERBOUGHT';
                        extremes.extremeSeverity = severity;
                    }
                } else if (rsi < 30) {
                    extremes.extremeIndicators.push('RSI');
                    extremeCount++;
                    const severity = Math.min(1.0, (30 - rsi) / 30); // 0-30 maps to 1-0
                    totalSeverity += severity;
                    if (severity > extremes.extremeSeverity) {
                        extremes.extremeType = 'OVERSOLD';
                        extremes.extremeSeverity = severity;
                    }
                }
            }
            
            // Bollinger Bands extremes
            if (bollingerBands !== null && bollingerBands.pctB !== null) {
                if (bollingerBands.pctB > 0.95) {
                    extremes.extremeIndicators.push('BB');
                    extremeCount++;
                    const severity = Math.min(1.0, (bollingerBands.pctB - 0.95) / 0.05);
                    totalSeverity += severity;
                    if (severity > extremes.extremeSeverity) {
                        extremes.extremeType = 'OVERBOUGHT';
                        extremes.extremeSeverity = severity;
                    }
                } else if (bollingerBands.pctB < 0.05) {
                    extremes.extremeIndicators.push('BB');
                    extremeCount++;
                    const severity = Math.min(1.0, (0.05 - bollingerBands.pctB) / 0.05);
                    totalSeverity += severity;
                    if (severity > extremes.extremeSeverity) {
                        extremes.extremeType = 'OVERSOLD';
                        extremes.extremeSeverity = severity;
                    }
                }
            }
            
            // Z-Score extremes
            if (zScore !== null) {
                if (Math.abs(zScore) > 1.25) {
                    extremes.extremeIndicators.push('Z-Score');
                    extremeCount++;
                    const severity = Math.min(1.0, (Math.abs(zScore) - 1.25) / 1.75); // 1.25-3.0 maps to 0-1
                    totalSeverity += severity;
                    if (severity > extremes.extremeSeverity) {
                        extremes.extremeType = zScore > 0 ? 'OVERBOUGHT' : 'OVERSOLD';
                        extremes.extremeSeverity = severity;
                    }
                }
            }
            
            // Price vs 200-DMA extremes
            if (priceVs200DMA !== null) {
                if (Math.abs(priceVs200DMA) > 15) {
                    extremes.extremeIndicators.push('200-DMA');
                    extremeCount++;
                    const severity = Math.min(1.0, (Math.abs(priceVs200DMA) - 15) / 15); // 15-30% maps to 0-1
                    totalSeverity += severity;
                    if (severity > extremes.extremeSeverity) {
                        extremes.extremeType = priceVs200DMA > 0 ? 'OVERBOUGHT' : 'OVERSOLD';
                        extremes.extremeSeverity = severity;
                    }
                }
            }
            
            extremes.isExtreme = extremeCount > 0;
            if (extremeCount > 0) {
                extremes.extremeSeverity = totalSeverity / extremeCount; // Average severity
            }
            
            return extremes;
        }
        
        /**
         * Detects momentum deceleration
         */
        function detectMomentumSlowdown(dailyMACD, monthlyMACD, adxData) {
            const slowdown = {
                isSlowing: false,
                slowdownType: 'STABLE',
                slowdownSeverity: 0
            };
            
            // Check daily MACD momentum
            if (dailyMACD && dailyMACD.histogram !== null && dailyMACD.slope !== null) {
                const hist = dailyMACD.histogram;
                const slope = dailyMACD.slope;
                const slopeThreshold = 0.005;
                
                // Momentum slowing: histogram and slope have opposite signs
                if ((hist > 0 && slope < -slopeThreshold) || (hist < 0 && slope > slopeThreshold)) {
                    slowdown.isSlowing = true;
                    slowdown.slowdownType = 'DECELERATING';
                    slowdown.slowdownSeverity = Math.min(1.0, Math.abs(slope) / 0.01); // Normalize to 0-1
                } else if (Math.abs(slope) > slopeThreshold) {
                    slowdown.slowdownType = 'ACCELERATING';
                }
            }
            
            // Check monthly MACD momentum
            if (monthlyMACD && monthlyMACD.histogram !== null && monthlyMACD.slope !== null) {
                const hist = monthlyMACD.histogram;
                const slope = monthlyMACD.slope;
                const slopeThreshold = 0.01;
                
                if ((hist > 0 && slope < -slopeThreshold) || (hist < 0 && slope > slopeThreshold)) {
                    slowdown.isSlowing = true;
                    slowdown.slowdownType = 'DECELERATING';
                    // Monthly slowdown is more significant
                    slowdown.slowdownSeverity = Math.max(slowdown.slowdownSeverity, Math.min(1.0, Math.abs(slope) / 0.02));
                }
            }
            
            // Check ADX trend strength
            if (adxData && adxData.adx !== null) {
                // If ADX is declining, trend is losing strength
                // Note: We'd need historical ADX to detect decline, but for now we check if ADX is low
                if (adxData.adx < 20) {
                    slowdown.isSlowing = true;
                    if (slowdown.slowdownType === 'STABLE') {
                        slowdown.slowdownType = 'WEAK_TREND';
                    }
                }
            }
            
            return slowdown;
        }
        
        /**
         * Calculates vulnerability score when extremes + momentum slowdown occur
         */
        function calculateVulnerabilityScore(extremes, momentum, trendHealth) {
            let vulnerabilityScore = 0;
            
            // Base vulnerability from extremes
            if (extremes.isExtreme) {
                vulnerabilityScore += extremes.extremeSeverity * 0.4;
            }
            
            // Add momentum slowdown component
            if (momentum.isSlowing) {
                vulnerabilityScore += momentum.slowdownSeverity * 0.4;
            }
            
            // Add trend weakness component
            if (trendHealth.isVulnerable) {
                vulnerabilityScore += 0.2;
            }
            
            // High vulnerability when all three conditions exist
            if (extremes.isExtreme && momentum.isSlowing && trendHealth.isVulnerable) {
                vulnerabilityScore = Math.min(1.0, vulnerabilityScore * 1.5); // Boost when all align
            }
            
            return Math.min(1.0, vulnerabilityScore);
        }
        
        // ============================================================================
        // PHILOSOPHY FRAMEWORK: Support/Resistance Analysis
        // ============================================================================
        
        /**
         * Identifies swing highs and swing lows (pivot points) for support/resistance
         * A swing high is a local peak where price is higher than N bars on both sides
         * A swing low is a local trough where price is lower than N bars on both sides
         */
        function identifySwingHighsLows(highs, lows, closes, dates, lookback = 252, pivotBars = 5) {
            if (highs.length < pivotBars * 2 + 1) return { swingHighs: [], swingLows: [] };
            
            const len = closes.length;
            const startIndex = Math.max(0, len - lookback);
            
            const swingHighs = [];
            const swingLows = [];
            
            // Identify swing highs (pivot highs)
            for (let i = startIndex + pivotBars; i < len - pivotBars; i++) {
                const currentHigh = highs[i];
                if (currentHigh === null || currentHigh === undefined) continue;
                
                // Check if this is a swing high: must be higher than pivotBars bars on both sides
                let isSwingHigh = true;
                for (let j = i - pivotBars; j <= i + pivotBars; j++) {
                    if (j !== i && highs[j] !== null && highs[j] !== undefined && highs[j] >= currentHigh) {
                        isSwingHigh = false;
                        break;
                    }
                }
                
                if (isSwingHigh) {
                    swingHighs.push({
                        price: currentHigh,
                        close: closes[i],
                        date: dates[i],
                        index: i
                    });
                }
            }
            
            // Identify swing lows (pivot lows)
            for (let i = startIndex + pivotBars; i < len - pivotBars; i++) {
                const currentLow = lows[i];
                if (currentLow === null || currentLow === undefined) continue;
                
                // Check if this is a swing low: must be lower than pivotBars bars on both sides
                let isSwingLow = true;
                for (let j = i - pivotBars; j <= i + pivotBars; j++) {
                    if (j !== i && lows[j] !== null && lows[j] !== undefined && lows[j] <= currentLow) {
                        isSwingLow = false;
                        break;
                    }
                }
                
                if (isSwingLow) {
                    swingLows.push({
                        price: currentLow,
                        close: closes[i],
                        date: dates[i],
                        index: i
                    });
                }
            }
            
            return {
                swingHighs: swingHighs,
                swingLows: swingLows
            };
        }
        
        /**
         * Analyzes support and resistance levels
         */
        function analyzeSupportResistance(currentPrice, sma50, sma100, sma200, fibLevels, priorHighs, priorLows) {
            const levels = {
                nearestSupport: null,
                nearestResistance: null,
                isAtSupport: false,
                isAtResistance: false,
                supportStrength: 0,
                resistanceStrength: 0
            };
            
            const supportLevels = [];
            const resistanceLevels = [];
            const threshold = 0.02; // 2% proximity threshold
            
            // Add moving averages as support/resistance
            if (sma50 !== null) {
                if (currentPrice > sma50) {
                    resistanceLevels.push({ level: sma50, type: 'SMA50', distance: ((currentPrice - sma50) / currentPrice) * 100 });
                } else {
                    supportLevels.push({ level: sma50, type: 'SMA50', distance: ((sma50 - currentPrice) / currentPrice) * 100 });
                }
            }
            
            if (sma100 !== null) {
                if (currentPrice > sma100) {
                    resistanceLevels.push({ level: sma100, type: 'SMA100', distance: ((currentPrice - sma100) / currentPrice) * 100 });
                } else {
                    supportLevels.push({ level: sma100, type: 'SMA100', distance: ((sma100 - currentPrice) / currentPrice) * 100 });
                }
            }
            
            if (sma200 !== null) {
                if (currentPrice > sma200) {
                    resistanceLevels.push({ level: sma200, type: 'SMA200', distance: ((currentPrice - sma200) / currentPrice) * 100 });
                } else {
                    supportLevels.push({ level: sma200, type: 'SMA200', distance: ((sma200 - currentPrice) / currentPrice) * 100 });
                }
            }
            
            // Add Fibonacci levels
            if (fibLevels) {
                ['38.2%', '50.0%', '61.8%'].forEach(level => {
                    const fibPrice = fibLevels[level];
                    if (fibPrice !== null && fibPrice !== undefined) {
                        const distance = ((fibPrice - currentPrice) / currentPrice) * 100;
                        if (distance > 0) {
                            supportLevels.push({ level: fibPrice, type: 'FIB', fibLevel: level, distance: distance });
                        } else {
                            resistanceLevels.push({ level: fibPrice, type: 'FIB', fibLevel: level, distance: Math.abs(distance) });
                        }
                    }
                });
            }
            
            // Add prior highs/lows (swing highs/lows - pivot points)
            // priorHighs and priorLows are now arrays of objects with {price, close, date, index}
            if (priorHighs && priorHighs.length > 0) {
                priorHighs.forEach(swingHigh => {
                    const highPrice = swingHigh.price || swingHigh; // Support both object and number format
                    if (highPrice > currentPrice) {
                        resistanceLevels.push({ 
                            level: highPrice, 
                            type: 'PRIOR_HIGH', 
                            distance: ((highPrice - currentPrice) / currentPrice) * 100,
                            date: swingHigh.date || null
                        });
                    }
                });
            }
            
            if (priorLows && priorLows.length > 0) {
                priorLows.forEach(swingLow => {
                    const lowPrice = swingLow.price || swingLow; // Support both object and number format
                    if (lowPrice < currentPrice) {
                        supportLevels.push({ 
                            level: lowPrice, 
                            type: 'PRIOR_LOW', 
                            distance: ((currentPrice - lowPrice) / currentPrice) * 100,
                            date: swingLow.date || null
                        });
                    }
                });
            }
            
            // Find nearest support
            if (supportLevels.length > 0) {
                supportLevels.sort((a, b) => a.distance - b.distance);
                levels.nearestSupport = supportLevels[0];
                levels.isAtSupport = levels.nearestSupport.distance <= threshold * 100;
                
                // Support strength: multiple levels nearby = stronger
                const nearbySupports = supportLevels.filter(s => s.distance <= 5); // Within 5%
                levels.supportStrength = Math.min(1.0, nearbySupports.length / 3); // 3+ levels = max strength
            }
            
            // Find nearest resistance
            if (resistanceLevels.length > 0) {
                resistanceLevels.sort((a, b) => a.distance - b.distance);
                levels.nearestResistance = resistanceLevels[0];
                levels.isAtResistance = levels.nearestResistance.distance <= threshold * 100;
                
                // Resistance strength: multiple levels nearby = stronger
                const nearbyResistances = resistanceLevels.filter(r => r.distance <= 5); // Within 5%
                levels.resistanceStrength = Math.min(1.0, nearbyResistances.length / 3);
            }
            
            return levels;
        }
        
        /**
         * Detects if price has bounced off support and is turning back toward trend
         */
        function detectSupportBounce(priceHistory, supportLevel, mainTrend, currentPrice) {
            if (!supportLevel || priceHistory.length < 10) {
                return { bounced: false, bounceStrength: 0, trendReestablished: false };
            }
            
            const bounce = {
                bounced: false,
                bounceStrength: 0,
                trendReestablished: false
            };
            
            // Check last 10 days for support test and bounce
            const lookback = Math.min(10, priceHistory.length);
            const recentPrices = priceHistory.slice(-lookback);
            const supportPrice = supportLevel.level;
            const threshold = 0.02; // 2% proximity
            
            // Find if price tested support (got within 2% of support level)
            let testedSupport = false;
            let testIndex = -1;
            for (let i = recentPrices.length - 1; i >= 0; i--) {
                const distance = Math.abs((recentPrices[i] - supportPrice) / supportPrice);
                if (distance <= threshold) {
                    testedSupport = true;
                    testIndex = i;
                    break;
                }
            }
            
            if (testedSupport && testIndex < recentPrices.length - 1) {
                // Check if price bounced (turned up after testing support)
                const testPrice = recentPrices[testIndex];
                const latestPrice = currentPrice || recentPrices[recentPrices.length - 1];
                
                if (mainTrend === 'BULLISH' && latestPrice > testPrice) {
                    bounce.bounced = true;
                    bounce.bounceStrength = Math.min(1.0, (latestPrice - testPrice) / (supportPrice * 0.05)); // Normalize to 0-1
                    
                    // Check if turning back toward trend (price above support and rising)
                    if (latestPrice > supportPrice) {
                        // Check if recent momentum is positive
                        const recentChange = (latestPrice - recentPrices[Math.max(0, testIndex - 2)]) / recentPrices[Math.max(0, testIndex - 2)];
                        if (recentChange > 0) {
                            bounce.trendReestablished = true;
                        }
                    }
                } else if (mainTrend === 'BEARISH' && latestPrice < testPrice) {
                    // For bearish trend, bounce means price fell to resistance and turned down
                    bounce.bounced = true;
                    bounce.bounceStrength = Math.min(1.0, (testPrice - latestPrice) / (supportPrice * 0.05));
                    
                    if (latestPrice < supportPrice) {
                        const recentChange = (latestPrice - recentPrices[Math.max(0, testIndex - 2)]) / recentPrices[Math.max(0, testIndex - 2)];
                        if (recentChange < 0) {
                            bounce.trendReestablished = true;
                        }
                    }
                }
            }
            
            return bounce;
        }
        
        // ============================================================================
        // PHILOSOPHY FRAMEWORK: Pullback vs Reversal Classification
        // ============================================================================
        
        /**
         * Classifies whether a reversal is a pullback (entry opportunity) or major reversal (dangerous)
         */
        function classifyReversalType(mainTrend, priceAction, supportResistance, momentum, trendHealth) {
            const classification = {
                reversalType: 'TREND_CONTINUATION',
                confidence: 0.5,
                entryOpportunity: false,
                riskLevel: 'MODERATE'
            };
            
            // If no clear trend, default to continuation
            if (mainTrend === 'NEUTRAL') {
                return classification;
            }
            
            // Check if price is at support/resistance
            const isAtKeyLevel = supportResistance.isAtSupport || supportResistance.isAtResistance;
            
            // PULLBACK characteristics (in uptrend):
            // - Main trend is BULLISH
            // - Price pulls back to support (50/100/200 DMA or Fib)
            // - Momentum slows but doesn't reverse (daily MACD still positive or near zero)
            // - Trend health is still good (ADX > 20, monthly MACD still bullish)
            // - Price bounces off support
            
            if (mainTrend === 'BULLISH') {
                if (supportResistance.isAtSupport && supportResistance.nearestSupport) {
                    // Price at support in uptrend
                    if (momentum.slowdownType !== 'REVERSING' && trendHealth.isHealthy) {
                        // Momentum slowing but not reversing, trend still healthy
                        classification.reversalType = 'PULLBACK';
                        classification.entryOpportunity = true;
                        classification.confidence = 0.7;
                        classification.riskLevel = 'LOW';
                        
                        // If support bounce detected, increase confidence
                        if (supportResistance.nearestSupport && supportResistance.nearestSupport.distance < 2) {
                            classification.confidence = 0.85;
                            classification.riskLevel = 'LOW';
                        }
                    } else if (momentum.slowdownType === 'REVERSING' || !trendHealth.isHealthy) {
                        // Momentum reversing or trend unhealthy = potential major reversal
                        classification.reversalType = 'MAJOR_REVERSAL';
                        classification.entryOpportunity = false;
                        classification.confidence = 0.6;
                        classification.riskLevel = 'HIGH';
                    }
                } else if (priceAction && priceAction > 0 && momentum.isSlowing && supportResistance.nearestSupport) {
                    // Price above support but momentum slowing = potential pullback forming
                    classification.reversalType = 'PULLBACK';
                    classification.entryOpportunity = true;
                    classification.confidence = 0.5;
                    classification.riskLevel = 'MODERATE';
                }
            } else if (mainTrend === 'BEARISH') {
                // Similar logic for bearish trend
                if (supportResistance.isAtResistance && supportResistance.nearestResistance) {
                    // Price at resistance in downtrend
                    if (momentum.slowdownType !== 'REVERSING' && trendHealth.isHealthy) {
                        classification.reversalType = 'PULLBACK';
                        classification.entryOpportunity = true;
                        classification.confidence = 0.7;
                        classification.riskLevel = 'LOW';
                    } else if (momentum.slowdownType === 'REVERSING' || !trendHealth.isHealthy) {
                        classification.reversalType = 'MAJOR_REVERSAL';
                        classification.entryOpportunity = false;
                        classification.confidence = 0.6;
                        classification.riskLevel = 'HIGH';
                    }
                }
            }
            
            // If price breaks key support/resistance, it's likely a major reversal
            if (mainTrend === 'BULLISH' && supportResistance.nearestSupport) {
                const priceBelowSupport = priceAction < supportResistance.nearestSupport.level * 0.98; // 2% below support
                if (priceBelowSupport && momentum.slowdownType === 'REVERSING') {
                    classification.reversalType = 'MAJOR_REVERSAL';
                    classification.entryOpportunity = false;
                    classification.confidence = 0.8;
                    classification.riskLevel = 'HIGH';
                }
            } else if (mainTrend === 'BEARISH' && supportResistance.nearestResistance) {
                const priceAboveResistance = priceAction > supportResistance.nearestResistance.level * 1.02; // 2% above resistance
                if (priceAboveResistance && momentum.slowdownType === 'REVERSING') {
                    classification.reversalType = 'MAJOR_REVERSAL';
                    classification.entryOpportunity = false;
                    classification.confidence = 0.8;
                    classification.riskLevel = 'HIGH';
                }
            }
            
            return classification;
        }
        
        // ============================================================================
        // PHILOSOPHY FRAMEWORK: Contextual Scoring & Dynamic Weighting
        // ============================================================================
        
        /**
         * Detects current market regime
         */
        function detectMarketRegime(adxData, priceVolatility, trendHealth) {
            const adx = adxData?.adx || 0;
            
            if (adx > 25 && trendHealth.strength !== 'DRIFTING') {
                return 'STRONG_TREND';
            } else if (adx > 20) {
                return 'WEAK_TREND';
            } else if (adx < 20) {
                return 'RANGING';
            }
            
            return 'TRANSITION';
        }
        
        /**
         * Detects market regime for a specific historical data point
         * Used for regime-switching ensemble training
         */
        function detectRegimeForPoint(i, adxData, monthlyMACDArray, dailyIndicatorArrays) {
            const adx = adxData?.adx?.[i] || 0;
            const monthlyMACD = monthlyMACDArray?.[i];
            
            // Assess trend health for this point
            let strength = 'DRIFTING';
            if (adx > 50) strength = 'STRONG';
            else if (adx > 25) strength = 'MODERATE';
            else if (adx > 20) strength = 'WEAK';
            
            // Simple regime detection based on ADX
            if (adx > 25 && strength !== 'DRIFTING') {
                return 'STRONG_TREND';
            } else if (adx > 20) {
                return 'WEAK_TREND';
            } else if (adx < 20) {
                return 'RANGING';
            }
            
            return 'TRANSITION';
        }
        
        /**
         * Trains regime-switching ensemble: separate models for each regime
         * Returns an object with models for each regime and a fallback model
         */
        function trainRegimeSwitchingEnsemble(X, y, regimes, lookahead, INDICATOR_KEYS, DISPLAY_NAMES) {
            const regimeModels = {
                'STRONG_TREND': null,
                'WEAK_TREND': null,
                'RANGING': null,
                'TRANSITION': null,
                'fallback': null // Ridge regression as fallback
            };
            
            const regimeWeights = {
                'STRONG_TREND': {},
                'WEAK_TREND': {},
                'RANGING': {},
                'TRANSITION': {},
                'fallback': {}
            };
            
            // Separate data by regime
            const regimeData = {
                'STRONG_TREND': { X: [], y: [], indices: [] },
                'WEAK_TREND': { X: [], y: [], indices: [] },
                'RANGING': { X: [], y: [], indices: [] },
                'TRANSITION': { X: [], y: [], indices: [] }
            };
            
            for (let i = 0; i < X.length; i++) {
                const regime = regimes[i] || 'TRANSITION';
                if (regimeData[regime]) {
                    regimeData[regime].X.push(X[i]);
                    regimeData[regime].y.push(y[i]);
                    regimeData[regime].indices.push(i);
                }
            }
            
            console.log('Regime data distribution:', {
                STRONG_TREND: regimeData.STRONG_TREND.X.length,
                WEAK_TREND: regimeData.WEAK_TREND.X.length,
                RANGING: regimeData.RANGING.X.length,
                TRANSITION: regimeData.TRANSITION.X.length
            });
            
            // Train model for each regime (minimum 20 samples required)
            const MIN_SAMPLES_PER_REGIME = 20;
            
            // STRONG_TREND: Use Gradient Boosting (best for trend-following)
            if (regimeData.STRONG_TREND.X.length >= MIN_SAMPLES_PER_REGIME) {
                console.log(`Training STRONG_TREND model (Gradient Boosting) with ${regimeData.STRONG_TREND.X.length} samples`);
                regimeModels.STRONG_TREND = gradientBoostingRegressor(regimeData.STRONG_TREND.X, regimeData.STRONG_TREND.y, 25, 0.1, 3);
                // Extract feature importance as weights
                if (regimeModels.STRONG_TREND && regimeModels.STRONG_TREND.featureImportance) {
                    const sum = regimeModels.STRONG_TREND.featureImportance.reduce((a, b) => a + b, 0);
                    INDICATOR_KEYS.forEach((key, idx) => {
                        regimeWeights.STRONG_TREND[DISPLAY_NAMES[key]] = sum > 0 ? regimeModels.STRONG_TREND.featureImportance[idx] / sum : 0;
                    });
                }
            }
            
            // WEAK_TREND: Use Elastic Net (balanced)
            if (regimeData.WEAK_TREND.X.length >= MIN_SAMPLES_PER_REGIME) {
                console.log(`Training WEAK_TREND model (Elastic Net) with ${regimeData.WEAK_TREND.X.length} samples`);
                regimeModels.WEAK_TREND = elasticNetRegression(regimeData.WEAK_TREND.X, regimeData.WEAK_TREND.y, 0.1, 0.5);
                if (regimeModels.WEAK_TREND && regimeModels.WEAK_TREND.weights) {
                    const sum = Math.abs(regimeModels.WEAK_TREND.weights.reduce((a, b) => a + Math.abs(b), 0));
                    INDICATOR_KEYS.forEach((key, idx) => {
                        regimeWeights.WEAK_TREND[DISPLAY_NAMES[key]] = sum > 0 ? Math.abs(regimeModels.WEAK_TREND.weights[idx]) / sum : 0;
                    });
                }
            }
            
            // RANGING: Use Elastic Net (good for mean-reversion)
            if (regimeData.RANGING.X.length >= MIN_SAMPLES_PER_REGIME) {
                console.log(`Training RANGING model (Elastic Net) with ${regimeData.RANGING.X.length} samples`);
                regimeModels.RANGING = elasticNetRegression(regimeData.RANGING.X, regimeData.RANGING.y, 0.15, 0.6);
                if (regimeModels.RANGING && regimeModels.RANGING.weights) {
                    const sum = Math.abs(regimeModels.RANGING.weights.reduce((a, b) => a + Math.abs(b), 0));
                    INDICATOR_KEYS.forEach((key, idx) => {
                        regimeWeights.RANGING[DISPLAY_NAMES[key]] = sum > 0 ? Math.abs(regimeModels.RANGING.weights[idx]) / sum : 0;
                    });
                }
            }
            
            // TRANSITION: Use Ridge (conservative, fast)
            if (regimeData.TRANSITION.X.length >= MIN_SAMPLES_PER_REGIME) {
                console.log(`Training TRANSITION model (Ridge) with ${regimeData.TRANSITION.X.length} samples`);
                regimeModels.TRANSITION = ridgeRegression(regimeData.TRANSITION.X, regimeData.TRANSITION.y, 0.1);
                if (regimeModels.TRANSITION && regimeModels.TRANSITION.weights) {
                    const sum = Math.abs(regimeModels.TRANSITION.weights.reduce((a, b) => a + Math.abs(b), 0));
                    INDICATOR_KEYS.forEach((key, idx) => {
                        regimeWeights.TRANSITION[DISPLAY_NAMES[key]] = sum > 0 ? Math.abs(regimeModels.TRANSITION.weights[idx]) / sum : 0;
                    });
                }
            }
            
            // Fallback: Ridge regression on all data
            console.log(`Training fallback model (Ridge) with ${X.length} samples`);
            regimeModels.fallback = ridgeRegression(X, y, 0.1);
            if (regimeModels.fallback && regimeModels.fallback.weights) {
                const sum = Math.abs(regimeModels.fallback.weights.reduce((a, b) => a + Math.abs(b), 0));
                INDICATOR_KEYS.forEach((key, idx) => {
                    regimeWeights.fallback[DISPLAY_NAMES[key]] = sum > 0 ? Math.abs(regimeModels.fallback.weights[idx]) / sum : 0;
                });
            }
            
            return {
                models: regimeModels,
                weights: regimeWeights
            };
        }
        
        /**
         * Predicts using regime-switching ensemble
         * Detects current regime and uses appropriate model
         */
        function predictWithRegimeSwitching(x, regimeModels, currentRegime, fallbackModel) {
            // Try to use regime-specific model
            let model = regimeModels[currentRegime];
            let modelType = currentRegime;
            
            // If no model for this regime, use fallback
            if (!model) {
                model = fallbackModel;
                modelType = 'fallback';
            }
            
            if (!model) {
                console.warn('No model available for prediction');
                return { prediction: 0, modelType: 'none', regime: currentRegime };
            }
            
            // Make prediction based on model type
            let prediction = 0;
            if (model.predict) {
                prediction = model.predict(x);
            } else if (model.weights) {
                // Ridge/Elastic Net: dot product
                prediction = x.reduce((sum, val, idx) => sum + (val * (model.weights[idx] || 0)), 0);
            }
            
            return {
                prediction: prediction,
                modelType: modelType,
                regime: currentRegime
            };
        }
        
        /**
         * Gets contextual weights based on regime and trend alignment
         */
        function getContextualWeights(baseWeights, mainTrend, regime, extremes, supportResistance) {
            const contextualWeights = { ...baseWeights };
            
            // In strong trends: favor trend-following indicators
            if (regime === 'STRONG_TREND') {
                // Boost trend-following indicators
                if (contextualWeights['MACD (Monthly)']) contextualWeights['MACD (Monthly)'] *= 1.2;
                if (contextualWeights['MACD (Daily)']) contextualWeights['MACD (Daily)'] *= 1.2;
                if (contextualWeights['ADX/DI (Daily)']) contextualWeights['ADX/DI (Daily)'] *= 1.2;
                if (contextualWeights['Price vs. 200-DMA (Dist)']) contextualWeights['Price vs. 200-DMA (Dist)'] *= 1.2;
                
                // Reduce mean-reversion indicators
                if (contextualWeights['RSI (Daily)']) contextualWeights['RSI (Daily)'] *= 0.8;
                if (contextualWeights['Bollinger Bands']) contextualWeights['Bollinger Bands'] *= 0.8;
            }
            
            // In ranging markets: favor mean-reversion indicators
            if (regime === 'RANGING') {
                // Boost mean-reversion indicators
                if (contextualWeights['RSI (Daily)']) contextualWeights['RSI (Daily)'] *= 1.3;
                if (contextualWeights['Bollinger Bands']) contextualWeights['Bollinger Bands'] *= 1.3;
                if (contextualWeights['50-DMA Z-Score']) contextualWeights['50-DMA Z-Score'] *= 1.3;
                
                // Reduce trend-following indicators
                if (contextualWeights['MACD (Daily)']) contextualWeights['MACD (Daily)'] *= 0.7;
                if (contextualWeights['ADX/DI (Daily)']) contextualWeights['ADX/DI (Daily)'] *= 0.7;
            }
            
            // At support/resistance: boost mean-reversion indicators
            if (supportResistance.isAtSupport || supportResistance.isAtResistance) {
                if (contextualWeights['RSI (Daily)']) contextualWeights['RSI (Daily)'] *= 1.2;
                if (contextualWeights['Bollinger Bands']) contextualWeights['Bollinger Bands'] *= 1.2;
            }
            
            // In extreme conditions: reduce conflicting signals
            if (extremes.isExtreme) {
                // If extreme and against main trend, reduce weights
                if (mainTrend === 'BULLISH' && extremes.extremeType === 'OVERBOUGHT') {
                    // Overbought in uptrend = potential pullback, but not reversal
                    // Keep weights but be cautious
                } else if (mainTrend === 'BEARISH' && extremes.extremeType === 'OVERSOLD') {
                    // Oversold in downtrend = potential pullback
                } else if ((mainTrend === 'BULLISH' && extremes.extremeType === 'OVERSOLD') ||
                           (mainTrend === 'BEARISH' && extremes.extremeType === 'OVERBOUGHT')) {
                    // Extreme against trend = dangerous
                    // Reduce all weights slightly
                    Object.keys(contextualWeights).forEach(key => {
                        contextualWeights[key] *= 0.9;
                    });
                }
            }
            
            // Renormalize weights to sum to 1
            const sum = Object.values(contextualWeights).reduce((a, b) => a + b, 0);
            if (sum > 0) {
                Object.keys(contextualWeights).forEach(key => {
                    contextualWeights[key] /= sum;
                });
            }
            
            return contextualWeights;
        }
        
        /**
         * Main philosophy framework function - applies all philosophy-based adjustments
         */
        function applyPhilosophyFramework(rawScores, weights, context) {
            try {
                console.log('applyPhilosophyFramework called with:', { rawScores, weights, context });
                
                if (!rawScores || !weights || !context) {
                    console.error('Missing required parameters:', { rawScores: !!rawScores, weights: !!weights, context: !!context });
                    return null;
                }
                
                const {
                    monthlyMACD,
                    dailyMACD,
                    adxData,
                    rsi,
                    bollingerBands,
                    zScore,
                    priceVs200DMA,
                    sma50,
                    sma100,
                    sma200,
                    fibLevels,
                    priorHighs,
                    priorLows,
                    priceHistory,
                    currentPrice
                } = context;
                
                console.log('Extracted context values:', { 
                    hasMonthlyMACD: !!monthlyMACD,
                    hasDailyMACD: !!dailyMACD,
                    hasAdxData: !!adxData,
                    rsi,
                    hasBollingerBands: !!bollingerBands,
                    zScore,
                    priceVs200DMA
                });
                
                // Step 1: Establish main trend and assess health
                const mainTrend = getMainTrend(monthlyMACD);
                console.log('Main trend determined:', mainTrend);
                
                const trendHealth = assessTrendHealth(monthlyMACD, dailyMACD, adxData, priceVs200DMA);
                console.log('Trend health assessed:', trendHealth);
                
                // Step 2: Detect extremes and momentum slowdown
                const extremes = detectExtremes(rsi, bollingerBands, zScore, priceVs200DMA);
                const momentum = detectMomentumSlowdown(dailyMACD, monthlyMACD, adxData);
                const vulnerability = calculateVulnerabilityScore(extremes, momentum, trendHealth);
                
                // Step 3: Analyze support/resistance
                const supportResistance = analyzeSupportResistance(
                    currentPrice, sma50, sma100, sma200, fibLevels, priorHighs, priorLows
                );
                
                // Step 4: Detect support bounce
                const supportBounce = supportResistance.nearestSupport ? 
                    detectSupportBounce(priceHistory, supportResistance.nearestSupport, mainTrend, currentPrice) : 
                    { bounced: false, bounceStrength: 0, trendReestablished: false };
                
                // Step 5: Classify reversal type
                const reversalClassification = classifyReversalType(
                    mainTrend, currentPrice, supportResistance, momentum, trendHealth
                );
                
                // Step 6: Detect market regime
                const regime = detectMarketRegime(adxData, null, trendHealth);
                
                // Step 7: Get contextual weights
                const contextualWeights = getContextualWeights(weights, mainTrend, regime, extremes, supportResistance);
                
                // Step 8: Apply trend alignment to raw scores
                const alignedScores = {};
                Object.keys(rawScores).forEach(indicatorName => {
                    alignedScores[indicatorName] = applyTrendAlignment(
                        rawScores[indicatorName], 
                        mainTrend, 
                        indicatorName
                    );
                });
                
                // Step 9: Calculate final score with contextual weights
                let finalScore = 0;
                Object.keys(alignedScores).forEach(indicatorName => {
                    finalScore += alignedScores[indicatorName] * (contextualWeights[indicatorName] || weights[indicatorName] || 0);
                });
                
                // Step 10: Apply vulnerability adjustment
                // High vulnerability reduces confidence in the signal
                if (vulnerability > 0.7) {
                    finalScore *= (1 - vulnerability * 0.3); // Reduce score by up to 21% when highly vulnerable
                }
                
                // Step 11: Determine trend alignment
                // Compare final score direction (after trend alignment adjustments) with main trend
                // Also check for MACD conflict - if monthly and daily MACD conflict, mark as CONFLICTING
                let trendAlignment = 'NEUTRAL';
                if (mainTrend !== 'NEUTRAL') {
                    // First, check for MACD conflict (monthly vs daily)
                    let macdConflict = false;
                    if (monthlyMACD && dailyMACD) {
                        const monthlyHist = monthlyMACD.histogram;
                        const dailyHist = dailyMACD.histogram;
                        if (monthlyHist !== null && dailyHist !== null) {
                            // Conflict: monthly and daily MACD histograms have opposite signs
                            // (one bullish, one bearish)
                            macdConflict = (monthlyHist > 0 && dailyHist < 0) || (monthlyHist < 0 && dailyHist > 0);
                        }
                    }
                    
                    if (macdConflict) {
                        // MACD conflict indicates trend divergence/weakness - mark as CONFLICTING
                        // even if final score happens to align with main trend
                        trendAlignment = 'CONFLICTING';
                    } else if (Math.abs(finalScore) < 0.01) {
                        // Score is essentially neutral/zero - cannot determine alignment
                        trendAlignment = 'NEUTRAL';
                    } else {
                        const scoreDirection = finalScore > 0 ? 'BULLISH' : 'BEARISH';
                        trendAlignment = scoreDirection === mainTrend ? 'ALIGNED' : 'CONFLICTING';
                    }
                }
                
                // Step 12: Determine signal type
                let signalType = 'TREND_FOLLOWING';
                if (regime === 'RANGING' || extremes.isExtreme) {
                    signalType = 'MEAN_REVERSION';
                }
                if (reversalClassification.reversalType === 'MAJOR_REVERSAL') {
                    signalType = 'REVERSAL';
                }
                
                // Step 13: Determine risk level
                let riskLevel = 'MODERATE';
                if (vulnerability > 0.7 || trendAlignment === 'CONFLICTING' || reversalClassification.riskLevel === 'HIGH') {
                    riskLevel = 'HIGH';
                } else if (vulnerability < 0.3 && trendAlignment === 'ALIGNED' && trendHealth.isHealthy) {
                    riskLevel = 'LOW';
                }
                
                // Step 14: Generate warning flags
                const warningFlags = [];
                if (trendAlignment === 'CONFLICTING') {
                    warningFlags.push('Positioning against monthly MACD trend');
                }
                if (extremes.isExtreme) {
                    warningFlags.push(`${extremes.extremeType} conditions (${extremes.extremeIndicators.join(', ')})`);
                }
                if (momentum.isSlowing) {
                    warningFlags.push('Momentum decelerating');
                }
                if (vulnerability > 0.7) {
                    warningFlags.push('High vulnerability to reversal');
                }
                if (reversalClassification.reversalType === 'MAJOR_REVERSAL') {
                    warningFlags.push('Potential major trend reversal');
                }
            
                const result = {
                    finalScore: finalScore,
                    trendAlignment: trendAlignment,
                    riskLevel: riskLevel,
                    signalType: signalType,
                    entryOpportunity: reversalClassification.entryOpportunity,
                    warningFlags: warningFlags,
                    metadata: {
                        mainTrend: mainTrend,
                        trendHealth: trendHealth,
                        extremes: extremes,
                        momentum: momentum,
                        vulnerability: vulnerability,
                        supportResistance: supportResistance,
                        supportBounce: supportBounce,
                        reversalClassification: reversalClassification,
                        regime: regime,
                        contextualWeights: contextualWeights
                    }
                };
                
                console.log('Philosophy framework result created:', result);
                return result;
            } catch (error) {
                console.error('Error inside applyPhilosophyFramework:', error);
                console.error('Error stack:', error.stack);
                console.error('Error at:', error.name, error.message);
                // Return a minimal result so the display can still show something
                return {
                    finalScore: 0,
                    trendAlignment: 'NEUTRAL',
                    riskLevel: 'MODERATE',
                    signalType: 'TREND_FOLLOWING',
                    entryOpportunity: false,
                    warningFlags: [`Error: ${error.message}`],
                    metadata: {
                        mainTrend: 'NEUTRAL',
                        trendHealth: { strength: 'UNKNOWN', direction: 'NEUTRAL', isHealthy: false, isVulnerable: false },
                        extremes: { isExtreme: false, extremeType: 'NEUTRAL', extremeSeverity: 0, extremeIndicators: [] },
                        momentum: { isSlowing: false, slowdownType: 'STABLE', slowdownSeverity: 0 },
                        vulnerability: 0,
                        supportResistance: { nearestSupport: null, nearestResistance: null, isAtSupport: false, isAtResistance: false },
                        supportBounce: { bounced: false, bounceStrength: 0, trendReestablished: false },
                        reversalClassification: { reversalType: 'TREND_CONTINUATION', confidence: 0, entryOpportunity: false, riskLevel: 'MODERATE' },
                        regime: 'UNKNOWN',
                        contextualWeights: weights
                    }
                };
            }
        }

        // Walk-forward validation using pre-calculated weights (for comparing different weight sets)
        function walkForwardValidationWithWeights(scoreVectors, returns, weights, displayNames, indicatorKeys, lookaheadDays, minTrainSize = 25, stepSize = 15) {
            const n = returns.length;

            const results = {
                periods: [],
                overall: {
                    hitRate: 0,
                    avgReturn: 0,
                    sharpeRatio: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    totalSignals: 0
                },
                error: null
            };

            if (n < minTrainSize + 5) {
                results.error = `Insufficient data: ${n} data points available, need at least ${minTrainSize + 5}`;
                return results;
            }

            let allPredictions = [];
            let allActuals = [];
            let allReturns = [];

            for (let testStart = minTrainSize; testStart < n - lookaheadDays; testStart += stepSize) {
                const testEnd = Math.min(testStart + stepSize, n - lookaheadDays);
                if (testEnd <= testStart) break;

                const periodResults = {
                    startIdx: testStart,
                    endIdx: testEnd,
                    predictions: [],
                    actuals: [],
                    returns: [],
                    hitRate: 0,
                    avgReturn: 0,
                    signals: { bullish: 0, bearish: 0, neutral: 0 }
                };

                for (let i = testStart; i < testEnd; i++) {
                    const testRow = [];
                    let hasNull = false;
                    for (const key of indicatorKeys) {
                        if (scoreVectors[key] && scoreVectors[key][i] !== null && scoreVectors[key][i] !== undefined) {
                            testRow.push(scoreVectors[key][i]);
                        } else {
                            hasNull = true;
                            break;
                        }
                    }

                    if (hasNull || testRow.length !== indicatorKeys.length) continue;

                    // Calculate prediction using provided weights
                    let prediction = 0;
                    for (let j = 0; j < indicatorKeys.length; j++) {
                        const key = indicatorKeys[j];
                        const displayName = displayNames[key];
                        if (weights[displayName] !== undefined) {
                            prediction += testRow[j] * weights[displayName];
                        }
                    }

                    const actualReturn = returns[i];

                    periodResults.predictions.push(prediction);
                    periodResults.actuals.push(actualReturn);
                    periodResults.returns.push(actualReturn);

                    allPredictions.push(prediction);
                    allActuals.push(actualReturn);
                    allReturns.push(actualReturn);

                    // Categorize signal
                    if (prediction >= 0.10) periodResults.signals.bullish++;
                    else if (prediction < 0) periodResults.signals.bearish++;
                    else periodResults.signals.neutral++;
                }

                if (periodResults.returns.length > 0) {
                    let correct = 0;
                    for (let i = 0; i < periodResults.predictions.length; i++) {
                        if ((periodResults.predictions[i] > 0 && periodResults.returns[i] > 0) ||
                            (periodResults.predictions[i] < 0 && periodResults.returns[i] < 0)) {
                            correct++;
                        }
                    }
                    periodResults.hitRate = correct / periodResults.returns.length;
                    periodResults.avgReturn = periodResults.returns.reduce((a, b) => a + b, 0) / periodResults.returns.length;
                    results.periods.push(periodResults);
                }
            }

            // Calculate overall metrics
            if (allReturns.length > 0) {
                let correct = 0;
                for (let i = 0; i < allPredictions.length; i++) {
                    if ((allPredictions[i] > 0 && allReturns[i] > 0) ||
                        (allPredictions[i] < 0 && allReturns[i] < 0)) {
                        correct++;
                    }
                }
                results.overall.hitRate = correct / allReturns.length;
                
                // Calculate strategy returns: only bullish signals generate returns
                // For bullish signals (prediction >= 0.10): use actual return (long position)
                // For bearish signals (prediction < 0): return 0 (no position)
                // For neutral signals (0 <= prediction < 0.10): return 0 (no position)
                const strategyReturns = [];
                for (let i = 0; i < allPredictions.length; i++) {
                    if (allPredictions[i] >= 0.10) {
                        // Bullish signal: go long
                        strategyReturns.push(allReturns[i]);
                    } else {
                        // Bearish or neutral signal: no position, return 0
                        strategyReturns.push(0);
                    }
                }
                
                // Use strategy returns for performance metrics (not all returns)
                if (strategyReturns.length > 0) {
                    results.overall.avgReturn = strategyReturns.reduce((a, b) => a + b, 0) / strategyReturns.length;

                    const meanReturn = results.overall.avgReturn;
                    let variance = 0;
                    for (const ret of strategyReturns) {
                        variance += (ret - meanReturn) ** 2;
                    }
                    const stdDev = Math.sqrt(variance / strategyReturns.length);
                    const sharpe = stdDev > 0 ? (meanReturn / stdDev) * Math.sqrt(252 / lookaheadDays) : 0;
                    results.overall.sharpeRatio = sharpe;

                    const winningReturns = strategyReturns.filter(r => r > 0);
                    const losingReturns = strategyReturns.filter(r => r < 0);
                    results.overall.avgWin = winningReturns.length > 0 ? winningReturns.reduce((a, b) => a + b, 0) / winningReturns.length : 0;
                    results.overall.avgLoss = losingReturns.length > 0 ? losingReturns.reduce((a, b) => a + b, 0) / losingReturns.length : 0;
                    results.overall.totalSignals = strategyReturns.length;
                } else {
                    // Fallback if no signals generated
                    results.overall.avgReturn = 0;
                    results.overall.sharpeRatio = 0;
                    results.overall.avgWin = 0;
                    results.overall.avgLoss = 0;
                    results.overall.totalSignals = 0;
                }
            }

            return results;
        }

        // Walk-forward validation with performance metrics (trains Ridge Regression internally)
        function walkForwardValidation(scoreVectors, returns, lookaheadDays, minTrainSize = 25, stepSize = 15) {
            const n = returns.length;

            const results = {
                periods: [],
                overall: {
                    hitRate: 0,
                    avgReturn: 0,
                    sharpeRatio: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    totalSignals: 0
                },
                error: null
            };

            // Need at least minTrainSize for training + some for testing (reduced requirements)
            if (n < minTrainSize + 5) {
                results.error = `Insufficient data: ${n} data points available, need at least ${minTrainSize + 5}`;
                return results;
            }
            
            let allPredictions = [];
            let allActuals = [];
            let allReturns = [];
            
            for (let testStart = minTrainSize; testStart < n - lookaheadDays; testStart += stepSize) {
                const trainEnd = testStart;
                const testEnd = Math.min(testStart + stepSize, n - lookaheadDays);
                
                if (testEnd <= testStart) break;
                
                // Prepare training data
                const trainX = [];
                const trainY = [];
                const indicatorKeys = Object.keys(scoreVectors).filter(k => k !== 'returns');
                
                for (let i = 0; i < trainEnd; i++) {
                    const row = [];
                    let hasNull = false;
                    for (const key of indicatorKeys) {
                        if (scoreVectors[key][i] === null || scoreVectors[key][i] === undefined) {
                            hasNull = true;
                            break;
                        }
                        row.push(scoreVectors[key][i]);
                    }
                    if (!hasNull && returns[i] !== null && returns[i] !== undefined) {
                        trainX.push(row);
                        trainY.push(returns[i]);
                    }
                }
                
                if (trainX.length < minTrainSize) continue;
                
                // Train ridge regression
                const model = ridgeRegression(trainX, trainY, 0.1);
                if (!model) continue;
                
                // Test on out-of-sample period
                const periodResults = {
                    startIdx: testStart,
                    endIdx: testEnd,
                    predictions: [],
                    actuals: [],
                    returns: [],
                    hitRate: 0,
                    avgReturn: 0,
                    signals: { bullish: 0, bearish: 0, neutral: 0 }
                };
                
                for (let i = testStart; i < testEnd; i++) {
                    const testRow = [];
                    let hasNull = false;
                    for (const key of indicatorKeys) {
                        if (scoreVectors[key][i] === null || scoreVectors[key][i] === undefined) {
                            hasNull = true;
                            break;
                        }
                        testRow.push(scoreVectors[key][i]);
                    }
                    
                    if (hasNull) continue;
                    
                    // Predict using model
                    let prediction = model.intercept;
                    for (let j = 0; j < testRow.length; j++) {
                        prediction += model.weights[j] * testRow[j];
                    }
                    
                    const actualReturn = returns[i];
                    
                    periodResults.predictions.push(prediction);
                    periodResults.actuals.push(actualReturn);
                    periodResults.returns.push(actualReturn);
                    
                    allPredictions.push(prediction);
                    allActuals.push(actualReturn);
                    allReturns.push(actualReturn);
                    
                    // Categorize signal
                    if (prediction >= 0.10) periodResults.signals.bullish++;
                    else if (prediction < 0) periodResults.signals.bearish++;
                    else periodResults.signals.neutral++;
                }
                
                if (periodResults.returns.length > 0) {
                    // Calculate period metrics
                    let correct = 0;
                    for (let i = 0; i < periodResults.predictions.length; i++) {
                        if ((periodResults.predictions[i] > 0 && periodResults.returns[i] > 0) ||
                            (periodResults.predictions[i] < 0 && periodResults.returns[i] < 0)) {
                            correct++;
                        }
                    }
                    periodResults.hitRate = correct / periodResults.returns.length;
                    periodResults.avgReturn = periodResults.returns.reduce((a, b) => a + b, 0) / periodResults.returns.length;
                    
                    results.periods.push(periodResults);
                }
            }
            
            // Calculate overall metrics
            if (allReturns.length > 0) {
                let correct = 0;
                for (let i = 0; i < allPredictions.length; i++) {
                    if ((allPredictions[i] > 0 && allReturns[i] > 0) ||
                        (allPredictions[i] < 0 && allReturns[i] < 0)) {
                        correct++;
                    }
                }
                results.overall.hitRate = correct / allReturns.length;
                results.overall.avgReturn = allReturns.reduce((a, b) => a + b, 0) / allReturns.length;
                
                // Sharpe ratio (annualized)
                const meanReturn = results.overall.avgReturn;
                let variance = 0;
                for (const ret of allReturns) {
                    variance += (ret - meanReturn) ** 2;
                }
                const stdDev = Math.sqrt(variance / allReturns.length);
                const sharpe = stdDev > 0 ? (meanReturn / stdDev) * Math.sqrt(252 / lookaheadDays) : 0;
                results.overall.sharpeRatio = sharpe;
                
                // Average win/loss
                const winReturns = allReturns.filter(r => r > 0);
                const lossReturns = allReturns.filter(r => r < 0);
                results.overall.avgWin = winReturns.length > 0 ? winReturns.reduce((a, b) => a + b, 0) / winReturns.length : 0;
                results.overall.avgLoss = lossReturns.length > 0 ? lossReturns.reduce((a, b) => a + b, 0) / lossReturns.length : 0;
                
                results.overall.totalSignals = allReturns.length;
            }
            
            return results;
        }

        // O(n) rolling SMA to avoid nested loops per point
        function SMA(data, period) {
            const results = new Array(data.length).fill(null);
            if (period <= 0 || data.length === 0) return results;

            let windowSum = 0;
            for (let i = 0; i < data.length; i++) {
                windowSum += data[i];
                if (i >= period) {
                    windowSum -= data[i - period];
                }
                if (i >= period - 1) {
                    results[i] = windowSum / period;
                }
            }
            return results;
        }

        function EMA(data, period) {
            let results = [];
            const k = 2 / (period + 1);

            let initialData = data.slice(0, period);
            if (initialData.length < period) {
                return new Array(data.length).fill(null);
            }
            let initialSMA = initialData.reduce((sum, val) => sum + val, 0) / period;

            for(let i=0; i<data.length; i++) {
                if(i < period - 1) {
                    results.push(null);
                } else if(i === period - 1) {
                    results.push(initialSMA);
                } else {
                    let val = (data[i] * k) + (results[i-1] * (1-k));
                    results.push(val);
                }
            }
            return results;
        }

        // O(n) rolling standard deviation using rolling sum and sum of squares
        function StdDev(data, period) {
            const results = new Array(data.length).fill(null);
            if (period <= 1 || data.length === 0) return results;

            let windowSum = 0;
            let windowSumSq = 0;

            for (let i = 0; i < data.length; i++) {
                const val = data[i];
                windowSum += val;
                windowSumSq += val * val;

                if (i >= period) {
                    const toRemove = data[i - period];
                    windowSum -= toRemove;
                    windowSumSq -= toRemove * toRemove;
                }

                if (i >= period - 1) {
                    const mean = windowSum / period;
                    const variance = Math.max(0, (windowSumSq / period) - (mean * mean));
                    results[i] = Math.sqrt(variance);
                }
            }
            return results;
        }

        function calculateRSI(closes, period = 14) {
            let rsiArr = new Array(closes.length).fill(null);

            let gains = 0;
            let losses = 0;
            for (let i = 1; i <= period; i++) {
                if (closes[i] === undefined || closes[i-1] === undefined) return rsiArr;
                let change = closes[i] - closes[i - 1];
                if (change > 0) gains += change;
                else losses += Math.abs(change);
            }

            let avgGain = gains / period;
            let avgLoss = losses / period;

            if (avgLoss === 0) {
                rsiArr[period] = 100;
            } else {
                rsiArr[period] = 100 - (100 / (1 + (avgGain / avgLoss)));
            }

            for (let i = period + 1; i < closes.length; i++) {
                let change = closes[i] - closes[i - 1];
                let up = change > 0 ? change : 0;
                let down = change < 0 ? Math.abs(change) : 0;

                avgGain = ((avgGain * (period - 1)) + up) / period;
                avgLoss = ((avgLoss * (period - 1)) + down) / period;

                let rs = avgLoss === 0 ? (avgGain === 0 ? 0 : Infinity) : avgGain / avgLoss;
                rsiArr[i] = rs === Infinity ? 100 : 100 - (100 / (1 + rs));
            }
            return rsiArr;
        }

        function calculateMACD(closes) {
            const ema12 = EMA(closes, 12);
            const ema26 = EMA(closes, 26);
            let macdLine = [];

            for(let i=0; i<closes.length; i++) {
                if(ema12[i] !== null && ema26[i] !== null) {
                    macdLine.push(ema12[i] - ema26[i]);
                } else {
                    macdLine.push(null);
                }
            }

            let validMacd = macdLine.filter(x => x !== null);
            let signalLineValid = EMA(validMacd, 9);

            let signalLine = new Array(macdLine.length).fill(null);
            let nullCount = macdLine.length - validMacd.length;

            for(let i=0; i<signalLineValid.length; i++) {
                if(signalLineValid[i] !== null) {
                    signalLine[i + nullCount] = signalLineValid[i];
                }
            }

            let histogram = [];
            let slope = [];

            for(let i=0; i<macdLine.length; i++) {
                if (macdLine[i] !== null && signalLine[i] !== null) {
                    histogram.push(macdLine[i] - signalLine[i]);
                } else {
                    histogram.push(null);
                }

                if (i > 0 && macdLine[i] !== null && macdLine[i-1] !== null) {
                    slope.push(macdLine[i] - macdLine[i-1]);
                } else {
                    slope.push(null);
                }
            }

            return { macdLine, signalLine, histogram, slope };
        }

        /**
         * Calculates adaptive normalization parameters from a rolling window of MACD raw scores
         * Uses percentile-based approach for robust normalization
         * 
         * @param {Array} rawScores - Array of raw MACD total scores (0-100 range)
         * @param {number} windowSize - Size of rolling window (default: 252 = 1 year)
         * @returns {Object} Normalization parameters: {neutral, scale, minScore, maxScore, p25, p75}
         */
        function calculateAdaptiveNormalization(rawScores, windowSize = 252) {
            if (!rawScores || rawScores.length === 0) {
                // Fallback to fixed normalization if no data
                // For -100 to +100 range, neutral is 0, scale is 100
                return {
                    neutral: 0,
                    scale: 100,
                    minScore: -100,
                    maxScore: 100,
                    p25: -50,
                    p75: 50,
                    method: 'FIXED'
                };
            }
            
            // Use rolling window (last N scores) or all available if less than windowSize
            const windowScores = rawScores.slice(-windowSize).filter(s => s !== null && !isNaN(s));
            
            if (windowScores.length < 10) {
                // Not enough data, use fixed normalization
                return {
                    neutral: 0,
                    scale: 100,
                    minScore: -100,
                    maxScore: 100,
                    p25: -50,
                    p75: 50,
                    method: 'FIXED'
                };
            }
            
            // Sort for percentile calculation
            const sorted = [...windowScores].sort((a, b) => a - b);
            const n = sorted.length;
            
            // Calculate percentiles
            const p25 = sorted[Math.floor(n * 0.25)]; // 25th percentile (bearish threshold)
            const p50 = sorted[Math.floor(n * 0.50)]; // Median
            const p75 = sorted[Math.floor(n * 0.75)]; // 75th percentile (bullish threshold)
            
            // Calculate min/max from actual data (with some padding for outliers)
            const minScore = Math.max(-100, sorted[0] - 5); // Pad minimum slightly
            const maxScore = Math.min(100, sorted[n - 1] + 5); // Pad maximum slightly
            
            // CRITICAL FIX: Always use 0 as the neutral point (symmetric -100 to +100 range)
            // The scoring system is now 2-tailed with 0 as neutral
            const neutral = 0;
            
            // Calculate scale based on distance from 0 to percentiles
            // Use the larger of: (p75 - 0) or (0 - p25) to ensure symmetric scaling
            // This adapts to the actual distribution while preserving 0 as neutral
            const scaleAboveNeutral = Math.max(p75 - 0, 10); // Distance from 0 to 75th percentile
            const scaleBelowNeutral = Math.max(0 - p25, 10); // Distance from 25th percentile to 0
            const scaleFromNeutral = Math.max(scaleAboveNeutral, scaleBelowNeutral, 10); // At least 10 points
            
            return {
                neutral: neutral,
                scale: scaleFromNeutral, // Use distance from neutral for symmetric scaling
                minScore: minScore,
                maxScore: maxScore,
                p25: p25,
                p50: p50,
                p75: p75,
                method: 'ADAPTIVE',
                sampleSize: windowScores.length
            };
        }

        /**
         * Detects volatility regime based on ATR or standard deviation
         * Returns: 'HIGH', 'MEDIUM', or 'LOW'
         */
        function detectVolatilityRegime(atrValue, atrArray, index, closes, lookback = 20) {
            if (atrValue === null || atrValue === undefined) {
                // Fallback: use price standard deviation
                if (closes && index >= lookback) {
                    const recentCloses = closes.slice(Math.max(0, index - lookback), index + 1);
                    const mean = recentCloses.reduce((a, b) => a + b, 0) / recentCloses.length;
                    const variance = recentCloses.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recentCloses.length;
                    const stdDev = Math.sqrt(variance);
                    const cv = mean > 0 ? stdDev / mean : 0; // Coefficient of variation
                    
                    // Classify based on CV
                    if (cv > 0.03) return 'HIGH';      // > 3% daily volatility
                    else if (cv > 0.015) return 'MEDIUM'; // 1.5-3% daily volatility
                    else return 'LOW';                  // < 1.5% daily volatility
                }
                return 'MEDIUM'; // Default
            }
            
            // Use ATR relative to price for volatility classification
            if (closes && index >= 0 && closes[index] !== null) {
                const currentPrice = closes[index];
                const atrPercent = currentPrice > 0 ? (atrValue / currentPrice) * 100 : 0;
                
                // Calculate historical ATR percentiles for context
                if (atrArray && index >= lookback) {
                    const recentATRs = [];
                    for (let i = Math.max(0, index - lookback); i <= index; i++) {
                        if (atrArray[i] !== null && closes[i] !== null && closes[i] > 0) {
                            recentATRs.push((atrArray[i] / closes[i]) * 100);
                        }
                    }
                    
                    if (recentATRs.length > 0) {
                        const sorted = [...recentATRs].sort((a, b) => a - b);
                        const median = sorted[Math.floor(sorted.length / 2)];
                        const p75 = sorted[Math.floor(sorted.length * 0.75)];
                        const p25 = sorted[Math.floor(sorted.length * 0.25)];
                        
                        // Classify based on percentile position
                        if (atrPercent > p75) return 'HIGH';
                        else if (atrPercent < p25) return 'LOW';
                        else return 'MEDIUM';
                    }
                }
                
                // Fallback: absolute thresholds if no history
                if (atrPercent > 3.0) return 'HIGH';      // > 3% of price
                else if (atrPercent > 1.5) return 'MEDIUM'; // 1.5-3% of price
                else return 'LOW';                         // < 1.5% of price
            }
            
            return 'MEDIUM'; // Default
        }
        
        /**
         * Gets dynamic MACD component weights based on volatility regime
         * Signal-heavy: Signal Position (B) is PRIMARY - has minimum weight (30%) and higher maximum (50%)
         * Signal Position is typically the most important component
         */
        function getDynamicMACDWeights(volatilityRegime) {
            const MIN_SIGNAL_WEIGHT = 30; // Minimum weight for Signal Position (B) - always primary
            const MAX_SIGNAL_WEIGHT = 50; // Maximum weight for Signal Position (B) - can go higher in extreme cases
            
            // Base weights with Signal Position (B) as primary (minimum 30%, typically 35-40%)
            const baseWeights = {
                A: 28, // Trend Regime: Secondary
                B: 35, // Signal Position: PRIMARY - minimum 30%, typically 35-45%
                C: 22, // Histogram Expansion: Tertiary
                D: 15  // Cross Quality: Supporting
            };
            
            let weights;
            
            switch(volatilityRegime) {
                case 'HIGH':
                    // High volatility: MAXIMIZE signal alignment (signal position is critical)
                    // Signal Position gets maximum weight, reduce noisy components
                    weights = {
                        A: 25, // Trend Regime: Reduced (still important but less than signal)
                        B: 50, // Signal Position: MAXIMUM (signal is critical in volatile markets)
                        C: 15, // Histogram Expansion: Reduced (noisy in high vol)
                        D: 10  // Cross Quality: Reduced (crosses less reliable in high vol)
                    };
                    break;
                    
                case 'MEDIUM':
                    // Medium volatility: Balanced but Signal Position still primary
                    weights = {
                        A: 28, // Trend Regime: Maintained
                        B: 38, // Signal Position: Above base (primary importance)
                        C: 20, // Histogram Expansion: Slightly reduced
                        D: 14  // Cross Quality: Maintained
                    };
                    break;
                    
                case 'LOW':
                    // Low volatility: Signal Position still primary, but can rely more on momentum
                    // Even in low vol, signal is still most important (minimum 30% enforced)
                    weights = {
                        A: 28, // Trend Regime: Maintained
                        B: 30, // Signal Position: MINIMUM (30% - still primary, but momentum more reliable)
                        C: 30, // Histogram Expansion: Increased (more reliable in low vol)
                        D: 12  // Cross Quality: Slightly reduced
                    };
                    break;
                    
                default:
                    weights = baseWeights;
            }
            
            // Enforce minimum weight for Signal Position (B) - always primary
            if (weights.B < MIN_SIGNAL_WEIGHT) {
                const deficit = MIN_SIGNAL_WEIGHT - weights.B;
                weights.B = MIN_SIGNAL_WEIGHT;
                // Rebalance other weights proportionally to maintain sum of 100
                const otherSum = weights.A + weights.C + weights.D;
                if (otherSum > 0) {
                    const reductionFactor = (100 - MIN_SIGNAL_WEIGHT) / otherSum;
                    weights.A = Math.round(weights.A * reductionFactor);
                    weights.C = Math.round(weights.C * reductionFactor);
                    weights.D = 100 - weights.B - weights.A - weights.C; // Ensure sum is exactly 100
                }
            }
            
            // Cap maximum weight for Signal Position (B) if needed (though current max is 50, which is fine)
            if (weights.B > MAX_SIGNAL_WEIGHT) {
                const excess = weights.B - MAX_SIGNAL_WEIGHT;
                weights.B = MAX_SIGNAL_WEIGHT;
                // Rebalance other weights proportionally
                const otherSum = weights.A + weights.C + weights.D;
                if (otherSum > 0) {
                    const increaseFactor = (100 - MAX_SIGNAL_WEIGHT) / otherSum;
                    weights.A = Math.round(weights.A * increaseFactor);
                    weights.C = Math.round(weights.C * increaseFactor);
                    weights.D = 100 - weights.B - weights.A - weights.C; // Ensure sum is exactly 100
                }
            }
            
            return weights;
        }
        
        /**
         * New MACD Calibration Scoring System (4 components, 0-100 total)
         * A. Trend Regime Score (0-30): MACD vs Zero Line
         * B. Signal-Line Position Score (0-30): MACD vs Signal
         * C. Histogram Expansion Score (0-25): Histogram slope/expansion
         * D. Cross Quality Score (0-15): Recent MACD/Signal crosses
         * 
         * @param {Object} weights - Optional weights object {A, B, C, D}. If not provided, uses default weights.
         * @param {String} volatilityRegimeName - Optional name of volatility regime ('HIGH', 'MEDIUM', 'LOW') for display
         */
        function calculateMACDCalibratedScore(macdLine, signalLine, histogram, histogramSlope, macdLineArray, signalLineArray, index, lookbackBars = 10, weights = null, volatilityRegimeName = null, normalizationParams = null) {
            if (macdLine === null || signalLine === null || histogram === null) {
                return 0;
            }

            // Use provided weights or default weights
            const defaultWeights = { A: 30, B: 30, C: 25, D: 15 };
            const w = weights || defaultWeights;
            
            // Normalize weights to ensure they sum to 100 (for consistency)
            const weightSum = w.A + w.B + w.C + w.D;
            const normalizedWeights = {
                A: (w.A / weightSum) * 100,
                B: (w.B / weightSum) * 100,
                C: (w.C / weightSum) * 100,
                D: (w.D / weightSum) * 100
            };

            let totalScore = 0;

            // A. Trend Regime Score (0-30): MACD vs Zero Line
            // Check if MACD line is rising/falling (need MACD line slope, not histogram slope)
            let macdLineRising = false;
            let macdLineFalling = false;
            if (macdLineArray && index > 0 && macdLineArray[index] !== null && macdLineArray[index - 1] !== null) {
                const macdLineSlope = macdLineArray[index] - macdLineArray[index - 1];
                macdLineRising = macdLineSlope > 0.001;
                macdLineFalling = macdLineSlope < -0.001;
            } else if (histogramSlope !== null) {
                // Fallback: use histogram slope as approximation
                macdLineRising = histogramSlope > 0.001;
                macdLineFalling = histogramSlope < -0.001;
            }
            const macdLineFlat = !macdLineRising && !macdLineFalling;
            
            // Calculate regime score on -30 to +30 scale (symmetric, 2-tailed), then scale to actual weight
            let regimeScoreRaw = 0;
            if (macdLine > 0) {
                if (macdLineRising) {
                    regimeScoreRaw = 30; // MACD > 0 and rising (strong bullish)
                } else if (macdLineFlat || macdLineFalling) {
                    regimeScoreRaw = 20; // MACD > 0 but flat/falling (weakening bullish)
                }
            } else if (macdLine < 0) {
                if (macdLineRising) {
                    regimeScoreRaw = -10; // MACD < 0 but rising (weakening bearish)
                } else if (macdLineFalling) {
                    regimeScoreRaw = -30; // MACD < 0 and falling (strong bearish)
                } else if (macdLineFlat) {
                    regimeScoreRaw = -20; // MACD < 0 but flat (bearish but stable)
                }
            }
            // Scale to actual weight (30 is the base max, scale proportionally)
            const regimeScore = (regimeScoreRaw / 30) * normalizedWeights.A;
            totalScore += regimeScore;

            // B. Signal-Line Position Score (0-30): MACD vs Signal
            const macdAboveSignal = macdLine > signalLine;
            let signalRising = false;
            let signalFalling = false;
            if (signalLineArray && index > 0 && signalLineArray[index] !== null && signalLineArray[index - 1] !== null) {
                const signalSlope = signalLineArray[index] - signalLineArray[index - 1];
                signalRising = signalSlope > 0.001;
                signalFalling = signalSlope < -0.001;
            }
            const signalFlat = !signalRising && !signalFalling;

            // Calculate signal position score on -30 to +30 scale (symmetric, 2-tailed), then scale to actual weight
            // Bullish: MACD > Signal = positive, Bearish: MACD < Signal = negative
            let signalPositionScoreRaw = 0;
            if (macdAboveSignal) {
                // MACD above Signal (bullish momentum)
                if (signalRising) {
                    signalPositionScoreRaw = 30; // MACD > Signal AND Signal rising (strong bullish)
                } else if (signalFlat) {
                    signalPositionScoreRaw = 20; // MACD > Signal BUT Signal flat (moderate bullish)
                } else {
                    // MACD > Signal BUT Signal falling = 0 (momentum weakening, neutral)
                    signalPositionScoreRaw = 0;
                }
            } else {
                // MACD below Signal (bearish momentum)
                if (signalFalling) {
                    signalPositionScoreRaw = -30; // MACD < Signal AND Signal falling (strong bearish)
                } else if (signalFlat) {
                    signalPositionScoreRaw = -20; // MACD < Signal BUT Signal flat (moderate bearish)
                } else {
                    // MACD < Signal BUT Signal rising = -10 (bearish but weakening)
                    signalPositionScoreRaw = -10;
                }
            }
            // Scale to actual weight (30 is the base max, scale proportionally)
            const signalPositionScore = (signalPositionScoreRaw / 30) * normalizedWeights.B;
            totalScore += signalPositionScore;

            // C. Histogram Expansion Score (-25 to +25): Histogram slope/expansion (symmetric, 2-tailed)
            // histogramSlope is the change in histogram (histogram[i] - histogram[i-1])
            // We need to check if histogram is expanding away from 0 or contracting toward 0
            // IMPORTANT: Expansion upward (positive) is bullish, expansion downward (negative) is bearish
            let histogramExpansionScoreRaw = 0;
            let histogramExpansionDesc = 'Histogram slope unavailable';
            if (histogramSlope !== null) {
                // Expansion upward: histogram positive and increasing (bullish)
                const histogramExpandingUp = histogram > 0 && histogramSlope > 0.001;
                // Expansion downward: histogram negative and decreasing (becoming more negative = bearish)
                const histogramExpandingDown = histogram < 0 && histogramSlope < -0.001;
                // Contracting: moving toward zero (losing momentum)
                const histogramContracting = (histogram > 0 && histogramSlope < -0.001) || (histogram < 0 && histogramSlope > 0.001);
                const histogramFlat = Math.abs(histogramSlope) <= 0.001;

                if (histogramExpandingUp) {
                    // Bullish: Positive histogram expanding upward (away from 0)
                    histogramExpansionScoreRaw = 25; // Maximum score for bullish expansion
                    histogramExpansionDesc = 'Histogram expanding upward (bullish)';
                } else if (histogramExpandingDown) {
                    // Bearish: Negative histogram expanding downward (away from 0, bearish)
                    histogramExpansionScoreRaw = -25; // Maximum negative score for bearish expansion
                    histogramExpansionDesc = 'Histogram expanding downward (bearish)';
                } else if (histogramFlat || Math.abs(histogramSlope) < 0.002) {
                    // Neutral: Flat or minor movement
                    histogramExpansionScoreRaw = 0; // Neutral score (was 15, now 0 for symmetry)
                    histogramExpansionDesc = 'Histogram flat / minor expansion';
                } else if (histogramContracting) {
                    // Losing momentum: Moving toward zero
                    // If contracting from positive, give small positive; if from negative, give small negative
                    if (histogram > 0) {
                        histogramExpansionScoreRaw = 5; // Contracting from positive (bullish weakening)
                    } else {
                        histogramExpansionScoreRaw = -5; // Contracting from negative (bearish weakening)
                    }
                    histogramExpansionDesc = 'Histogram contracting toward 0';
                }
                
                // Check if histogram is crossing 0 against trend
                if (macdLineArray && signalLineArray && index > 0) {
                    const prevHistogram = (macdLineArray[index - 1] !== null && signalLineArray[index - 1] !== null) 
                        ? (macdLineArray[index - 1] - signalLineArray[index - 1]) : null;
                    if (prevHistogram !== null) {
                        const crossingZero = (prevHistogram < 0 && histogram > 0) || (prevHistogram > 0 && histogram < 0);
                        if (crossingZero && histogramContracting) {
                            histogramExpansionScoreRaw = 0; // Histogram crossing 0 against trend
                            histogramExpansionDesc = 'Histogram crossing 0 against trend';
                        }
                    }
                }
            } else {
                histogramExpansionScoreRaw = 0; // Default neutral if slope unavailable (was 5, now 0 for symmetry)
            }
            // Scale to actual weight (25 is the base max, scale proportionally)
            const histogramExpansionScore = (histogramExpansionScoreRaw / 25) * normalizedWeights.C;
            totalScore += histogramExpansionScore;

            // D. Cross Quality Score (-15 to +15): Recent MACD/Signal crosses (symmetric, 2-tailed)
            let crossScoreRaw = 0; // Default: no recent cross (neutral, was 5, now 0 for symmetry)
            if (macdLineArray && signalLineArray && index >= 1) {
                // Look back for recent cross (within last N bars)
                for (let i = index; i >= Math.max(1, index - lookbackBars + 1); i--) {
                    if (macdLineArray[i] === null || signalLineArray[i] === null || 
                        macdLineArray[i - 1] === null || signalLineArray[i - 1] === null) {
                        continue;
                    }

                    const prevMacdAboveSignal = macdLineArray[i - 1] > signalLineArray[i - 1];
                    const currMacdAboveSignal = macdLineArray[i] > signalLineArray[i];
                    const prevMacdAboveZero = macdLineArray[i - 1] > 0;
                    const currMacdAboveZero = macdLineArray[i] > 0;

                    // Bull cross: MACD crosses above Signal
                    if (!prevMacdAboveSignal && currMacdAboveSignal) {
                        if (prevMacdAboveZero && currMacdAboveZero) {
                            crossScoreRaw = 15; // Bull cross ABOVE zero line (strong bullish)
                            break;
                        } else {
                            crossScoreRaw = 7; // Bull cross BELOW zero line (moderate bullish)
                            break;
                        }
                    }
                    // Bear cross: MACD crosses below Signal
                    else if (prevMacdAboveSignal && !currMacdAboveSignal) {
                        if (!prevMacdAboveZero && !currMacdAboveZero) {
                            crossScoreRaw = -15; // Bear cross BELOW zero line (strong bearish, was 0)
                            break;
                        } else {
                            crossScoreRaw = -7; // Bear cross ABOVE zero line (moderate bearish, was -5)
                            break;
                        }
                    }
                }
            }
            // Scale to actual weight (15 is the base max, scale proportionally)
            // Handle negative scores - scale proportionally but maintain sign
            const crossScore = (crossScoreRaw / 15) * normalizedWeights.D;
            totalScore += crossScore;

            // Improved Adaptive Normalization
            // Uses percentile-based normalization if parameters provided, otherwise falls back to fixed
            // NOTE: totalScore now ranges from -100 to +100 (symmetric, 2-tailed), with 0 as neutral
            let normalizedScore;
            let normalizationMethod = 'FIXED';
            
            if (normalizationParams && normalizationParams.method === 'ADAPTIVE') {
                // Adaptive normalization: Always use 0 as neutral point (symmetric scoring)
                // Scale is dynamically determined from percentiles to adapt to actual distribution
                // Since raw scores are now -100 to +100, we shift them to 0-200 for percentile calculation
                // But for normalization, we use 0 as neutral directly
                const neutral = 0; // Always 0 for symmetric -100 to +100 range
                const scale = normalizationParams.scale;
                
                // Normalize: (score - 0) / scale = score / scale
                // This maps: 0 -> 0, +scale -> +1, -scale -> -1
                // Ensures scores above 0 stay positive, scores below 0 stay negative
                normalizedScore = scale > 0 ? (totalScore - neutral) / scale : 0;
                normalizationMethod = 'ADAPTIVE';
                
                // Clamp to reasonable bounds (allow slight overflow for extreme cases)
                normalizedScore = Math.max(-1.5, Math.min(1.5, normalizedScore));
            } else {
                // Fallback: Fixed normalization (original method)
                // Score of 0 = neutral (0), +100 = +1, -100 = -1
                normalizedScore = totalScore / 100;
                normalizationMethod = 'FIXED';
            }
            
            // Final clamp to -1 to +1 range
            const finalScore = Math.max(-1.0, Math.min(1.0, normalizedScore));
            
            // Return both score and detailed breakdown
            return {
                score: finalScore,
                breakdown: {
                    trendRegime: {
                        score: regimeScore,
                        maxScore: normalizedWeights.A,
                        description: macdLine > 0 
                            ? (macdLineRising ? 'MACD > 0 and rising' : 'MACD > 0 but flat/falling')
                            : (macdLineRising ? 'MACD < 0 but rising' : 'MACD < 0 and falling')
                    },
                    signalPosition: {
                        score: signalPositionScore,
                        maxScore: normalizedWeights.B,
                        description: macdAboveSignal
                            ? (signalRising ? 'MACD > Signal AND Signal rising' : signalFlat ? 'MACD > Signal BUT Signal flat' : 'MACD > Signal BUT Signal falling')
                            : (signalRising ? 'MACD < Signal BUT Signal rising' : signalFalling ? 'MACD < Signal AND Signal falling' : 'MACD < Signal BUT Signal flat')
                    },
                    histogramExpansion: {
                        score: histogramExpansionScore,
                        maxScore: normalizedWeights.C,
                        description: histogramExpansionDesc
                    },
                    crossQuality: {
                        score: crossScore,
                        maxScore: normalizedWeights.D,
                        description: crossScoreRaw === 15 ? 'Bull cross ABOVE zero line'
                            : crossScoreRaw === 7 ? 'Bull cross BELOW zero line'
                            : crossScoreRaw === 0 ? 'Bear cross BELOW zero line'
                            : crossScoreRaw === -5 ? 'Bear cross ABOVE zero line (penalty)'
                            : 'No recent cross'
                    },
                    totalRawScore: totalScore,
                    normalizedScore: finalScore,
                    normalizationMethod: normalizationMethod,
                    normalizationParams: normalizationParams ? {
                        neutral: normalizationParams.neutral,
                        scale: normalizationParams.scale,
                        p25: normalizationParams.p25,
                        p50: normalizationParams.p50,
                        p75: normalizationParams.p75
                    } : null,
                    weightsUsed: {
                        A: normalizedWeights.A,
                        B: normalizedWeights.B,
                        C: normalizedWeights.C,
                        D: normalizedWeights.D,
                        volatilityRegime: weights ? 'DYNAMIC' : 'DEFAULT',
                        rawWeights: weights || { A: 30, B: 30, C: 25, D: 15 },
                        volatilityRegimeName: volatilityRegimeName || (weights ? (weights.A === 50 ? 'HIGH' : weights.A === 30 && weights.C === 30 ? 'LOW' : weights.A === 38 ? 'MEDIUM' : 'MEDIUM') : 'DEFAULT')
                    }
                }
            };
        }

        function calculateATR(highs, lows, closes, period = 14) {
            let tr = [];
            for(let i=0; i<highs.length; i++) {
                if(i===0) {
                    tr.push(highs[i] - lows[i]);
                    continue;
                }
                let hl = highs[i] - lows[i];
                let hc = Math.abs(highs[i] - closes[i-1]);
                let lc = Math.abs(lows[i] - closes[i-1]);
                tr.push(Math.max(hl, hc, lc));
            }

            let atr = new Array(highs.length).fill(null);
            let firstATR = 0;
            if (tr.length >= period) {
                for(let i=0; i<period; i++) firstATR += tr[i];
                atr[period-1] = firstATR / period;
            } else {
                return atr;
            }

            for(let i=period; i<highs.length; i++) {
                if (atr[i-1] !== null) {
                    atr[i] = ((atr[i-1] * (period-1)) + tr[i]) / period;
                }
            }
            return atr;
        }

        function calculateADX(highs, lows, closes, period = 14) {
            let plusDM = [], minusDM = [], tr = [];

            for(let i=0; i<highs.length; i++) {
                if(i===0) {
                    plusDM.push(0); minusDM.push(0); tr.push(0);
                    continue;
                }
                let up = highs[i] - highs[i-1];
                let down = lows[i-1] - lows[i];

                if(up > down && up > 0) plusDM.push(up); else plusDM.push(0);
                if(down > up && down > 0) minusDM.push(down); else minusDM.push(0);

                let hl = highs[i] - lows[i];
                let hc = Math.abs(highs[i] - closes[i-1]);
                let lc = Math.abs(lows[i] - closes[i-1]);
                tr.push(Math.max(hl, hc, lc));
            }

            function smooth(data, startIdx, initialVal) {
                let smoothed = new Array(data.length).fill(0);
                smoothed[startIdx] = initialVal;
                for(let i=startIdx+1; i<data.length; i++) {
                    smoothed[i] = smoothed[i-1] - (smoothed[i-1]/period) + data[i];
                }
                return smoothed;
            }

            if (tr.length <= period) return { adx: new Array(highs.length).fill(null), pdi: [], mdi: [] };

            let sTR = 0, sPDM = 0, sMDM = 0;
            for(let i=1; i<=period; i++) {
                sTR += tr[i]; sPDM += plusDM[i]; sMDM += minusDM[i];
            }

            let smoothTR = smooth(tr, period, sTR);
            let smoothPDM = smooth(plusDM, period, sPDM);
            let smoothMDM = smooth(minusDM, period, sMDM);

            let dx = [];
            for(let i=0; i<highs.length; i++) {
                if(i <= period) { dx.push(null); continue; }
                let pdi = 100 * (smoothPDM[i] / smoothTR[i]);
                let mdi = 100 * (smoothMDM[i] / smoothTR[i]);
                let div = pdi + mdi;
                if(div === 0) dx.push(0);
                else dx.push(100 * Math.abs(pdi - mdi) / div);
            }

            let adx = new Array(highs.length).fill(null);
            let startADXIdx = period * 2;

            if (dx.length >= startADXIdx) {
                let sumDX = 0;
                for(let i=period + 1; i<=startADXIdx; i++) sumDX += dx[i];
                adx[startADXIdx] = sumDX / period;

                for(let i=startADXIdx + 1; i<highs.length; i++) {
                    adx[i] = ((adx[i-1] * (period-1)) + dx[i]) / period;
                }
            }

            return { adx,
                pdi: smoothPDM.map((v,i) => i >= period && smoothTR[i] > 0 ? 100 * v/smoothTR[i] : (i<period ? null : 0)),
                mdi: smoothMDM.map((v,i) => i >= period && smoothTR[i] > 0 ? 100 * v/smoothTR[i] : (i<period ? null : 0))
            };
        }

        function calculateRecentHighLow(highs, lows, lookback = 250) {
            const recentHighs = highs.slice(Math.max(highs.length - lookback, 0));
            const recentLows = lows.slice(Math.max(lows.length - lookback, 0));

            const recentHigh = Math.max(...recentHighs);
            const recentLow = Math.min(...recentLows);

            return { recentHigh, recentLow };
        }

        // CMT-style pivot-based swing point detection
        // Identifies swing highs (pivot highs) and swing lows (pivot lows) following CMT methodology
        // Parameters:
        //   - lookback: days to analyze (default 504 = 2 years)
        //   - pivotBars: bars on each side required to confirm a pivot (default 5)
        //   - minRetracement: minimum price move to confirm pivot significance (default 3% = 0.03)
        //   - minSwingSeparation: minimum days between swing start and end (default 20)
        function findMeasuredTrendSwing(highs, lows, closes, dates, lookback = 504, pivotBars = 5, minRetracement = 0.03, minSwingSeparation = 20) {
            if (closes.length < Math.max(lookback, pivotBars * 2 + 1)) return null;

            const len = closes.length;
            const startIndex = Math.max(0, len - lookback);

            // Step 1: Identify pivot highs (swing highs) and pivot lows (swing lows)
            // A pivot high must be higher than pivotBars bars on both sides
            // A pivot low must be lower than pivotBars bars on both sides
            const pivotHighs = []; // {idx, high, close, date}
            const pivotLows = [];  // {idx, low, close, date}

            for (let i = startIndex + pivotBars; i < len - pivotBars; i++) {
                const currentHigh = highs[i];
                const currentLow = lows[i];
                const currentClose = closes[i];

                // Check for pivot high: must be higher than pivotBars bars on both sides
                let isPivotHigh = true;
                for (let j = i - pivotBars; j <= i + pivotBars; j++) {
                    if (j !== i && highs[j] >= currentHigh) {
                        isPivotHigh = false;
                        break;
                    }
                }
                if (isPivotHigh) {
                    pivotHighs.push({ idx: i, high: currentHigh, close: currentClose, date: dates[i] });
                }

                // Check for pivot low: must be lower than pivotBars bars on both sides
                let isPivotLow = true;
                for (let j = i - pivotBars; j <= i + pivotBars; j++) {
                    if (j !== i && lows[j] <= currentLow) {
                        isPivotLow = false;
                        break;
                    }
                }
                if (isPivotLow) {
                    pivotLows.push({ idx: i, low: currentLow, close: currentClose, date: dates[i] });
                }
            }

            if (pivotHighs.length === 0 || pivotLows.length === 0) {
                return null;
            }

            // Step 2: Filter pivots by minimum retracement requirement
            // Calculate average price range for context
            const priceRange = Math.max(...closes.slice(startIndex)) - Math.min(...closes.slice(startIndex));
            const avgPrice = closes.slice(startIndex).reduce((a, b) => a + b, 0) / (len - startIndex);
            const minMove = avgPrice * minRetracement;

            // Filter pivots: must represent a meaningful move
            const significantHighs = pivotHighs.filter(pivot => {
                // Check if this pivot represents a significant move from nearby pivots
                const nearbyLows = pivotLows.filter(l => Math.abs(l.idx - pivot.idx) <= 20);
                if (nearbyLows.length === 0) return true; // Keep if no nearby lows to compare
                const minNearbyLow = Math.min(...nearbyLows.map(l => l.close));
                return (pivot.close - minNearbyLow) >= minMove;
            });

            const significantLows = pivotLows.filter(pivot => {
                // Check if this pivot represents a significant move from nearby pivots
                const nearbyHighs = pivotHighs.filter(h => Math.abs(h.idx - pivot.idx) <= 20);
                if (nearbyHighs.length === 0) return true; // Keep if no nearby highs to compare
                const maxNearbyHigh = Math.max(...nearbyHighs.map(h => h.close));
                return (maxNearbyHigh - pivot.close) >= minMove;
            });

            if (significantHighs.length === 0 || significantLows.length === 0) {
                return null;
            }

            // Step 3: Evaluate all combinations to find the most significant swing
            // Score based on: price magnitude, time duration, and recency
            const potentialSwings = [];

            for (const high of significantHighs) {
                for (const low of significantLows) {
                    const daysBetween = Math.abs(high.idx - low.idx);
                    
                    // Must meet minimum time separation
                    if (daysBetween < minSwingSeparation) {
                        continue;
                    }

                    const swingRange = Math.abs(high.close - low.close);
                    
                    // Must represent significant price movement
                    if (swingRange < minMove) {
                        continue;
                    }

                    // Calculate significance score
                    // Price magnitude (normalized to price range): 50% weight
                    const priceMagnitude = swingRange / priceRange;
                    
                    // Duration score (normalized, caps at 100 days): 30% weight
                    const durationScore = Math.min(daysBetween / 100, 1.0);
                    
                    // Recency score (more recent = higher): 20% weight
                    const mostRecentIdx = Math.max(high.idx, low.idx);
                    const recencyScore = 1.0 - (mostRecentIdx - startIndex) / (len - startIndex);
                    
                    // Combined significance score
                    const significanceScore = (priceMagnitude * 0.5) + (durationScore * 0.3) + (recencyScore * 0.2);

                    potentialSwings.push({
                        high: high,
                        low: low,
                        swingRange: swingRange,
                        daysBetween: daysBetween,
                        significanceScore: significanceScore
                    });
                }
            }

            if (potentialSwings.length === 0) {
                return null;
            }

            // Step 4: Select the most significant swing (highest score)
            potentialSwings.sort((a, b) => b.significanceScore - a.significanceScore);
            const mostSignificantSwing = potentialSwings[0];

            // Step 5: Determine swing direction and return
            let startingPoint, endingPoint, startingDate, endingDate, startingType, endingType, measuredTrend;

            if (mostSignificantSwing.low.idx < mostSignificantSwing.high.idx) {
                // Low came first, then high - upward swing
                startingPoint = mostSignificantSwing.low.close;
                startingDate = mostSignificantSwing.low.date;
                startingType = 'Low';
                endingPoint = mostSignificantSwing.high.close;
                endingDate = mostSignificantSwing.high.date;
                endingType = 'High';
                measuredTrend = 'Upward';
            } else {
                // High came first, then low - downward swing
                startingPoint = mostSignificantSwing.high.close;
                startingDate = mostSignificantSwing.high.date;
                startingType = 'High';
                endingPoint = mostSignificantSwing.low.close;
                endingDate = mostSignificantSwing.low.date;
                endingType = 'Low';
                measuredTrend = 'Downward';
            }

            return {
                startingPoint: startingPoint,
                startingDate: startingDate,
                endingPoint: endingPoint,
                endingDate: endingDate,
                startingType: startingType,
                endingType: endingType,
                measuredTrend: measuredTrend,
                currentClose: closes[len - 1]
            };
        }


        function calculateDeMarkFibLevels(highs, lows, closes, dates) {
            if (closes.length < 3) return null;

            const swing = findMeasuredTrendSwing(highs, lows, closes, dates);
            if (!swing) return null;

            const startPrice = swing.startingPoint;
            const endPrice = swing.endingPoint;

            const totalRange = endPrice - startPrice;
            const absRange = Math.abs(totalRange);

            if (absRange === 0) return null;

            const fibRatios = [0.382, 0.50, 0.618];
            let retracementLevels = {
                measuredTrend: swing.measuredTrend,
                swingStart: startPrice,
                swingEndDate: swing.endingDate,
                swingEnd: endPrice,
                swingStartDate: swing.startingDate,
                swingStartType: swing.startingType,
                swingEndType: swing.endingType,
                currentClose: swing.currentClose,
                swingHigh: Math.max(startPrice, endPrice),
                swingLow: Math.min(startPrice, endPrice),
            };

            fibRatios.forEach(ratio => {
                const levelKey = (ratio * 100).toFixed(1) + '%';
                let levelPrice;

                if (swing.measuredTrend === 'Upward') {
                    levelPrice = endPrice - (absRange * ratio);
                }
else if (swing.measuredTrend === 'Downward') {
                    levelPrice = endPrice + (absRange * ratio);
                }

                retracementLevels[levelKey] = levelPrice;

                const distance = ((levelPrice - swing.currentClose) / swing.currentClose) * 100;
                retracementLevels[levelKey + 'Dist'] = distance;
            });

            return retracementLevels;
        }


        async function fetchCompanyName(ticker, apiKey) {
            const url = `https://api.twelvedata.com/quote?symbol=${ticker}&apikey=${apiKey}`;
            try {
                const result = await safeFetch(url);
                if (!result.ok) return `(${ticker})`;
                const json = result.data;
                if (json.status === "error" || !json.name) return `(${ticker})`;
                return `${ticker} - ${json.name}`;
            } catch (err) {
                return `(${ticker})`;
            }
        }

        async function fetchStockData(ticker, apiKey, interval) {
            const maxRetries = 3;
            let lastError = null;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const url = `https://api.twelvedata.com/time_series?symbol=${ticker}&interval=${interval}&apikey=${apiKey}&outputsize=5000`;
                    const result = await safeFetch(url);
                    if (!result.ok) throw new Error(`Status ${result.status}`);
                    const json = result.data;
                    if (json["status"] === "error") throw new Error(json["message"]);
                    if (!json["values"]) throw new Error('No data found');
                    const sortedData = json["values"].reverse();
                    let closes = [], highs = [], lows = [], dates = [];
                    sortedData.forEach(day => {
                        closes.push(parseFloat(day.close));
                        highs.push(parseFloat(day.high));
                        lows.push(parseFloat(day.low));
                        dates.push(day.datetime);
                    });
                    return { closes, highs, lows, dates };
                } catch (err) {
                    lastError = err;
                    if (attempt < maxRetries - 1) await new Promise(r => setTimeout(r, Math.pow(2, attempt) * 1000));
                }
            }
            throw lastError;
        }

        // Calculate dynamic thresholds based on historical data distribution
        function calculateDynamicThresholds(dailyIndicatorArrays, startIdx, endIdx, macdMonthlyData = null) {
            const { closes, macdData, sma200_arr, sd200_arr } = dailyIndicatorArrays;
            
            // Collect historical values for analysis
            const dist200Values = [];
            const macdHistValues = [];
            const macdSlopeValues = [];
            
            for (let i = startIdx; i < endIdx; i++) {
                if (sma200_arr[i] !== null && closes[i] !== null && closes[i] > sma200_arr[i]) {
                    // Only calculate percentage ABOVE 200-DMA (magnitude determines score, above is bullish)
                    const dist200 = ((closes[i] - sma200_arr[i]) / sma200_arr[i]) * 100;
                    dist200Values.push(dist200);
                }
                
                if (macdData.histogram[i] !== null) {
                    macdHistValues.push(Math.abs(macdData.histogram[i]));
                }
                
                if (macdData.slope[i] !== null) {
                    macdSlopeValues.push(Math.abs(macdData.slope[i]));
                }
            }
            
            // Calculate percentiles for dynamic thresholds
            const percentile = (arr, p) => {
                if (arr.length === 0) return null;
                const filtered = arr.filter(v => v !== null && v !== undefined && !isNaN(v));
                if (filtered.length === 0) return null;
                const sorted = [...filtered].sort((a, b) => a - b);
                const index = Math.floor((p / 100) * (sorted.length - 1));
                return sorted[Math.min(index, sorted.length - 1)];
            };
            
            // Price vs 200-DMA: Use 75th and 25th percentiles as dynamic thresholds
            const dist200_75th = percentile(dist200Values, 75);
            const dist200_25th = percentile(dist200Values, 25);
            const dist200_median = percentile(dist200Values, 50);
            const dist200_std = dist200Values.length > 1 ? 
                Math.sqrt(dist200Values.reduce((sum, val) => sum + Math.pow(val - dist200_median, 2), 0) / dist200Values.length) : 1;
            
            // MACD Histogram: Use 75th percentile as dynamic threshold for "near zero"
            const macdHist_75th = percentile(macdHistValues, 75);
            const macdHist_median = percentile(macdHistValues, 50);
            const macdHist_std = macdHistValues.length > 1 ?
                Math.sqrt(macdHistValues.reduce((sum, val) => sum + Math.pow(val - macdHist_median, 2), 0) / macdHistValues.length) : 0.02;
            
            // MACD Slope: Use 75th percentile as dynamic threshold
            const macdSlope_75th = percentile(macdSlopeValues, 75);
            const macdSlope_median = percentile(macdSlopeValues, 50);
            const macdSlope_std = macdSlopeValues.length > 1 ?
                Math.sqrt(macdSlopeValues.reduce((sum, val) => sum + Math.pow(val - macdSlope_median, 2), 0) / macdSlopeValues.length) : 0.005;
            
            // Calculate daily MACD thresholds first (needed for monthly threshold calculation)
            const macdHist_nearZeroThreshold = macdHist_75th !== null ? Math.max(0.01, macdHist_75th * 0.3) : 0.02;
            const macdSlope_threshold = macdSlope_75th !== null ? Math.max(0.002, macdSlope_75th * 0.5) : 0.005;
            
            // Monthly MACD thresholds: Calculate from historical monthly MACD data
            // Solution 1: Use array of monthly MACD values to calculate proper thresholds
            let macdMonthlyHist_nearZeroThreshold = 0.05;
            let macdMonthlyHist_std = 0.05;
            let macdMonthlySlope_threshold = 0.01;
            let macdMonthlySlope_std = 0.01;
            
            // Collect monthly MACD values from the array
            const monthlyHistValues = [];
            const monthlySlopeValues = [];
            
            if (Array.isArray(macdMonthlyData)) {
                // Extract monthly MACD values for the threshold calculation window
                for (let i = startIdx; i < endIdx; i++) {
                    if (macdMonthlyData[i] && macdMonthlyData[i].histogram !== null) {
                        monthlyHistValues.push(Math.abs(macdMonthlyData[i].histogram));
                    }
                    if (macdMonthlyData[i] && macdMonthlyData[i].slope !== null) {
                        monthlySlopeValues.push(Math.abs(macdMonthlyData[i].slope));
                    }
                }
            } else if (macdMonthlyData && macdMonthlyData.histogram !== null && macdMonthlyData.slope !== null) {
                // Fallback: Use single value if array not available (backward compatibility)
                monthlyHistValues.push(Math.abs(macdMonthlyData.histogram));
                monthlySlopeValues.push(Math.abs(macdMonthlyData.slope));
            }
            
            if (monthlyHistValues.length > 0 && monthlySlopeValues.length > 0) {
                // Calculate percentiles for monthly MACD thresholds
                const monthlyHist_75th = percentile(monthlyHistValues, 75);
                const monthlyHist_median = percentile(monthlyHistValues, 50);
                const monthlyHist_std_calc = monthlyHistValues.length > 1 ?
                    Math.sqrt(monthlyHistValues.reduce((sum, val) => sum + Math.pow(val - monthlyHist_median, 2), 0) / monthlyHistValues.length) : 0.05;
                
                const monthlySlope_75th = percentile(monthlySlopeValues, 75);
                const monthlySlope_median = percentile(monthlySlopeValues, 50);
                const monthlySlope_std_calc = monthlySlopeValues.length > 1 ?
                    Math.sqrt(monthlySlopeValues.reduce((sum, val) => sum + Math.pow(val - monthlySlope_median, 2), 0) / monthlySlopeValues.length) : 0.01;
                
                macdMonthlyHist_nearZeroThreshold = monthlyHist_75th !== null ? Math.max(0.05, monthlyHist_75th * 0.3) : 0.05;
                macdMonthlyHist_std = monthlyHist_std_calc;
                macdMonthlySlope_threshold = monthlySlope_75th !== null ? Math.max(0.01, monthlySlope_75th * 0.5) : 0.01;
                macdMonthlySlope_std = monthlySlope_std_calc;
            } else {
                // Fallback: Scale daily thresholds for monthly (monthly values are typically 2-5x larger)
                macdMonthlyHist_nearZeroThreshold = macdHist_nearZeroThreshold * 2.5;
                macdMonthlyHist_std = macdHist_std * 2.5;
                macdMonthlySlope_threshold = macdSlope_threshold * 2.0;
                macdMonthlySlope_std = macdSlope_std * 2.0;
            }
            
            // Legacy fallback code removed - now using proper array-based calculation above
            if (false) {
                // Estimate monthly thresholds as scaled versions of daily thresholds
                // If monthly histogram is significantly larger, scale thresholds proportionally
                const histScaleFactor = monthlyHistAbs > 0 ? Math.max(1.5, Math.min(5.0, monthlyHistAbs / (macdHist_std + 0.01))) : 2.5;
                const slopeScaleFactor = monthlySlopeAbs > 0 ? Math.max(1.5, Math.min(5.0, monthlySlopeAbs / (macdSlope_std + 0.001))) : 2.0;
                
                macdMonthlyHist_nearZeroThreshold = Math.max(0.02, macdHist_nearZeroThreshold * histScaleFactor);
                macdMonthlyHist_std = Math.max(0.02, macdHist_std * histScaleFactor);
                macdMonthlySlope_threshold = Math.max(0.005, macdSlope_threshold * slopeScaleFactor);
                macdMonthlySlope_std = Math.max(0.005, macdSlope_std * slopeScaleFactor);
            }
            
            return {
                // Price vs 200-DMA thresholds (using percentiles and std dev)
                // With new formula: positive dist200 = price above 200-DMA (bullish), negative = below (bearish)
                // dist200_75th is higher values (more bullish/positive), dist200_25th is lower values (more bearish/negative)
                // Note: variable names are used backwards in code (bearishThresh for bullish, bullishThresh for bearish)
                dist200_bullishThreshold: dist200_25th !== null ? Math.min(-0.5, dist200_25th - dist200_std) : -1.0, // Used as bearish threshold (negative, lower bound)
                dist200_bearishThreshold: dist200_75th !== null ? Math.max(0.5, dist200_75th + dist200_std) : 1.0, // Used as bullish threshold (positive, upper bound)
                dist200_std: dist200_std || 1.0,
                
                // MACD Histogram thresholds (daily)
                macdHist_nearZeroThreshold: macdHist_nearZeroThreshold,
                macdHist_std: macdHist_std || 0.02,
                
                // MACD Slope thresholds (daily)
                macdSlope_threshold: macdSlope_threshold,
                macdSlope_std: macdSlope_std || 0.005,
                
                // MACD Monthly thresholds
                macdMonthlyHist_nearZeroThreshold: macdMonthlyHist_nearZeroThreshold,
                macdMonthlyHist_std: macdMonthlyHist_std,
                macdMonthlySlope_threshold: macdMonthlySlope_threshold,
                macdMonthlySlope_std: macdMonthlySlope_std
            };
        }

        // Solution 1: Create monthly MACD array mapped to daily dates
        // Maps each daily date to its corresponding month's MACD values
        function createMonthlyMACDArray(dailyDates, monthlyDates, monthlyMACDData) {
            const monthlyMACDArray = [];
            const monthlyMACDByDate = new Map();
            
            // Create a map of month-year to MACD values
            for (let i = 0; i < monthlyDates.length; i++) {
                const monthDate = new Date(monthlyDates[i]);
                const monthKey = `${monthDate.getFullYear()}-${monthDate.getMonth()}`;
                
                // Get MACD values for this month
                const histVal = monthlyMACDData.histogram[i];
                const slopeVal = monthlyMACDData.slope[i];
                const macdLine = monthlyMACDData.macdLine[i];
                const signalLine = monthlyMACDData.signalLine[i];
                
                monthlyMACDByDate.set(monthKey, {
                    histogram: histVal,
                    slope: slopeVal,
                    macdLine: macdLine,
                    signalLine: signalLine,
                    signal: (macdLine !== null && signalLine !== null) 
                        ? (macdLine > signalLine ? 1 : (macdLine < signalLine ? -1 : 0))
                        : 0
                });
            }
            
            // Map each daily date to its month's MACD values
            for (let i = 0; i < dailyDates.length; i++) {
                const dailyDate = new Date(dailyDates[i]);
                const monthKey = `${dailyDate.getFullYear()}-${dailyDate.getMonth()}`;
                
                // Find the most recent month with MACD data (in case of gaps)
                let macdData = monthlyMACDByDate.get(monthKey);
                if (!macdData) {
                    // Look for previous months
                    let found = false;
                    for (let lookback = 1; lookback <= 3 && !found; lookback++) {
                        const prevDate = new Date(dailyDate);
                        prevDate.setMonth(prevDate.getMonth() - lookback);
                        const prevMonthKey = `${prevDate.getFullYear()}-${prevDate.getMonth()}`;
                        macdData = monthlyMACDByDate.get(prevMonthKey);
                        if (macdData) found = true;
                    }
                }
                
                monthlyMACDArray.push(macdData || {
                    histogram: null,
                    slope: null,
                    macdLine: null,
                    signalLine: null,
                    signal: 0
                });
            }
            
            return monthlyMACDArray;
        }

        function getRawIndicatorScores(i, dailyIndicatorArrays, macdMonthlyData = null, dynamicThresholds = null, macdRawScoresHistory = null) {
            const { closes, highs, lows, rsiArr, macdData, upperBBs, lowerBBs, adxData, sma50_arr, sd50_arr, sma200_arr, sd200_arr, atrArray } = dailyIndicatorArrays;

            const currentPrice_i = closes[i];
            const rsiVal_i = rsiArr[i];
            const macdLine_i = macdData.macdLine[i];
            const signalLine_i = macdData.signalLine[i];
            const histVal_i = macdData.histogram[i];
            const slopeVal_i = macdData.slope[i];
            const upperBB_i = upperBBs[i];
            const lowerBB_i = lowerBBs[i];
            const adxVal_i = adxData.adx[i];
            const pdiVal_i = adxData.pdi[i];
            const mdiVal_i = adxData.mdi[i];
            const sma50_i = sma50_arr[i];
            const sd50_i = sd50_arr[i];
            const sma200_i = sma200_arr[i];
            const sd200_i = sd200_arr[i];

            const bbRange_i = upperBB_i !== null && lowerBB_i !== null ? upperBB_i - lowerBB_i : 0;
            const pctB_i = bbRange_i === 0 ? 0.5 : (currentPrice_i - lowerBB_i) / bbRange_i;
            // Calculate percentage ABOVE 200-DMA only (magnitude determines score, above is bullish)
            // If price is below 200-DMA, this will be 0 or negative
            const dist200_i = sma200_i && currentPrice_i > sma200_i ? ((currentPrice_i - sma200_i) / sma200_i) * 100 : (sma200_i && currentPrice_i <= sma200_i ? 0 : null);
            // Use 50-day MA z-score instead of 200-day MA z-score for the indicator
            const zScoreVal_i = (sma50_i && sd50_i) ? (currentPrice_i - sma50_i) / sd50_i : null;

            // Solution 1: Get monthly MACD values for this specific day (from array)
            // macdMonthlyData can be either an array (per-day values) or object (single current value for backward compatibility)
            let monthlyMACDForDay = null;
            if (Array.isArray(macdMonthlyData)) {
                monthlyMACDForDay = macdMonthlyData[i] || null;
            } else if (macdMonthlyData) {
                monthlyMACDForDay = macdMonthlyData;
            }

            // Detect volatility regime for dynamic MACD weights
            const atrValue = atrArray && atrArray[i] !== null ? atrArray[i] : null;
            const volatilityRegime = detectVolatilityRegime(atrValue, atrArray, i, closes, 20);
            const macdWeights = getDynamicMACDWeights(volatilityRegime);
            
            // Store volatility regime for breakdown display
            const volatilityRegimeForBreakdown = volatilityRegime;
            
            // Calculate adaptive normalization parameters from rolling window of raw scores
            // Use separate normalization for monthly and daily MACD (they may have different distributions)
            let monthlyNormParams = null;
            let dailyNormParams = null;
            
            if (macdRawScoresHistory) {
                // Monthly MACD normalization
                if (macdRawScoresHistory.monthly && macdRawScoresHistory.monthly.length > 0) {
                    monthlyNormParams = calculateAdaptiveNormalization(macdRawScoresHistory.monthly, 252);
                }
                // Daily MACD normalization
                if (macdRawScoresHistory.daily && macdRawScoresHistory.daily.length > 0) {
                    dailyNormParams = calculateAdaptiveNormalization(macdRawScoresHistory.daily, 252);
                }
            }

            // New MACD Calibration Scoring System for Monthly MACD
            let s_macd_m = 0;
            let macd_m_breakdown = null;
            if (monthlyMACDForDay && monthlyMACDForDay.macdLine !== null && monthlyMACDForDay.signalLine !== null) {
                const macdLine_m = monthlyMACDForDay.macdLine;
                const signalLine_m = monthlyMACDForDay.signalLine;
                const histVal_m = monthlyMACDForDay.histogram;
                const macdSlope_m = monthlyMACDForDay.slope; // MACD line slope
                
                // Calculate histogram slope (change in histogram)
                let histogramSlope_m = null;
                if (Array.isArray(macdMonthlyData) && i > 0 && macdMonthlyData[i - 1]) {
                    const prevHist = macdMonthlyData[i - 1].histogram;
                    if (prevHist !== null && histVal_m !== null) {
                        histogramSlope_m = histVal_m - prevHist;
                    }
                }
                
                // Extract monthly MACD arrays for cross detection
                let monthlyMacdLineArray = null;
                let monthlySignalLineArray = null;
                if (Array.isArray(macdMonthlyData) && macdMonthlyData.length > 0) {
                    monthlyMacdLineArray = macdMonthlyData.map(m => m.macdLine !== null ? m.macdLine : null);
                    monthlySignalLineArray = macdMonthlyData.map(m => m.signalLine !== null ? m.signalLine : null);
                }
                
                const macd_m_result = calculateMACDCalibratedScore(
                    macdLine_m,
                    signalLine_m,
                    histVal_m,
                    histogramSlope_m || macdSlope_m, // Use MACD slope as fallback for histogram slope
                    monthlyMacdLineArray,
                    monthlySignalLineArray,
                    i,
                    10, // lookback bars
                    macdWeights, // Pass dynamic weights based on volatility regime
                    volatilityRegimeForBreakdown, // Pass volatility regime name
                    monthlyNormParams // Pass adaptive normalization parameters
                );
                s_macd_m = macd_m_result.score;
                macd_m_breakdown = macd_m_result.breakdown;
            } else if (monthlyMACDForDay && monthlyMACDForDay.signal !== undefined) {
                // Fallback to simple signal if data not available
                s_macd_m = monthlyMACDForDay.signal;
            }

            // New MACD Calibration Scoring System for Daily MACD
            let s_macd_d = 0;
            let macd_d_breakdown = null;
            if (macdLine_i !== null && signalLine_i !== null && histVal_i !== null) {
                // Calculate histogram slope (change in histogram)
                let histogramSlope_d = null;
                if (i > 0 && macdData.histogram[i - 1] !== null) {
                    histogramSlope_d = histVal_i - macdData.histogram[i - 1];
                } else if (slopeVal_i !== null) {
                    // Fallback: use MACD line slope as approximation for histogram slope
                    histogramSlope_d = slopeVal_i;
                }
                
                // Use MACD arrays for cross detection
                const macdLineArray = macdData.macdLine;
                const signalLineArray = macdData.signalLine;
                
                const macd_d_result = calculateMACDCalibratedScore(
                    macdLine_i,
                    signalLine_i,
                    histVal_i,
                    histogramSlope_d || slopeVal_i, // Use histogram slope or MACD slope as fallback
                    macdLineArray,
                    signalLineArray,
                    i,
                    10, // lookback bars
                    macdWeights, // Pass dynamic weights based on volatility regime
                    volatilityRegimeForBreakdown, // Pass volatility regime name
                    dailyNormParams // Pass adaptive normalization parameters
                );
                s_macd_d = macd_d_result.score;
                macd_d_breakdown = macd_d_result.breakdown;
                
                // Store raw score for normalization calculation (if history tracking enabled)
                if (macdRawScoresHistory && macdRawScoresHistory.daily) {
                    macdRawScoresHistory.daily.push(macd_d_result.breakdown.totalRawScore);
                    // Keep only last 252 scores (1 year rolling window)
                    if (macdRawScoresHistory.daily.length > 252) {
                        macdRawScoresHistory.daily.shift();
                    }
                }
            }
            
            // Store monthly raw score if available
            if (macd_m_breakdown && macdRawScoresHistory && macdRawScoresHistory.monthly) {
                macdRawScoresHistory.monthly.push(macd_m_breakdown.totalRawScore);
                // Keep only last 252 scores (1 year rolling window)
                if (macdRawScoresHistory.monthly.length > 252) {
                    macdRawScoresHistory.monthly.shift();
                }
            }

            let s_rsi = 0;
            if (rsiVal_i !== null) {
                s_rsi = (50 - rsiVal_i) / 50;
            }

            // CMT-Aligned ADX/DI Scoring System
            let s_adx = 0;
            if (adxVal_i !== null && pdiVal_i !== null && mdiVal_i !== null) {
                // Step 1: ADX Regime Filter (CMT Principle #2)
                // ADX < 20 = no trend / noise - return 0
                if (adxVal_i < 20) {
                    // ADX 15-20 = transition zone - give partial credit
                    if (adxVal_i >= 15) {
                        const transitionMultiplier = (adxVal_i - 15) / 5; // 0 to 1 as ADX goes from 15 to 20
                        // Calculate base score with transition multiplier
                        if (pdiVal_i > mdiVal_i) {
                            s_adx = (adxVal_i / 50) * transitionMultiplier;
                        } else if (mdiVal_i > pdiVal_i) {
                            s_adx = -1 * (adxVal_i / 50) * transitionMultiplier;
                        }
                    }
                    // ADX < 15 = 0 (no trend)
                } else {
                    // ADX >= 20: Full scoring with CMT enhancements
                    
                    // Step 2: Calculate ADX Slope (CMT Principle #4 - Most Important)
                    let adxSlope = 0;
                    if (adxData.adx && i > 0 && adxData.adx[i] !== null && adxData.adx[i - 1] !== null) {
                        adxSlope = adxData.adx[i] - adxData.adx[i - 1];
                    }
                    
                    // Step 3: ADX Extremes Risk Management (CMT Principle #7)
                    let riskAdjustment = 1.0;
                    if (adxVal_i > 40) {
                        // Late-stage / exhaustion risk - reduce score by 30%
                        riskAdjustment = 0.7;
                    } else if (adxVal_i > 30) {
                        // Strong trend but maturing - reduce score by 15%
                        riskAdjustment = 0.85;
                    }
                    
                    // Step 4: ADX Slope Multiplier (CMT Principle #4)
                    let slopeMultiplier = 1.0;
                    if (adxSlope > 0.5) {
                        // Rising ADX = permission - boost score
                        slopeMultiplier = 1.2;
                    } else if (adxSlope < -0.5) {
                        // Falling ADX = caution - reduce score
                        slopeMultiplier = 0.6;
                    }
                    
                    // Step 5: DI Separation Analysis (CMT Principle #6)
                    const diSeparation = Math.abs(pdiVal_i - mdiVal_i);
                    const avgSeparation = 15; // Typical separation threshold
                    
                    let separationMultiplier = 1.0;
                    if (diSeparation > avgSeparation * 1.5) {
                        // Wide separation = dominance
                        separationMultiplier = 1.15;
                    } else if (diSeparation < avgSeparation * 0.5) {
                        // Narrow separation = transition/compression
                        separationMultiplier = 0.7;
                    }
                    
                    // Step 6: DI Expansion/Compression (CMT Principle #3)
                    let diExpansionMultiplier = 1.0;
                    if (adxData.pdi && adxData.mdi && i > 0 && 
                        adxData.pdi[i - 1] !== null && adxData.mdi[i - 1] !== null) {
                        const prevPDI = adxData.pdi[i - 1];
                        const prevMDI = adxData.mdi[i - 1];
                        
                        if (pdiVal_i > mdiVal_i) {
                            // Bullish: Check if +DI expanding and -DI compressing
                            const pdiExpanding = pdiVal_i > prevPDI;
                            const mdiCompressing = mdiVal_i < prevMDI;
                            if (pdiExpanding && mdiCompressing) {
                                diExpansionMultiplier = 1.2; // Strong control
                            } else if (pdiExpanding || mdiCompressing) {
                                diExpansionMultiplier = 1.1; // Moderate control
                            }
                        } else if (mdiVal_i > pdiVal_i) {
                            // Bearish: Check if -DI expanding and +DI compressing
                            const mdiExpanding = mdiVal_i > prevMDI;
                            const pdiCompressing = pdiVal_i < prevPDI;
                            if (mdiExpanding && pdiCompressing) {
                                diExpansionMultiplier = 1.2; // Strong control
                            } else if (mdiExpanding || pdiCompressing) {
                                diExpansionMultiplier = 1.1; // Moderate control
                            }
                        }
                    }
                    
                    // Step 7: Base Score Calculation with Weighted DI Dominance
                    let baseScore = 0;
                    if (pdiVal_i > mdiVal_i) {
                        // Bullish bias - weighted by DI dominance ratio
                        const diRatio = pdiVal_i / (pdiVal_i + mdiVal_i);
                        baseScore = (adxVal_i / 50) * diRatio;
                    } else if (mdiVal_i > pdiVal_i) {
                        // Bearish bias - weighted by DI dominance ratio
                        const diRatio = mdiVal_i / (pdiVal_i + mdiVal_i);
                        baseScore = -1 * (adxVal_i / 50) * diRatio;
                    }
                    
                    // Step 8: Apply All Multipliers
                    s_adx = baseScore * riskAdjustment * slopeMultiplier * separationMultiplier * diExpansionMultiplier;
                }
                
                // Clamp to reasonable bounds
                s_adx = Math.max(-1.0, Math.min(1.0, s_adx));
            }

            let s_bb = 0;
            if (upperBB_i !== null && lowerBB_i !== null) {
                if (pctB_i > 1.05) s_bb = -1;
                else if (pctB_i < -0.05) s_bb = 1;
                else if (pctB_i > 0.8) s_bb = -0.25;
                else if (pctB_i < 0.2) s_bb = 0.25;
            }

            let s_ma200_dist = 0;
            // Calculate full distance (both positive and negative) relative to 200-DMA
            // Use existing sma200_i and currentPrice_i variables from earlier in the function
            
            if (sma200_i !== null && currentPrice_i !== null && sma200_i > 0) {
                // Calculate percentage distance: positive = above, negative = below
                const percentageDistance = ((currentPrice_i - sma200_i) / sma200_i) * 100;
                
                // Scale linearly from +10% to -10%: +10% = +1, 0% = 0, -10% = -1
                // Formula: score = (percentage_distance / 10)
                s_ma200_dist = percentageDistance / 10;
                
                // Clamp between -1 and +1
                s_ma200_dist = Math.max(-1, Math.min(1, s_ma200_dist));
            }

            let s_zscore = 0;
            if (zScoreVal_i !== null) {
                if (zScoreVal_i > 1 || zScoreVal_i < -1) {
                    // Outside range [-1, 1]: use raw scaling
                    s_zscore = zScoreVal_i / (-2);
                } else {
                    // Inside range [-1, 1]: use 50% scaling
                    s_zscore = 0.5 * (zScoreVal_i / (-2));
                }
            }

            return {
                macd_m: s_macd_m,
                macd_d: s_macd_d,
                rsi: s_rsi,
                adx: s_adx,
                bb: s_bb,
                ma200_dist: s_ma200_dist,
                zscore: s_zscore,
                macd_m_breakdown: macd_m_breakdown,
                macd_d_breakdown: macd_d_breakdown
            };
        }

        function renderChart(dates, closes, sma50, sma100, sma200, sma1050, upperBBs, lowerBBs, fibLevels, historicalDates = null, historicalScores = null) {
            const ctx = document.getElementById('priceChart').getContext('2d');

            if (priceChartInstance) {
                priceChartInstance.destroy();
            }

            // Limit main chart to maximum 2 years of data (~500 trading days)
            const maxDataPoints = 500;
            let filteredDates = dates;
            let filteredCloses = closes;
            let filteredSma50 = sma50;
            let filteredSma100 = sma100;
            let filteredSma200 = sma200;
            let filteredSma1050 = sma1050;
            let filteredUpperBBs = upperBBs;
            let filteredLowerBBs = lowerBBs;

            if (dates.length > maxDataPoints) {
                const startIdx = dates.length - maxDataPoints;
                filteredDates = dates.slice(startIdx);
                filteredCloses = closes.slice(startIdx);
                filteredSma50 = sma50.slice(startIdx);
                filteredSma100 = sma100.slice(startIdx);
                filteredSma200 = sma200.slice(startIdx);
                filteredSma1050 = sma1050.slice(startIdx);
                filteredUpperBBs = upperBBs.slice(startIdx);
                filteredLowerBBs = lowerBBs.slice(startIdx);
            }

            let swingLineData = [];
            let fibDatasets = [];
            const fibLabels = ['38.2%', '50.0%', '61.8%'];

            // fibColors is now defined globally

            if (fibLevels && fibLevels.measuredTrend !== 'Neutral') {
                const startDate = fibLevels.swingStartDate;
                const endDate = fibLevels.swingEndDate;
                const startPrice = fibLevels.swingStart;
                const endPrice = fibLevels.swingEnd;

                let startIdx = filteredDates.indexOf(startDate);
                let endIdx = filteredDates.indexOf(endDate);

                if (startIdx !== -1 && endIdx !== -1) {
                    swingLineData = new Array(filteredDates.length).fill(null);
                    swingLineData[startIdx] = startPrice;
                    swingLineData[endIdx] = endPrice;

                    fibDatasets.push({
                        label: 'Measured Swing Line',
                        data: swingLineData,
                        borderColor: '#9ca3af',
                        borderWidth: 1.5,
                        pointRadius: 3,
                        pointBackgroundColor: '#9ca3af',
                        fill: false,
                        yAxisID: 'y',
                        spanGaps: true
                    });

                    fibLabels.forEach(label => {
                        const levelPrice = fibLevels[label];
                        let fibLevelData = new Array(filteredDates.length).fill(null);
                        const lineLength = 10;
                        for(let i = filteredDates.length - lineLength; i < filteredDates.length; i++) {
                            fibLevelData[i] = levelPrice;
                        }

                        fibDatasets.push({
                            label: `Fib ${label}`,
                            data: fibLevelData,
                            borderColor: fibColors[label],
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            yAxisID: 'y',
                        });
                    });
                }
            }

            // Prepare signal history data for overlay
            let signalHistoryData = new Array(filteredDates.length).fill(null);
            if (historicalDates && historicalScores && historicalDates.length === historicalScores.length) {
                // Align signal scores with price chart dates
                for (let i = 0; i < filteredDates.length; i++) {
                    const date = filteredDates[i];
                    const signalIdx = historicalDates.indexOf(date);
                    if (signalIdx !== -1 && signalIdx < historicalScores.length) {
                        signalHistoryData[i] = historicalScores[signalIdx];
                    }
                }
            }

            const chartData = {
                labels: filteredDates,
                datasets: [
                    {
                        label: 'BB Range Base',
                        data: filteredLowerBBs,
                        borderColor: 'transparent',
                        borderWidth: 0,
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y',
                    },
                    {
                        label: 'Bollinger Band Range (20D)',
                        data: filteredUpperBBs,
                        borderColor: 'transparent',
                        borderWidth: 0,
                        pointRadius: 0,
                        fill: {
                            target: '-1',
                            above: 'rgba(59, 130, 246, 0.15)'
                        },
                        yAxisID: 'y',
                    },
                    ...fibDatasets,
                    {
                        label: '50-Month MA',
                        data: filteredSma1050,
                        borderColor: '#a855f7', // purple
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y',
                        hidden: true, // Turned off by default
                    },
                    {
                        label: '200-DMA',
                        data: filteredSma200,
                        borderColor: '#3b82f6', // blue
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y',
                    },
                    {
                        label: '100-DMA',
                        data: filteredSma100,
                        borderColor: '#fde047', // light yellow
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y',
                    },
                    {
                        label: '50-DMA',
                        data: filteredSma50,
                        borderColor: '#ef4444', // red
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y',
                    },
                    {
                        label: 'Closing Price',
                        data: filteredCloses,
                        borderColor: '#ffffff',
                        borderWidth: 2.5,
                        pointRadius: 0,
                        fill: false,
                        yAxisID: 'y',
                    },
                    {
                        label: 'Signal Score',
                        data: signalHistoryData,
                        type: 'bar',
                        backgroundColor: function(context) {
                            const value = context.parsed.y;
                            if (value === null || value === 0) return 'transparent';
                            // Faint bars: green for positive, red for negative (30% opacity)
                            if (value > 0) {
                                return 'rgba(16, 185, 129, 0.30)'; // 30% opacity green
                            } else {
                                return 'rgba(239, 68, 68, 0.30)'; // 30% opacity red
                            }
                        },
                        borderColor: 'transparent',
                        borderWidth: 0,
                        yAxisID: 'y1', // Use secondary y-axis (hidden)
                        base: 0, // Bars start from zero line
                        barPercentage: 0.6, // Make bars slightly narrower
                        categoryPercentage: 0.8,
                    }
                ]
            };

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        ticks: {
                            color: '#9ca3af',
                            maxTicksLimit: 10,
                            font: {
                                size: 10
                            },
                            padding: 2,
                            callback: function(value, index) {
                                const date = new Date(this.getLabelForValue(value));
                                const year = date.getFullYear();
                                const month = date.getMonth() + 1;
                                const day = date.getDate();
                                // Show full date in compact format: MM/DD/YY
                                return `${month.toString().padStart(2, '0')}/${day.toString().padStart(2, '0')}/${year.toString().slice(-2)}`;
                            }
                        },
                        grid: {
                            color: 'rgba(75, 85, 99, 0.3)',
                            drawBorder: false
                        }
                    },
                    y: {
                        position: 'right',
                        type: 'linear',
                        display: true,
                        ticks: {
                            color: '#9ca3af',
                            callback: function(value) {
                                return '$' + value.toFixed(2);
                            }
                        },
                        grid: {
                            color: 'rgba(75, 85, 99, 0.3)',
                            drawBorder: false
                        },
                    },
                    y1: {
                        type: 'linear',
                        display: false, // Hide the axis
                        position: 'left',
                        ticks: {
                            display: false, // Hide ticks
                        },
                        grid: {
                            drawOnChartArea: false, // Don't draw grid lines
                            drawBorder: false
                        },
                        // Keep the scale for proper bar positioning
                        min: -1,
                        max: 1,
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#e5e7eb',
                            usePointStyle: true,
                            font: {
                                size: 9
                            },
                            boxWidth: 10,
                            padding: 6
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1f2937',
                        titleColor: '#e5e7eb',
                        bodyColor: '#e5e7eb',
                        borderColor: '#4b5563',
                        borderWidth: 1,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';

                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    // Format differently for signal score vs price
                                    if (context.dataset.label === 'Signal Score') {
                                        label += (context.parsed.y * 100).toFixed(1) + '%';
                                    } else {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                }
                                return label;
                            }
                        }
                    }
                }
            };

            priceChartInstance = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: chartOptions,
            });
        }

        function renderMACDChart(elementId, dates, macdData, timeframe) {
            const ctx = document.getElementById(elementId).getContext('2d');

            if (elementId === 'dailyMacdChart' && dailyMacdChartInstance) {
                dailyMacdChartInstance.destroy();
            } else if (elementId === 'monthlyMacdChart' && monthlyMacdChartInstance) {
                monthlyMacdChartInstance.destroy();
            }

            // Limit both daily and monthly charts to maximum 5 years of data
            let filteredDates = dates;
            let filteredMacdData = macdData;

            if (timeframe === 'monthly' && dates.length > 60) {
                // 5 years = 60 months for monthly data
                const startIdx = dates.length - 60;
                filteredDates = dates.slice(startIdx);
                filteredMacdData = {
                    histogram: macdData.histogram.slice(startIdx),
                    signalLine: macdData.signalLine.slice(startIdx),
                    macdLine: macdData.macdLine.slice(startIdx),
                    slope: macdData.slope.slice(startIdx)
                };
            } else if (timeframe === 'daily' && dates.length > 500) {
                // 2 years = ~500 trading days for daily data
                const startIdx = dates.length - 500;
                filteredDates = dates.slice(startIdx);
                filteredMacdData = {
                    histogram: macdData.histogram.slice(startIdx),
                    signalLine: macdData.signalLine.slice(startIdx),
                    macdLine: macdData.macdLine.slice(startIdx),
                    slope: macdData.slope.slice(startIdx)
                };
            }

            const histogramColors = filteredMacdData.histogram.map(val =>
                val === null ? 'rgba(0,0,0,0)' : (val >= 0 ? 'rgba(52, 211, 153, 0.7)' : 'rgba(251, 113, 113, 0.7)')
            );

            const chartData = {
                labels: filteredDates,
                datasets: [
                    {
                        type: 'bar',
                        label: 'Histogram',
                        data: filteredMacdData.histogram,
                        backgroundColor: histogramColors,
                        borderColor: histogramColors.map(c => c.replace('0.7', '1')),
                        borderWidth: 1,
                        order: 2,
                        yAxisID: 'y'
                    },
                    {
                        type: 'line',
                        label: 'Signal Line (9 EMA)',
                        data: filteredMacdData.signalLine,
                        borderColor: '#f59e0b',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        order: 1,
                        yAxisID: 'y'
                    },
                    {
                        type: 'line',
                        label: 'MACD Line (12 EMA - 26 EMA)',
                        data: filteredMacdData.macdLine,
                        borderColor: '#3b82f6',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        order: 1,
                        yAxisID: 'y'
                    }
                ]
            };

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        ticks: {
                            color: '#9ca3af',
                            maxTicksLimit: 8,
                            font: {
                                size: 10
                            },
                            padding: 2,
                            callback: function(val, index) {
                                const date = new Date(this.getLabelForValue(val));
                                const year = date.getFullYear();
                                const month = date.getMonth() + 1;
                                const day = date.getDate();

                                if (timeframe === 'daily') {
                                    // For daily charts, show dates at regular intervals
                                    if (index % 15 === 0) { // Show every ~15 days for better visibility
                                        return `${month.toString().padStart(2, '0')}/${day.toString().padStart(2, '0')}/${year.toString().slice(-2)}`;
                                    }
                                    return null; // Don't show label for this tick
                                } else {
                                    // For monthly charts, show year and month
                                    if (month === 1) {
                                        return `${year}`;
                                    } else if (index % 3 === 0) { // Show every quarter
                                        return `${month.toString().padStart(2, '0')}/${year.toString().slice(-2)}`;
                                    }
                                    return null;
                                }
                            }
                        },
                        grid: {
                            color: 'rgba(75, 85, 99, 0.3)',
                            drawBorder: false
                        }
                    },
                    y: {
                        position: 'right',
                        ticks: {
                            color: '#9ca3af',
                            callback: function(value) {
                                return value.toFixed(2);
                            }
                        },
                        grid: {
                            color: 'rgba(75, 85, 99, 0.3)',
                            drawBorder: false
                        },
                        beginAtZero: true,
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#e5e7eb',
                            font: {
                                size: 11
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1f2937',
                        titleColor: '#e5e7eb',
                        bodyColor: '#e5e7eb',
                        borderColor: '#4b5563',
                        borderWidth: 1,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';

                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += context.parsed.y.toFixed(4);
                                }
                                return label;
                            }
                        }
                    }
                }
            };

            const newInstance = new Chart(ctx, {
                data: chartData,
                options: chartOptions,
            });

            if (elementId === 'dailyMacdChart') {
                dailyMacdChartInstance = newInstance;
            } else if (elementId === 'monthlyMacdChart') {
                monthlyMacdChartInstance = newInstance;
            }
        }

        function renderScoreTimeSeriesChart(dates, scores) {
            const canvas = document.getElementById('scoreTimeSeriesChart');
            if (!canvas) {
                console.error('Score chart canvas not found');
                return;
            }
            const ctx = canvas.getContext('2d');

            if (scoreTimeSeriesChartInstance) {
                scoreTimeSeriesChartInstance.destroy();
            }

            // Limit to last 100 days for better visibility
            const maxDays = 100;
            const startIdx = Math.max(0, dates.length - maxDays);
            const limitedDates = dates.slice(startIdx);
            const limitedScores = scores.slice(startIdx);

            if (limitedScores.length === 0) {
                console.warn('No score data to display');
                return;
            }

            const BULLISH_20 = 0.10; // Modified from 0.20 to 0.10
            const BEARISH_0 = -0.05;

            const barColors = limitedScores.map(score => {
                if (score >= BULLISH_20) return 'rgba(74, 222, 128, 0.8)';
                if (score < BEARISH_0) return 'rgba(248, 113, 113, 0.8)';
                if (score > 0) return 'rgba(45, 212, 191, 0.8)';
                return 'rgba(251, 191, 36, 0.8)';
            });

            const chartData = {
                labels: limitedDates,
                datasets: [{
                    type: 'bar',
                    label: 'Composite Score',
                    data: limitedScores.map(s => s * 100),
                    backgroundColor: barColors,
                    borderColor: barColors.map(c => c.replace('0.8', '1')),
                    borderWidth: 1,
                    yAxisID: 'y'
                }]
            };

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        display: false,
                        grid: {
                            display: false,
                        }
                    },
                    y: {
                        position: 'right',
                        grid: {
                            color: 'rgba(75, 85, 99, 0.3)',
                            drawBorder: false
                        },
                        ticks: {
                            color: '#9ca3af',
                            callback: function(value) {
                                return value.toFixed(0) + '%';
                            }
                        },
                        beginAtZero: false, // Allow y-axis to scale based on data range for better visibility
                    },
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: '#1f2937',
                        titleColor: '#e5e7eb',
                        bodyColor: '#e5e7eb',
                        borderColor: '#4b5563',
                        borderWidth: 1,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += (context.parsed.y > 0 ? '+' : '') + context.parsed.y.toFixed(1) + '%';
                                }
                                return label;
                            },
                            title: function(context) {
                                return context[0].label;
                            }
                        }
                    }
                }
            };

            scoreTimeSeriesChartInstance = new Chart(ctx, {
                data: chartData,
                options: chartOptions,
            });
        }

        function renderRSIBar(rsiValue) {
            const rsi = Math.max(0, Math.min(100, rsiValue));
            const markerPosition = rsi.toFixed(1);
            let textColor = 'text-blue-400';
            let markerColor = '#3b82f6';

            if (rsi < 30) {
                textColor = 'text-green-400';
                markerColor = '#4ade80';
            } else if (rsi > 70) {
                textColor = 'text-red-400';
                markerColor = '#f87171';
            }

            return `
                <div class="space-y-1">
                    <div class="flex justify-center">
                        <div class="text-xs font-extrabold ${textColor}">${rsiValue.toFixed(2)}</div>
                    </div>
                    <div class="relative h-1 w-full rounded-full overflow-hidden bg-gray-700/50">
                        <div class="absolute inset-y-0" style="width: 30%; background-color: rgba(74, 222, 128, 0.4);"></div>
                        <div class="absolute inset-y-0" style="left: 30%; width: 40%; background-color: rgba(59, 130, 246, 0.4);"></div>
                        <div class="absolute inset-y-0" style="left: 70%; width: 30%; background-color: rgba(248, 113, 113, 0.4);"></div>
                        <div class="absolute h-2 w-0.5 rounded-full" style="background-color: ${markerColor}; left: ${markerPosition}%; transform: translate(-50%, -25%); top: 0;">
                        </div>
                    </div>
                    <div class="flex justify-between text-xs text-gray-400/70 font-mono">
                        <span>0</span>
                        <span>50</span>
                        <span>100</span>
                    </div>
                </div>
            `;
        }

        // Compact 1-line quartile bar for score distributions (min..max split into 4 quartiles),
        // with a marker showing where the current score falls.
        function renderScoreQuartileBar({ min, q1, q2, q3, max, current }) {
            const safe = (v) => (typeof v === 'number' && Number.isFinite(v)) ? v : null;
            const minV = safe(min), q1V = safe(q1), q2V = safe(q2), q3V = safe(q3), maxV = safe(max), curV = safe(current);
            if (minV === null || maxV === null || curV === null) return '<span class="text-gray-400">N/A</span>';

            const range = (maxV - minV) === 0 ? 1 : (maxV - minV);
            const clamp01 = (x) => Math.max(0, Math.min(1, x));
            const pct = (x) => (clamp01((x - minV) / range) * 100);

            const q1P = q1V === null ? null : pct(q1V);
            const q2P = q2V === null ? null : pct(q2V);
            const q3P = q3V === null ? null : pct(q3V);
            const curP = pct(curV);

            // 4 quartile segments (Q0->Q1, Q1->Q2, Q2->Q3, Q3->Q4)
            const segs = [
                { left: 0, right: q1P ?? 25, color: 'rgba(239, 68, 68, 0.25)' },     // red-500
                { left: q1P ?? 25, right: q2P ?? 50, color: 'rgba(245, 158, 11, 0.22)' }, // amber-500
                { left: q2P ?? 50, right: q3P ?? 75, color: 'rgba(59, 130, 246, 0.22)' },  // blue-500
                { left: q3P ?? 75, right: 100, color: 'rgba(34, 197, 94, 0.25)' },    // green-500
            ].map(s => ({
                ...s,
                left: Math.max(0, Math.min(100, s.left)),
                right: Math.max(0, Math.min(100, s.right))
            }));

            const fmtPct = (v) => (v * 100).toFixed(2) + '%';
            const tooltip = [
                `Min: ${fmtPct(minV)}`,
                q1V !== null ? `Q1: ${fmtPct(q1V)}` : null,
                q2V !== null ? `Median: ${fmtPct(q2V)}` : null,
                q3V !== null ? `Q3: ${fmtPct(q3V)}` : null,
                `Max: ${fmtPct(maxV)}`,
                `Current: ${fmtPct(curV)}`
            ].filter(Boolean).join(' | ');

            return `
                <div class="flex items-center gap-2 w-full" title="${tooltip}">
                    <span class="text-[10px] text-gray-300 font-mono tabular-nums">${fmtPct(minV)}</span>
                    <div class="relative flex-1 h-2 rounded bg-gray-700/50 overflow-hidden">
                        ${segs.map(s => {
                            const width = Math.max(0, s.right - s.left);
                            return `<div class="absolute inset-y-0" style="left:${s.left}%; width:${width}%; background-color:${s.color};"></div>`;
                        }).join('')}
                        ${q1P !== null ? `<div class="absolute inset-y-0 w-px bg-gray-200/30" style="left:${q1P}%;"></div>` : ''}
                        ${q2P !== null ? `<div class="absolute inset-y-0 w-px bg-gray-200/35" style="left:${q2P}%;"></div>` : ''}
                        ${q3P !== null ? `<div class="absolute inset-y-0 w-px bg-gray-200/30" style="left:${q3P}%;"></div>` : ''}
                        <div class="absolute -top-1 h-4 w-0.5 rounded-full bg-white/90" style="left:${curP}%; transform: translateX(-50%);"></div>
                    </div>
                    <span class="text-[10px] text-gray-300 font-mono tabular-nums">${fmtPct(maxV)}</span>
                </div>
            `;
        }

        function calculateHistoricalStats(historicalScores, historicalCloses, lookaheadDays) {
            const cleanScores = (historicalScores || []).filter(s => typeof s === 'number' && Number.isFinite(s));
            const nScores = cleanScores.length;
            if (nScores === 0) {
                return {
                    avgScore: null,
                    percentile: null,
                    minScore: null,
                    maxScore: null,
                    q1Score: null,
                    medianScore: null,
                    q3Score: null,
                    bullishCount: 0,
                    neutralCount: 0,
                    bearishCount: 0,
                    bullishReturn: null,
                    bearishReturn: null,
                    lookaheadDays: lookaheadDays
                };
            }

            // Quartiles for distribution bar
            const sorted = [...cleanScores].sort((a, b) => a - b);
            const q1Score = sorted[Math.min(sorted.length - 1, Math.floor(sorted.length * 0.25))];
            const medianScore = sorted[Math.min(sorted.length - 1, Math.floor(sorted.length * 0.50))];
            const q3Score = sorted[Math.min(sorted.length - 1, Math.floor(sorted.length * 0.75))];

            let sumScore = 0;
            let minScore = Infinity;
            let maxScore = -Infinity;
            let bullishCount = 0;
            let neutralCount = 0;
            let bearishCount = 0;
            let bullishReturn = 0;
            let bearishReturn = 0;

            const BULLISH_THRESHOLD = 0.01; // Modified from 0.20 to 0.10

            for (let i = 0; i < historicalScores.length; i++) {
                const score = historicalScores[i];
                if (typeof score !== 'number' || !Number.isFinite(score)) continue;
                sumScore += score;
                minScore = Math.min(minScore, score);
                maxScore = Math.max(maxScore, score);

                const currentClose = historicalCloses[i];
                const futureCloseIndex = i + lookaheadDays;

                let signal = 'NEUTRAL';
                if (score >= BULLISH_THRESHOLD) {
                    signal = 'BULLISH';
                } else if (score < 0.0) {
                    signal = 'BEARISH';
                } else {
                    neutralCount++;
                }

                if (signal === 'BULLISH') {
                    bullishCount++;
                    if (futureCloseIndex < historicalCloses.length) {
                        const futureClose = historicalCloses[futureCloseIndex];
                        bullishReturn += (futureClose - currentClose) / currentClose;
                    }
                }
                if (signal === 'BEARISH') {
                    bearishCount++;
                    if (futureCloseIndex < historicalCloses.length) {
                        const futureClose = historicalCloses[futureCloseIndex];
                        bearishReturn += (currentClose - futureClose) / currentClose;
                    }
                }
            }

            const avgScore = historicalScores.length > 0 ? sumScore / historicalScores.length : null;

            // Calculate percentile of current score (last score) in its history
            // Higher percentile = higher score relative to history (e.g., 90th percentile means score is higher than 90% of historical scores)
            let currentScorePercentile = null;
            if (cleanScores.length > 0) {
                const currentScore = cleanScores[cleanScores.length - 1];
                // Count how many scores are below and equal to the current score
                const scoresBelow = cleanScores.filter(s => s < currentScore).length;
                const scoresEqual = cleanScores.filter(s => s === currentScore).length;
                // Use standard percentile formula: (scores below + 0.5 * scores equal) / total scores * 100
                // This handles ties properly and gives a value between 0 and 100
                // Higher scores result in higher percentiles
                currentScorePercentile = ((scoresBelow + 0.5 * scoresEqual) / cleanScores.length) * 100;
            }

            return {
                avgScore: avgScore,
                percentile: currentScorePercentile,
                minScore: minScore,
                maxScore: maxScore,
                q1Score: q1Score,
                medianScore: medianScore,
                q3Score: q3Score,
                bullishCount: bullishCount,
                neutralCount: neutralCount,
                bearishCount: bearishCount,
                bullishReturn: bullishCount > 0 ? (bullishReturn / bullishCount) * 100 : null,
                bearishReturn: bearishCount > 0 ? (bearishReturn / bearishCount) * 100 : null,
                lookaheadDays: lookaheadDays
            };
        }


        async function calculateSignal() {
            const ticker = document.getElementById('tickerInput').value.toUpperCase();
            const selectedLookaheadBtn = document.querySelector('.lookahead-btn.active');
            const selectedLookahead = selectedLookaheadBtn ? parseInt(selectedLookaheadBtn.getAttribute('data-value'), 10) : 30;
            const modelSelection = document.getElementById('modelSelection').value;
            const useGradientBoosting = modelSelection === 'gradientboosting';
            const useElasticNet = modelSelection === 'elasticnet';
            const useRegimeSwitching = modelSelection === 'regimeswitching';
            const useEqualCategoryWeighting = document.getElementById('useEqualCategoryWeighting').checked;
            const apiKey = 'ca3dfeb893a041b188ae4648825386d7';
            const resultsArea = document.getElementById('resultsArea');
            const loading = document.getElementById('loading');
            const errorMsg = document.getElementById('errorMsg');

            errorMsg.classList.add('hidden');
            resultsArea.classList.add('hidden');
            loading.classList.remove('hidden');

            try {
                const [dailyData, monthlyData, companyName] = await Promise.all([
                    fetchStockData(ticker, apiKey, '1day'),
                    fetchStockData(ticker, apiKey, '1month'),
                    fetchCompanyName(ticker, apiKey)
                ]);

                const { closes, highs, lows, dates } = dailyData;
                const MIN_REQUIRED_POINTS = 220; // Ensure enough history for SMA200 + walk-forward
                if (closes.length < MIN_REQUIRED_POINTS) {
                    throw new Error(`Not enough historical data returned (need ${MIN_REQUIRED_POINTS}+ daily points, got ${closes.length}). The API may have rate limits or the ticker may have limited history.`);
                }
                const lastIdx = closes.length - 1;
                const currentPrice = closes[lastIdx];

                const sma50_arr = SMA(closes, 50);
                const sma100_arr = SMA(closes, 100);
                const sma200_arr = SMA(closes, 200);
                const sma1050_arr = SMA(closes, 1050); // 50-month moving average (~1050 trading days)

                const sd50_arr = StdDev(closes, 50);
                const sd100_arr = StdDev(closes, 100);
                const sd200_arr = StdDev(closes, 200);

                const sma20_arr = SMA(closes, 20);
                const stdDev20_arr = StdDev(closes, 20);
                let upperBBs = [];
                let lowerBBs = [];
                for(let i=0; i<closes.length; i++) {
                    if(sma20_arr[i] !== null && stdDev20_arr[i] !== null) {
                        upperBBs.push(sma20_arr[i] + (stdDev20_arr[i] * 2));
                        lowerBBs.push(sma20_arr[i] - (stdDev20_arr[i] * 2));
                    } else {
                        upperBBs.push(null);
                        lowerBBs.push(null);
                    }
                }

                const rsiArr = calculateRSI(closes);
                const macdData = calculateMACD(closes);
                const adxData = calculateADX(highs, lows, closes);
                const atrArray = calculateATR(highs, lows, closes, 14); // 14-period ATR

                const dailyIndicatorArrays = { closes, highs, lows, rsiArr, macdData, upperBBs, lowerBBs, adxData, sma50_arr, sd50_arr, sma200_arr, sd200_arr, atrArray };

                const macdDataMonthly = calculateMACD(monthlyData.closes);
                
                // Solution 1: Create monthly MACD array mapped to each daily date
                // This gives each historical day its corresponding month's MACD values
                const monthlyMACDArray = createMonthlyMACDArray(dates, monthlyData.dates, macdDataMonthly);
                
                // Keep current values for display purposes
                const macdLineMonthly = macdDataMonthly.macdLine[macdDataMonthly.macdLine.length - 1];
                const signalLineMonthly = macdDataMonthly.signalLine[macdDataMonthly.signalLine.length - 1];
                const histValMonthly = macdDataMonthly.histogram[macdDataMonthly.histogram.length - 1];
                const slopeMonthly = macdDataMonthly.slope[macdDataMonthly.slope.length - 1];

                const startIdxScoreRaw = sma200_arr.findIndex(v => v !== null);
                const startIdxScore = startIdxScoreRaw === -1 ? 0 : startIdxScoreRaw;
                // Multi-timeframe analysis for robust signal generation
                // Analyze signals across key horizons to ensure consistency
                // Balanced approach: medium-term (30d) and longer-term (60d) signals
                // For maximum speed, change to [30] to use single timeframe
                // Use user-selected lookahead horizon (default: 60 days)
                const LOOKAHEAD_WINDOWS = [selectedLookahead]; // User-selected forecast horizon
                const INDICATOR_KEYS = ['macd_m', 'macd_d', 'rsi', 'adx', 'bb', 'ma200_dist', 'zscore'];
                const DISPLAY_NAMES = {
                    'macd_m': 'MACD (Monthly)',
                    'macd_d': 'MACD (Daily)',
                    'rsi': 'RSI (Daily)',
                    'adx': 'ADX/DI (Daily)',
                    'bb': 'Bollinger Bands',
                    'ma200_dist': 'Price vs. 200-DMA (Dist)',
                    'zscore': '50-DMA Z-Score'
                };
                
                // Solution 5: Define indicator categories for category-based importance calculation
                const INDICATOR_CATEGORIES = {
                    'macd_m': 'Trend',
                    'macd_d': 'Trend',
                    'rsi': 'Mean-Reversion',
                    'adx': 'Trend-Following',
                    'bb': 'Mean-Reversion',
                    'ma200_dist': 'Trend-Following',
                    'zscore': 'Mean-Reversion'
                };
                
                // Create category mapping array (index matches INDICATOR_KEYS)
                const indicatorCategoryArray = INDICATOR_KEYS.map(key => INDICATOR_CATEGORIES[key]);

                const NAME_KEY_MAP = {};
                INDICATOR_KEYS.forEach(key => NAME_KEY_MAP[DISPLAY_NAMES[key]] = key);

                // Maximum weight cap: all indicators capped at 25%
                const MAX_WEIGHT = 0.25;


                // Multi-timeframe analysis: Analyze signals across multiple horizons for robustness
                let multiTimeframeScoreVectors = {};

                LOOKAHEAD_WINDOWS.forEach(window => {
                    multiTimeframeScoreVectors[window] = { returns: [] };
                    INDICATOR_KEYS.forEach(key => multiTimeframeScoreVectors[window][key] = []);
                });

                // Calculate dynamic thresholds based on historical data distribution
                // Use a window from startIdxScore to current for threshold calculation
                const thresholdStartIdx = Math.max(0, startIdxScore);
                const maxLookahead = Math.max(...LOOKAHEAD_WINDOWS);
                const thresholdEndIdx = closes.length - maxLookahead;
                const dynamicThresholds = calculateDynamicThresholds(dailyIndicatorArrays, thresholdStartIdx, thresholdEndIdx, monthlyMACDArray);

                // Build score vectors for each timeframe to maximize data for validation
                // Validation function will filter out null values
                const validationStartIdx = Math.max(0, startIdxScore - 50); // Reduced from 100 to 50 for speed
                
                // For regime-switching: detect regimes for each historical point
                let historicalRegimes = [];
                if (useRegimeSwitching) {
                    for (let i = validationStartIdx; i < closes.length - maxLookahead; i++) {
                        const regime = detectRegimeForPoint(i, adxData, monthlyMACDArray, dailyIndicatorArrays);
                        historicalRegimes.push(regime);
                    }
                }

                // Initialize MACD raw scores history for adaptive normalization (validation loop)
                let validationMacdRawScoresHistory = { monthly: [], daily: [] };
                
                for (let i = validationStartIdx; i < closes.length - maxLookahead; i++) {
                    const rawScores = getRawIndicatorScores(i, dailyIndicatorArrays, monthlyMACDArray, dynamicThresholds, validationMacdRawScoresHistory);

                    // Calculate scores for each timeframe
                    LOOKAHEAD_WINDOWS.forEach(window => {
                        if (i + window < closes.length) {
                            const currentClose = closes[i];
                            const futureClose = closes[i + window];

                            if (futureClose && currentClose) {
                                const forwardReturn = (futureClose - currentClose) / currentClose;
                                multiTimeframeScoreVectors[window].returns.push(forwardReturn);
                                INDICATOR_KEYS.forEach(key => {
                                    multiTimeframeScoreVectors[window][key].push(rawScores[key]);
                                });
                            }
                        }
                    });
                }

                // Use the primary training lookahead window for validation data (match training to validation)
                const primaryLookahead = LOOKAHEAD_WINDOWS[LOOKAHEAD_WINDOWS.length - 1]; // Use last (longest) window
                const dailyScoreVectors = multiTimeframeScoreVectors[primaryLookahead] || multiTimeframeScoreVectors[LOOKAHEAD_WINDOWS[0]];

                let FINAL_WEIGHTS = {};
                let REFERENCE_RIDGE_WEIGHTS = {}; // Store Ridge Regression weights for reference when Gradient Boosting is used
                let validationResults = null;

                const defaultWeights = { 'MACD (Monthly)': 0.25, 'MACD (Daily)': 0.20, 'RSI (Daily)': 0.15, 'ADX/DI (Daily)': 0.10, 'Bollinger Bands': 0.10, 'Price vs. 200-DMA (Dist)': 0.10, '50-DMA Z-Score': 0.20 };

                // Multi-timeframe model training and consensus weighting
                // Weights are capped at timeframe level, then averaged

                const availableDataPoints = closes.length - maxLookahead;
                let validRowCount = 0;
                let timeframeModels = {};
                let timeframeWeights = {};
                let timeframeRidgeWeights = {}; // Store Ridge Regression weights for reference when Gradient Boosting is main model

                // Train models for each timeframe that has sufficient data
                LOOKAHEAD_WINDOWS.forEach(window => {
                    const scoreVectors = multiTimeframeScoreVectors[window];
                    if (!scoreVectors || scoreVectors.returns.length < 30) return;

                    // Count valid rows for this timeframe
                    let timeframeValidRows = 0;
                    for (let i = 0; i < scoreVectors.returns.length; i++) {
                        let hasNull = false;
                        for (const key of INDICATOR_KEYS) {
                            if (scoreVectors[key][i] === null || scoreVectors[key][i] === undefined) {
                                hasNull = true;
                                break;
                            }
                        }
                        if (!hasNull && scoreVectors.returns[i] !== null && scoreVectors.returns[i] !== undefined) {
                            timeframeValidRows++;
                        }
                    }

                    if (timeframeValidRows >= 30) {
                        // Prepare feature matrix and target for this timeframe
                        const X = [];
                        const y = [];
                        const regimesForTraining = []; // Track regimes for each row in X

                        for (let i = 0; i < scoreVectors.returns.length; i++) {
                            const row = [];
                            let hasNull = false;
                            for (const key of INDICATOR_KEYS) {
                                if (scoreVectors[key][i] === null || scoreVectors[key][i] === undefined) {
                                    hasNull = true;
                                    break;
                                }
                                row.push(scoreVectors[key][i]);
                            }
                            if (!hasNull && scoreVectors.returns[i] !== null && scoreVectors.returns[i] !== undefined) {
                                X.push(row);
                                y.push(scoreVectors.returns[i]);
                                // Map back to original index: i corresponds to (validationStartIdx + i) in closes array
                                if (useRegimeSwitching) {
                                    const originalIdx = validationStartIdx + i;
                                    const regimeIdx = originalIdx - validationStartIdx;
                                    regimesForTraining.push(historicalRegimes[regimeIdx] || 'TRANSITION');
                                }
                            }
                        }

                        if (X.length >= 30) {
                            let model;
                            let regimeEnsemble = null;
                            
                            if (useRegimeSwitching && regimesForTraining.length === X.length) {
                                // Train regime-switching ensemble
                                console.log(`Training ${window}-day Regime-Switching Ensemble with ${X.length} samples`);
                                regimeEnsemble = trainRegimeSwitchingEnsemble(X, y, regimesForTraining, window, INDICATOR_KEYS, DISPLAY_NAMES);
                                timeframeModels[window] = regimeEnsemble;
                                
                                // Use consensus weights from all regime models (weighted by sample size)
                                const allRegimeWeights = {};
                                let totalSamples = 0;
                                const regimeSampleCounts = {
                                    'STRONG_TREND': regimeEnsemble.models.STRONG_TREND ? X.filter((_, idx) => regimesForTraining[idx] === 'STRONG_TREND').length : 0,
                                    'WEAK_TREND': regimeEnsemble.models.WEAK_TREND ? X.filter((_, idx) => regimesForTraining[idx] === 'WEAK_TREND').length : 0,
                                    'RANGING': regimeEnsemble.models.RANGING ? X.filter((_, idx) => regimesForTraining[idx] === 'RANGING').length : 0,
                                    'TRANSITION': regimeEnsemble.models.TRANSITION ? X.filter((_, idx) => regimesForTraining[idx] === 'TRANSITION').length : 0
                                };
                                
                                // Weight by sample count, fallback gets 20% weight
                                Object.keys(regimeEnsemble.weights).forEach(regime => {
                                    const sampleCount = regime === 'fallback' ? X.length * 0.2 : regimeSampleCounts[regime] || 0;
                                    if (sampleCount > 0 && regimeEnsemble.weights[regime]) {
                                        Object.keys(regimeEnsemble.weights[regime]).forEach(indicator => {
                                            if (!allRegimeWeights[indicator]) allRegimeWeights[indicator] = 0;
                                            allRegimeWeights[indicator] += regimeEnsemble.weights[regime][indicator] * sampleCount;
                                        });
                                        totalSamples += sampleCount;
                                    }
                                });
                                
                                // Normalize to get consensus weights
                                if (totalSamples > 0) {
                                    const consensusWeights = [];
                                    INDICATOR_KEYS.forEach(key => {
                                        const indicatorName = DISPLAY_NAMES[key];
                                        consensusWeights.push(allRegimeWeights[indicatorName] / totalSamples || 0);
                                    });
                                    
                                    // Apply weight caps at weight level (not contribution level)
                                    // Price vs. 200-DMA gets 10% cap, others get 25%
                                    const indicatorCaps = getIndicatorCaps(INDICATOR_KEYS, DISPLAY_NAMES, MAX_WEIGHT);
                                    const cappedWeights = applyWeightCaps(consensusWeights, MAX_WEIGHT, indicatorCaps);
                                    
                                    timeframeWeights[window] = cappedWeights;
                                    
                                    // Set FINAL_WEIGHTS from consensus
                                    INDICATOR_KEYS.forEach((key, idx) => {
                                        FINAL_WEIGHTS[DISPLAY_NAMES[key]] = cappedWeights[idx];
                                    });
                                }
                            } else if (useGradientBoosting) {
                                console.log(`Training ${window}-day Gradient Boosting model with ${X.length} samples`);
                                model = gradientBoostingRegressor(X, y, 25, 0.1, 3); // Reduced from 50 to 25 trees for speed
                            } else if (useElasticNet) {
                                console.log(`Training ${window}-day Elastic Net model with ${X.length} samples`);
                                model = elasticNetRegression(X, y, 0.1, 0.5); // lambda=0.1, alpha=0.5 (balanced L1/L2)
                            } else {
                                console.log(`Training ${window}-day Ridge Regression model with ${X.length} samples`);
                                model = ridgeRegression(X, y, 0.1);
                            }
                            
                            if (model && !useRegimeSwitching) {
                                timeframeModels[window] = model;

                                // Extract weights from model
                                let weights;
                                if (model.predict) {
                                    // Gradient boosting - use feature importance (data-driven or equal category weighting based on user selection)
                                    const importance = calculateFeatureImportance(model, X, y, indicatorCategoryArray, useEqualCategoryWeighting);
                                    const sumImportance = importance.reduce((a, b) => a + b, 0);
                                    weights = sumImportance > 0 ? importance.map(v => v / sumImportance) : null;
                                } else if (model.weights) {
                                    // Ridge regression - use absolute coefficients
                                    const absWeights = model.weights.map(w => Math.abs(w));
                                    const sumAbsWeights = absWeights.reduce((a, b) => a + b, 0);
                                    let rawWeights = sumAbsWeights > 0 ? absWeights.map(v => v / sumAbsWeights) : null;
                                    
                                    // Apply category balancing if enabled
                                    if (rawWeights && useEqualCategoryWeighting && indicatorCategoryArray) {
                                        rawWeights = applyCategoryBalancing(rawWeights, indicatorCategoryArray, INDICATOR_KEYS);
                                    }
                                    
                                    weights = rawWeights;
                                }

                                if (weights) {
                                    console.log(`${window}-day raw weights:`, weights);
                                    // Apply weight caps at weight level (not contribution level)
                                    // Price vs. 200-DMA gets 10% cap, others get 25%
                                    const indicatorCaps = getIndicatorCaps(INDICATOR_KEYS, DISPLAY_NAMES, MAX_WEIGHT);
                                    const cappedWeights = applyWeightCaps(weights, MAX_WEIGHT, indicatorCaps);
                                    console.log(`${window}-day capped weights:`, cappedWeights);
                                    timeframeWeights[window] = cappedWeights;
                                }
                            }
                            
                            // When Gradient Boosting or Elastic Net is the main model, also train Ridge Regression for reference
                            // This ensures REFERENCE_RIDGE_WEIGHTS uses the same multi-timeframe approach
                            if ((useGradientBoosting || useElasticNet) && X.length >= 30) {
                                const ridgeModel = ridgeRegression(X, y, 0.1);
                                if (ridgeModel && ridgeModel.weights) {
                                    const absWeights = ridgeModel.weights.map(w => Math.abs(w));
                                    const sumAbsWeights = absWeights.reduce((a, b) => a + b, 0);
                                    if (sumAbsWeights > 0) {
                                        let ridgeWeights = absWeights.map(v => v / sumAbsWeights);
                                        
                                        // Apply category balancing if enabled (same as main Ridge Regression)
                                        if (useEqualCategoryWeighting && indicatorCategoryArray) {
                                            ridgeWeights = applyCategoryBalancing(ridgeWeights, indicatorCategoryArray, INDICATOR_KEYS);
                                        }
                                        
                                        // Apply weight caps at weight level (not contribution level)
                                        // Price vs. 200-DMA gets 10% cap, others get 25%
                                        const indicatorCaps = getIndicatorCaps(INDICATOR_KEYS, DISPLAY_NAMES, MAX_WEIGHT);
                                        const cappedRidgeWeights = applyWeightCaps(ridgeWeights, MAX_WEIGHT, indicatorCaps);
                                        
                                        // Store Ridge weights for this timeframe (will be used later to set REFERENCE_RIDGE_WEIGHTS)
                                        timeframeRidgeWeights[window] = cappedRidgeWeights;
                                        console.log(`${window}-day Ridge Regression reference weights (capped):`, cappedRidgeWeights);
                                    }
                                }
                            }
                        }
                    }
                });

                // Use weights from the user-selected timeframe directly (no averaging needed since only one timeframe)
                // Note: Individual timeframe weights are already capped above
                if (Object.keys(timeframeWeights).length > 0) {
                    // Since LOOKAHEAD_WINDOWS only contains the user-selected timeframe, use those weights directly
                    const selectedWindow = Object.keys(timeframeWeights)[0]; // Get the user-selected timeframe
                    const selectedWeights = timeframeWeights[selectedWindow];
                    
                    for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                        const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                        FINAL_WEIGHTS[name] = selectedWeights[i];
                    }

                    // Apply 25% weight caps at weight level (not contribution level) - final safety check
                    console.log('Weights from user-selected timeframe:', FINAL_WEIGHTS);
                    FINAL_WEIGHTS = applyWeightCapsToObject(FINAL_WEIGHTS, MAX_WEIGHT);
                    
                    // Verify no weight exceeds cap
                    const maxWeightFound = Math.max(...Object.values(FINAL_WEIGHTS));
                    if (maxWeightFound > MAX_WEIGHT + 1e-10) {
                        console.error(`ERROR: Weight cap violation detected! Max weight: ${maxWeightFound}, Cap: ${MAX_WEIGHT}`);
                        // Force re-cap
                        FINAL_WEIGHTS = applyWeightCapsToObject(FINAL_WEIGHTS, MAX_WEIGHT);
                    }
                    
                    console.log('Final weights after capping and renormalization:', FINAL_WEIGHTS);
                    
                    // When Ridge Regression is the main model, set reference weights to match FINAL_WEIGHTS exactly
                    // This ensures both use the exact same weights from the same training data
                    if (!useGradientBoosting && !useElasticNet) {
                        for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                            const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                            REFERENCE_RIDGE_WEIGHTS[name] = FINAL_WEIGHTS[name] || 0;
                        }
                        // Verify weights match exactly
                        let weightsMatch = true;
                        for (const name in FINAL_WEIGHTS) {
                            if (Math.abs((FINAL_WEIGHTS[name] || 0) - (REFERENCE_RIDGE_WEIGHTS[name] || 0)) > 0.0001) {
                                weightsMatch = false;
                                console.warn(`Weight mismatch for ${name}: FINAL=${FINAL_WEIGHTS[name]}, REF=${REFERENCE_RIDGE_WEIGHTS[name]}`);
                            }
                        }
                        console.log('Reference Ridge Regression weights set to match FINAL_WEIGHTS (Ridge is main model):', REFERENCE_RIDGE_WEIGHTS);
                        console.log('Weights match verification:', weightsMatch ? 'PASSED' : 'FAILED');
                    } else if (useGradientBoosting || useElasticNet) {
                        // When Gradient Boosting or Elastic Net is the main model, set REFERENCE_RIDGE_WEIGHTS from multi-timeframe Ridge training
                        // This ensures REFERENCE_RIDGE_WEIGHTS uses the same methodology as when Ridge is the main model
                        const selectedWindow = Object.keys(timeframeWeights)[0]; // Get the user-selected timeframe
                        if (timeframeRidgeWeights[selectedWindow]) {
                            const selectedRidgeWeights = timeframeRidgeWeights[selectedWindow];
                            
                            for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                                const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                                REFERENCE_RIDGE_WEIGHTS[name] = selectedRidgeWeights[i] || 0;
                            }
                            
                            // Weights are already capped at timeframe level, but apply final safety check
                            for (const name in REFERENCE_RIDGE_WEIGHTS) {
                                REFERENCE_RIDGE_WEIGHTS[name] = Math.min(REFERENCE_RIDGE_WEIGHTS[name], MAX_WEIGHT);
                            }
                            
                            // Renormalize after final capping to ensure weights sum to 1
                            const ridgeFinalCappedSum = Object.values(REFERENCE_RIDGE_WEIGHTS).reduce((a, b) => a + b, 0);
                            if (ridgeFinalCappedSum > 0) {
                                for (const name in REFERENCE_RIDGE_WEIGHTS) {
                                    REFERENCE_RIDGE_WEIGHTS[name] = REFERENCE_RIDGE_WEIGHTS[name] / ridgeFinalCappedSum;
                                }
                            }
                            
                            console.log('Reference Ridge Regression weights from multi-timeframe training (Gradient Boosting or Elastic Net is main model):', REFERENCE_RIDGE_WEIGHTS);
                        }
                    }

                    validRowCount = Math.max(...Object.values(multiTimeframeScoreVectors).map(v => v.returns.length));
                } else {
                    // Fallback: Count valid rows from primary timeframe
                    for (let i = 0; i < dailyScoreVectors.returns.length; i++) {
                        let hasNull = false;
                        for (const key of INDICATOR_KEYS) {
                            if (dailyScoreVectors[key][i] === null || dailyScoreVectors[key][i] === undefined) {
                                hasNull = true;
                                break;
                            }
                        }
                        if (!hasNull && dailyScoreVectors.returns[i] !== null && dailyScoreVectors.returns[i] !== undefined) {
                            validRowCount++;
                        }
                    }
                }

                // Run walk-forward validation if we have weights and sufficient data
                console.log(`Validation check: availableDataPoints=${availableDataPoints}, validRowCount=${validRowCount}, FINAL_WEIGHTS keys: ${Object.keys(FINAL_WEIGHTS).length}`);
                console.log('FINAL_WEIGHTS:', FINAL_WEIGHTS);
                console.log('dailyScoreVectors.returns.length:', dailyScoreVectors.returns ? dailyScoreVectors.returns.length : 'undefined');

                // Always try to run validation if we have any weights
                if (Object.keys(FINAL_WEIGHTS).length > 0) {
                    console.log('Running multi-timeframe model training...');
                    // Prepare feature matrix X and target vector y for ridge regression
                    const X = [];
                    const y = [];
                    
                    for (let i = 0; i < dailyScoreVectors.returns.length; i++) {
                        const row = [];
                        let hasNull = false;
                        for (const key of INDICATOR_KEYS) {
                            if (dailyScoreVectors[key][i] === null || dailyScoreVectors[key][i] === undefined) {
                                hasNull = true;
                                break;
                            }
                            row.push(dailyScoreVectors[key][i]);
                        }
                        if (!hasNull && dailyScoreVectors.returns[i] !== null && dailyScoreVectors.returns[i] !== undefined) {
                            X.push(row);
                            y.push(dailyScoreVectors.returns[i]);
                        }
                    }
                    
                    if (useGradientBoosting) {
                        // Use Gradient Boosting (user-selected)
                        console.log(`Training Gradient Boosting model with ${X.length} samples`);
                        const model = gradientBoostingRegressor(X, y, 25, 0.1, 3); // Reduced from 50 to 25 trees for speed

                        if (model) {
                            // Use feature importance from gradient boosting (data-driven or equal category weighting based on user selection)
                            const featureImportance = calculateFeatureImportance(model, X, y, indicatorCategoryArray, useEqualCategoryWeighting);

                            // Convert to normalized weights
                            const sumImportance = featureImportance.reduce((a, b) => a + b, 0);
                            if (sumImportance > 0) {
                                for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                                    const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                                    FINAL_WEIGHTS[name] = featureImportance[i] / sumImportance;
                                }
                                
                                // Apply 25% weight caps at weight level (not contribution level)
                                FINAL_WEIGHTS = applyWeightCapsToObject(FINAL_WEIGHTS, MAX_WEIGHT);
                                
                                console.log('Gradient Boosting weights after capping and renormalization:', FINAL_WEIGHTS);
                            }
                        }
                        
                        // NOTE: REFERENCE_RIDGE_WEIGHTS is now calculated in the multi-timeframe loop above
                        // when Gradient Boosting is the main model, ensuring it uses the same methodology
                        // as when Ridge Regression is the main model. This ensures consistency.
                        // No need to calculate it again here from a single training pass.
                    } else if (useElasticNet && X.length >= 40) {
                        // Use Elastic Net (user-selected)
                        console.log(`Training Elastic Net model with ${X.length} samples`);
                        const model = elasticNetRegression(X, y, 0.1, 0.5); // lambda=0.1, alpha=0.5 (balanced L1/L2)
                        
                        if (model && model.weights) {
                            // Convert regression coefficients to normalized weights (same as Ridge)
                            const absWeights = model.weights.map(w => Math.abs(w));
                            const sumAbsWeights = absWeights.reduce((a, b) => a + b, 0);
                            
                            if (sumAbsWeights > 0) {
                                let rawWeights = absWeights.map(v => v / sumAbsWeights);
                                
                                // Apply category balancing if enabled
                                if (useEqualCategoryWeighting && indicatorCategoryArray) {
                                    rawWeights = applyCategoryBalancing(rawWeights, indicatorCategoryArray, INDICATOR_KEYS);
                                }
                                
                                for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                                    const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                                    FINAL_WEIGHTS[name] = rawWeights[i];
                                }
                                
                                // Apply 25% weight caps at weight level (not contribution level)
                                FINAL_WEIGHTS = applyWeightCapsToObject(FINAL_WEIGHTS, MAX_WEIGHT);
                                
                                console.log('Elastic Net weights after capping and renormalization:', FINAL_WEIGHTS);
                            }
                        }
                        
                        // NOTE: REFERENCE_RIDGE_WEIGHTS is now calculated in the multi-timeframe loop above
                        // when Elastic Net is the main model, ensuring it uses the same methodology
                        // as when Ridge Regression is the main model. This ensures consistency.
                        // No need to calculate it again here from a single training pass.
                    } else if (X.length >= 40) {
                        // Use Ridge Regression (default, faster)
                        // Check if FINAL_WEIGHTS already exist from multi-timeframe training - if so, preserve them
                        const hasMultiTimeframeWeights = Object.keys(FINAL_WEIGHTS).length > 0;
                        
                        if (!hasMultiTimeframeWeights) {
                            // Only calculate single timeframe weights if multi-timeframe weights don't exist
                            console.log(`Training Ridge Regression model with ${X.length} samples`);
                            const model = ridgeRegression(X, y, 0.1);

                            if (model && model.weights) {
                                // Convert regression coefficients to normalized weights
                                const absWeights = model.weights.map(w => Math.abs(w));
                                const sumAbsWeights = absWeights.reduce((a, b) => a + b, 0);

                                if (sumAbsWeights > 0) {
                                    let rawWeights = absWeights.map(v => v / sumAbsWeights);
                                    
                                    // Apply category balancing if enabled
                                    if (useEqualCategoryWeighting && indicatorCategoryArray) {
                                        rawWeights = applyCategoryBalancing(rawWeights, indicatorCategoryArray, INDICATOR_KEYS);
                                    }
                                    
                                    for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                                        const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                                        FINAL_WEIGHTS[name] = rawWeights[i];
                                    }
                                    
                                    // Apply 25% weight caps at weight level (not contribution level)
                                    FINAL_WEIGHTS = applyWeightCapsToObject(FINAL_WEIGHTS, MAX_WEIGHT);

                                    console.log('Single timeframe Ridge Regression weights:', FINAL_WEIGHTS);
                                }
                            }
                        } else {
                            console.log('Using weights from user-selected timeframe (Ridge Regression):', FINAL_WEIGHTS);
                        }
                        
                        // Set reference weights to match FINAL_WEIGHTS exactly
                        // This ensures validation uses the exact same weights when Ridge is the main model
                        // Only set if not already set from multi-timeframe loop (to avoid overwriting)
                        if (Object.keys(REFERENCE_RIDGE_WEIGHTS).length === 0 || (!useGradientBoosting && !useElasticNet)) {
                            for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                                const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                                REFERENCE_RIDGE_WEIGHTS[name] = FINAL_WEIGHTS[name] || 0;
                            }
                            // Verify weights match exactly
                            let weightsMatch = true;
                            for (const name in FINAL_WEIGHTS) {
                                if (Math.abs((FINAL_WEIGHTS[name] || 0) - (REFERENCE_RIDGE_WEIGHTS[name] || 0)) > 0.0001) {
                                    weightsMatch = false;
                                    console.warn(`Weight mismatch for ${name}: FINAL=${FINAL_WEIGHTS[name]}, REF=${REFERENCE_RIDGE_WEIGHTS[name]}`);
                                }
                            }
                            console.log('Reference Ridge Regression weights (identical to FINAL_WEIGHTS when Ridge is main model):', REFERENCE_RIDGE_WEIGHTS);
                            console.log('Weights match verification:', weightsMatch ? 'PASSED' : 'FAILED');
                        }
                                
                        // IMPORTANT: When Ridge Regression is the main model, we should NOT run validation here
                        // because FINAL_WEIGHTS may have been set from multi-timeframe training above.
                        // Validation will be handled later using walkForwardValidationWithWeights to ensure
                        // we use the exact FINAL_WEIGHTS that were calculated.
                        // This prevents the issue where walkForwardValidation trains internally and ignores FINAL_WEIGHTS.
                        console.log('Skipping validation here - will use walkForwardValidationWithWeights later to ensure correct weights are used');
                    }
                } else {
                    validationResults = {
                        error: `Not enough clean data for validation: availableDays=${availableDataPoints}, validRows=${validRowCount} (need >=80 days and >=40 valid rows for basic modeling, >=500 for advanced ML)`,
                        availableDataPoints,
                        validRowCount
                    };
                }
                
                // Fallback to default weights if regression failed
                if (Object.keys(FINAL_WEIGHTS).length === 0) {
                    const sum = Object.values(defaultWeights).reduce((a, b) => a + b, 0);
                    for (const name in defaultWeights) {
                        FINAL_WEIGHTS[name] = defaultWeights[name] / sum;
                    }
                    
                    // Apply 25% weight caps at weight level (not contribution level)
                    FINAL_WEIGHTS = applyWeightCapsToObject(FINAL_WEIGHTS, MAX_WEIGHT);
                    
                    console.log('Default weights after capping and renormalization:', FINAL_WEIGHTS);
                }
                
                // Run walk-forward validation if we have calculated weights and haven't run validation yet
                let ridgeValidationResults = null;
                if (validationResults === null && Object.keys(FINAL_WEIGHTS).length > 0 && dailyScoreVectors && dailyScoreVectors.returns && dailyScoreVectors.returns.length > 0) {
                    const minTrainSize = dailyScoreVectors.returns.length >= 500 ? 60 : 30;
                    const requiredDataPoints = Math.max(20, minTrainSize + 5);
                    
                    if (dailyScoreVectors.returns.length >= requiredDataPoints) {
                        // Use adaptive step size: larger for big datasets to reduce iterations while still getting good coverage
                        const dataSize = dailyScoreVectors.returns.length;
                        let stepSize = 25; // Default step size
                        if (dataSize > 1000) {
                            stepSize = 50; // Larger step for very large datasets
                        } else if (dataSize > 500) {
                            stepSize = 35; // Medium step for large datasets
                        }
                        
                        // Use the primary training lookahead window for validation (match training to validation)
                        const validationLookahead = LOOKAHEAD_WINDOWS[LOOKAHEAD_WINDOWS.length - 1]; // Use last (longest) window
                        console.log(`Running walk-forward validation (final check): ${dataSize} data points, stepSize: ${stepSize}, lookahead: ${validationLookahead} days`);
                        
                        // When Ridge Regression is the main model, ensure REFERENCE_RIDGE_WEIGHTS exactly matches FINAL_WEIGHTS
                        // This is critical to ensure both validations use identical weights
                        if (!useGradientBoosting && !useElasticNet && Object.keys(FINAL_WEIGHTS).length > 0) {
                            for (let i = 0; i < INDICATOR_KEYS.length; i++) {
                                const name = DISPLAY_NAMES[INDICATOR_KEYS[i]];
                                REFERENCE_RIDGE_WEIGHTS[name] = FINAL_WEIGHTS[name] || 0;
                            }
                            // Final verification before validation
                            let weightsMatch = true;
                            for (const name in FINAL_WEIGHTS) {
                                if (Math.abs((FINAL_WEIGHTS[name] || 0) - (REFERENCE_RIDGE_WEIGHTS[name] || 0)) > 0.0001) {
                                    weightsMatch = false;
                                    console.error(`CRITICAL: Weight mismatch before validation for ${name}: FINAL=${FINAL_WEIGHTS[name]}, REF=${REFERENCE_RIDGE_WEIGHTS[name]}`);
                                }
                            }
                            if (weightsMatch) {
                                console.log('✓ Weights verified identical before validation (Ridge is main model)');
                            } else {
                                console.error('✗ Weight mismatch detected before validation!');
                            }
                        }
                        
                        // Validate using FINAL_WEIGHTS (the actual model weights)
                        validationResults = walkForwardValidationWithWeights(dailyScoreVectors, dailyScoreVectors.returns, FINAL_WEIGHTS, DISPLAY_NAMES, INDICATOR_KEYS, validationLookahead, Math.min(minTrainSize, dailyScoreVectors.returns.length - 10), stepSize);
                        console.log('Validation results (main model):', validationResults);
                        
                        // Also validate using Ridge Regression reference weights if available
                        if (REFERENCE_RIDGE_WEIGHTS && Object.keys(REFERENCE_RIDGE_WEIGHTS).length > 0) {
                            ridgeValidationResults = walkForwardValidationWithWeights(dailyScoreVectors, dailyScoreVectors.returns, REFERENCE_RIDGE_WEIGHTS, DISPLAY_NAMES, INDICATOR_KEYS, validationLookahead, Math.min(minTrainSize, dailyScoreVectors.returns.length - 10), stepSize);
                            console.log('Validation results (Ridge Regression reference):', ridgeValidationResults);
                            
                            // Compare results to verify they match when weights should be identical
                            if (!useGradientBoosting && !useElasticNet && validationResults && ridgeValidationResults && validationResults.overall && ridgeValidationResults.overall) {
                                const mainHitRate = validationResults.overall.hitRate || 0;
                                const refHitRate = ridgeValidationResults.overall.hitRate || 0;
                                const mainAvgReturn = validationResults.overall.avgReturn || 0;
                                const refAvgReturn = ridgeValidationResults.overall.avgReturn || 0;
                                if (Math.abs(mainHitRate - refHitRate) > 0.001 || Math.abs(mainAvgReturn - refAvgReturn) > 0.0001) {
                                    console.warn(`⚠️ Validation results differ: HitRate (main=${mainHitRate}, ref=${refHitRate}), AvgReturn (main=${mainAvgReturn}, ref=${refAvgReturn})`);
                                } else {
                                    console.log('✓ Validation results match (as expected when weights are identical)');
                                }
                            }
                        }
                    } else {
                        console.log('Skipping validation - insufficient data points for walk-forward testing');
                        validationResults = { error: `Insufficient data: ${dailyScoreVectors.returns.length} points available, need ${requiredDataPoints}` };
                    }
                }

                let historicalScores = [];
                let ridgeHistoricalScores = [];
                const historicalDates = dates.slice(startIdxScore);
                const historicalCloses = closes.slice(startIdxScore);

                // Initialize MACD raw scores history for adaptive normalization (historical loop)
                let historicalMacdRawScoresHistory = { monthly: [], daily: [] };
                
                for (let i = startIdxScore; i < closes.length; i++) {
                    const rawScores = getRawIndicatorScores(i, dailyIndicatorArrays, monthlyMACDArray, dynamicThresholds, historicalMacdRawScoresHistory);
                    let dailyScore = 0;
                    let ridgeDailyScore = 0;

                    dailyScore += rawScores.macd_m * FINAL_WEIGHTS['MACD (Monthly)'] ; 
                    dailyScore += rawScores.macd_d * FINAL_WEIGHTS['MACD (Daily)'];
                    dailyScore += rawScores.rsi * FINAL_WEIGHTS['RSI (Daily)'];
                    dailyScore += rawScores.adx * FINAL_WEIGHTS['ADX/DI (Daily)'];
                    dailyScore += rawScores.bb * FINAL_WEIGHTS['Bollinger Bands'];
                    dailyScore += rawScores.ma200_dist * FINAL_WEIGHTS['Price vs. 200-DMA (Dist)'];
                    dailyScore += rawScores.zscore * FINAL_WEIGHTS['50-DMA Z-Score'];

                    historicalScores.push(dailyScore);

                    // Calculate Ridge Regression historical scores if reference weights are available
                    if (REFERENCE_RIDGE_WEIGHTS && Object.keys(REFERENCE_RIDGE_WEIGHTS).length > 0) {
                        ridgeDailyScore += rawScores.macd_m * (REFERENCE_RIDGE_WEIGHTS['MACD (Monthly)'] || 0);
                        ridgeDailyScore += rawScores.macd_d * (REFERENCE_RIDGE_WEIGHTS['MACD (Daily)'] || 0);
                        ridgeDailyScore += rawScores.rsi * (REFERENCE_RIDGE_WEIGHTS['RSI (Daily)'] || 0);
                        ridgeDailyScore += rawScores.adx * (REFERENCE_RIDGE_WEIGHTS['ADX/DI (Daily)'] || 0);
                        ridgeDailyScore += rawScores.bb * (REFERENCE_RIDGE_WEIGHTS['Bollinger Bands'] || 0);
                        ridgeDailyScore += rawScores.ma200_dist * (REFERENCE_RIDGE_WEIGHTS['Price vs. 200-DMA (Dist)'] || 0);
                        ridgeDailyScore += rawScores.zscore * (REFERENCE_RIDGE_WEIGHTS['50-DMA Z-Score'] || 0);
                    }

                    ridgeHistoricalScores.push(ridgeDailyScore);
                }


                const finalTotalScore = historicalScores[historicalScores.length - 1];

                const historicalStats = calculateHistoricalStats(historicalScores, historicalCloses, 30);
                const ridgeHistoricalStats = (REFERENCE_RIDGE_WEIGHTS && Object.keys(REFERENCE_RIDGE_WEIGHTS).length > 0 && ridgeHistoricalScores.length > 0) 
                    ? calculateHistoricalStats(ridgeHistoricalScores, historicalCloses, 30) 
                    : null;

                const lastDayRawScores = getRawIndicatorScores(lastIdx, dailyIndicatorArrays, monthlyMACDArray, dynamicThresholds);
                
                // Apply Philosophy Framework to final score
                let philosophyResult = null;
                let philosophyAlignedScore = finalTotalScore;
                
                // Prepare context for philosophy framework
                // Handle monthly MACD data - it might be an array of objects or a single object
                let monthlyMACDForLastDay = null;
                if (Array.isArray(monthlyMACDArray) && monthlyMACDArray.length > 0) {
                    monthlyMACDForLastDay = monthlyMACDArray[lastIdx] || monthlyMACDArray[monthlyMACDArray.length - 1];
                } else if (monthlyMACDArray && typeof monthlyMACDArray === 'object') {
                    monthlyMACDForLastDay = monthlyMACDArray;
                } else if (macdDataMonthly && macdDataMonthly.histogram && macdDataMonthly.histogram.length > 0) {
                    // Fallback: construct from macdDataMonthly if available
                    const monthlyIdx = macdDataMonthly.histogram.length - 1;
                    monthlyMACDForLastDay = {
                        histogram: macdDataMonthly.histogram[monthlyIdx],
                        slope: macdDataMonthly.slope ? macdDataMonthly.slope[monthlyIdx] : null,
                        macdLine: macdDataMonthly.macdLine ? macdDataMonthly.macdLine[monthlyIdx] : null,
                        signalLine: macdDataMonthly.signalLine ? macdDataMonthly.signalLine[monthlyIdx] : null
                    };
                }
                const dailyMACDForLastDay = {
                    histogram: macdData.histogram[lastIdx],
                    slope: macdData.slope[lastIdx],
                    macdLine: macdData.macdLine[lastIdx],
                    signalLine: macdData.signalLine[lastIdx]
                };
                
                // Get swing highs and lows (pivot points) for support/resistance
                // These are meaningful price levels, not just all daily highs/lows
                const swingPoints = identifySwingHighsLows(highs, lows, closes, dates, 252, 5);
                const recentHighs = swingPoints.swingHighs; // Array of {price, close, date, index}
                const recentLows = swingPoints.swingLows;   // Array of {price, close, date, index}
                
                // Prepare raw scores object with indicator names
                const rawScoresWithNames = {
                    'MACD (Monthly)': lastDayRawScores.macd_m,
                    'MACD (Daily)': lastDayRawScores.macd_d,
                    'RSI (Daily)': lastDayRawScores.rsi,
                    'ADX/DI (Daily)': lastDayRawScores.adx,
                    'Bollinger Bands': lastDayRawScores.bb,
                    'Price vs. 200-DMA (Dist)': lastDayRawScores.ma200_dist,
                    '50-DMA Z-Score': lastDayRawScores.zscore
                };
                
                // Get price history for bounce detection
                const priceHistory = closes.slice(Math.max(0, lastIdx - 20), lastIdx + 1);

                const sma50_i = sma50_arr[lastIdx];
                const sd50_i = sd50_arr[lastIdx];
                const sma100_i = sma100_arr[lastIdx];
                const sd100_i = sd100_arr[lastIdx];
                const sma200_i = sma200_arr[lastIdx];
                const sd200_i = sd200_arr[lastIdx];
                const upperBB = upperBBs[lastIdx];
                const lowerBB = lowerBBs[lastIdx];
                const bbRange = upperBB !== null && lowerBB !== null ? upperBB - lowerBB : 0;
                const pctB = bbRange === 0 ? 0.5 : (currentPrice - lowerBB) / bbRange;
                // Distance traveling FROM current price TO moving average: positive = price below MA (traveling up), negative = price above MA (traveling down)
                const dist50 = sma50_i ? ((sma50_i - currentPrice) / currentPrice) * 100 : null;
                const dist100 = sma100_i ? ((sma100_i - currentPrice) / currentPrice) * 100 : null;
                // For 200-DMA display: use same format as 50 and 100 for consistency in Key Technical Levels card
                const dist200_display = sma200_i ? ((sma200_i - currentPrice) / currentPrice) * 100 : null;
                // For 200-DMA indicator calculation: calculate percentage ABOVE only (magnitude determines score, above is bullish)
                const dist200 = sma200_i && currentPrice > sma200_i ? ((currentPrice - sma200_i) / sma200_i) * 100 : (sma200_i && currentPrice <= sma200_i ? 0 : null);

                const zScore50 = (sma50_i && sd50_i) ? (currentPrice - sma50_i) / sd50_i : null;
                const zScore100 = (sma100_i && sd100_i) ? (currentPrice - sma100_i) / sd100_i : null;
                const zScore200 = (sma200_i && sd200_i) ? (currentPrice - sma200_i) / sd200_i : null;

                // Extract the specific MACD values for the last day
                const macdLine_d = macdData.macdLine[lastIdx];
                const signalLine_d = macdData.signalLine[lastIdx];
                const histVal = macdData.histogram[lastIdx];
                const slope_d = macdData.slope[lastIdx];

                const macdLine_m = macdDataMonthly.macdLine[macdDataMonthly.macdLine.length - 1];
                const signalLine_m = macdDataMonthly.signalLine[macdDataMonthly.signalLine.length - 1];
                const histVal_m = macdDataMonthly.histogram[macdDataMonthly.histogram.length - 1]; // Added monthly histogram
                const slope_m = macdDataMonthly.slope[macdDataMonthly.slope.length - 1]; // Added monthly slope

                function getInterp(key, rawScore, details) {
                    const histVal = details.histVal; // Daily Histogram
                    const slope = details.slope_d; // Daily MACD Line Slope
                    const histVal_m = details.histVal_m; // Monthly Histogram
                    const slope_m = details.slope_m; // Monthly MACD Line Slope

                    switch (key) {
                        case 'MACD (Monthly)': {
                            if (histVal_m === null || slope_m === null) {
                                return rawScore > 0 ? "Monthly: MACD Line > Signal (Macro Trend Up)" : rawScore < 0 ? "Monthly: MACD Line < Signal (Macro Trend Down)" : "Monthly: Neutral/Consolidating";
                            }
                            
                            // Use dynamic thresholds from details object
                            const monthlySlopeThreshold = details.monthlySlopeThreshold || 0.01;
                            const monthlyHistNearZeroThreshold = details.monthlyHistNearZeroThreshold || 0.05;
                            
                            let interpretation = "Monthly: ";
                            if (histVal_m > monthlyHistNearZeroThreshold) {
                                // Histogram positive
                                if (slope_m > monthlySlopeThreshold) {
                                    interpretation += "Strong bullish macro momentum (Histogram positive and accelerating).";
                                } else if (slope_m < -monthlySlopeThreshold) {
                                    const timeToZero = Math.abs(histVal_m / slope_m);
                                    interpretation += `Bullish macro momentum decelerating (Histogram positive but trending down). **Potential bearish crossover in ~${timeToZero.toFixed(1)} months**`;
                                } else {
                                    interpretation += "Bullish macro momentum sustained (Histogram positive and stable).";
                                }
                            } else if (histVal_m < -monthlyHistNearZeroThreshold) {
                                // Histogram negative
                                if (slope_m < -monthlySlopeThreshold) {
                                    interpretation += "Strong bearish macro momentum (Histogram negative and accelerating down).";
                                } else if (slope_m > monthlySlopeThreshold) {
                                    const timeToZero = Math.abs(histVal_m / slope_m);
                                    interpretation += `Bearish macro momentum decelerating (Histogram negative but improving). **Potential bullish crossover in ~${timeToZero.toFixed(1)} months**`;
                                } else {
                                    interpretation += "Bearish macro momentum sustained (Histogram negative and stable).";
                                }
                            } else {
                                // Histogram near zero (crossover potential)
                                if (slope_m > monthlySlopeThreshold) {
                                    interpretation += "Histogram crossing/near zero and rising (Potential **bullish macro crossover** forming).";
                                } else if (slope_m < -monthlySlopeThreshold) {
                                    interpretation += "Histogram crossing/near zero and falling (Potential **bearish macro crossover** forming).";
                                } else {
                                    interpretation += "Histogram near zero and flat (No clear macro trend, consolidating).";
                                }
                            }
                            return interpretation;
                        }
                        case 'MACD (Daily)': {
                            if (histVal === null || slope === null) return "Daily: N/A - Insufficient Data";

                            let interpretation = "Daily: ";
                            if (histVal > details.histNearZeroThreshold) {
                                // Histogram positive
                                if (slope > details.slopeThreshold) {
                                    interpretation += "Bullish momentum (Histogram positive and accelerating).";
                                } else if (slope < -details.slopeThreshold) {
                                    const timeToZero = Math.abs(histVal / slope);
                                    interpretation += `Bullish momentum decelerating (Histogram positive but trending down). **Potential bearish crossover in ~${timeToZero.toFixed(1)} days**`;
                                } else {
                                    interpretation += "Bullish momentum sustained (Histogram positive and flat, but no clear acceleration/deceleration).";
                                }
                            } else if (histVal < -details.histNearZeroThreshold) {
                                // Histogram negative
                                if (slope < -details.slopeThreshold) {
                                    interpretation += "Bearish momentum (Histogram negative and accelerating down).";
                                } else if (slope > details.slopeThreshold) {
                                    const timeToZero = Math.abs(histVal / slope);
                                    interpretation += `Bearish momentum decelerating (Histogram negative but improving). **Potential bullish crossover in ~${timeToZero.toFixed(1)} days to cross.**`;
                                } else {
                                    interpretation += "Bearish momentum sustained (Histogram negative and flat, but no clear acceleration/deceleration).";
                                }
                            } else {
                                // Histogram near zero (crossover region)
                                if (slope > details.slopeThreshold) {
                                    interpretation += "Histogram crossing/near zero and rising (Potential **bullish crossover** forming).";
                                } else if (slope < -details.slopeThreshold) {
                                    interpretation += "Histogram crossing/near zero and falling (Potential **bearish crossover** forming).";
                                } else {
                                    interpretation += "Histogram near zero and flat (No meaningful momentum, ranging/choppy market).";
                                }
                            }
                            return interpretation;
                        }
                        case 'RSI (Daily)':
                            if (details.rsiVal < 30) return "Extreme Oversold (<30) - Potential Reversal/Bounce";
                            else if (details.rsiVal > 70) return "Extreme Overbought (>70) - Risk of Pullback/Reversal";
                            else if (details.rsiVal < 45) return "Oversold Bias";
                            else if (details.rsiVal > 55) return "Overbought Bias";
                            else return "Neutral (RSI approx 50)";
                        case 'ADX/DI (Daily)':
                            const adx = details.adxVal;
                            const pdi = details.pdiVal;
                            const mdi = details.mdiVal;

                            if (adx === null || pdi === null || mdi === null) return "N/A - Insufficient Data";

                            let trendStrength = "";
                            if (adx > 50) trendStrength = "Very Strong Trend";
                            else if (adx > 25) trendStrength = "Strong Trend";
                            else if (adx > 20) trendStrength = "Developing Trend";
                            else trendStrength = "No Significant Trend";

                            let trendDirection = "";
                            if (pdi > mdi) trendDirection = "Uptrend";
                            else if (mdi > pdi) trendDirection = "Downtrend";
                            else trendDirection = "Neutral Direction";

                            if (adx > 20) { // Only if there's at least a developing trend
                                if (pdi > mdi) return `${trendStrength}: ${trendDirection} (+DI > -DI)`;
                                else if (mdi > pdi) return `${trendStrength}: ${trendDirection} (-DI > +DI)`;
                                else return `${trendStrength}: ${trendDirection} (PDI ~ MDI)`; // Should be rare
                            } else { // ADX <= 20
                                return `${trendStrength} (ADX: ${adx.toFixed(2)})`;
                            }
                        case 'Bollinger Bands': return rawScore === 1 ? "Price < Lower Band (Extended)" : rawScore === -1 ? "Price > Upper Band (Extended)" : rawScore === 0.25 ? "Near Lower Band (Support)" : rawScore === -0.25 ? "Near Upper Band (Risk)" : "Mid-Range";
                        case 'Price vs. 200-DMA (Dist)': 
                            // dist200 is the percentage ABOVE 200-DMA (0 if at or below)
                            // Magnitude above determines score - more above = more bullish
                            if (details.dist200 !== null && details.dist200 !== undefined) {
                                if (details.dist200 > 0) {
                                    // Price is above 200-DMA - magnitude determines bullishness
                                    return `Bullish (${details.dist200.toFixed(2)}% above 200-DMA)`;
                                } else {
                                    // Price is at or below 200-DMA
                                    return `Neutral/Weak (At or below 200-DMA, 200-DMA: ${details.ma200_val?.toFixed(2) || 'N/A'})`;
                                }
                            } else {
                                return `Neutral (200-DMA: ${details.ma200_val?.toFixed(2) || 'N/A'})`;
                            }
                        case '50-DMA Z-Score':
                            // Uses 50-day MA z-score
                            if (details.zScore50 > 1.25) {
                                return `Overvaluation (Z-Score: ${details.zScore50?.toFixed(2) || 'N/A'})`;
                            } else if (details.zScore50 < -1.25) {
                                return `Undervaluation (Z-Score: ${details.zScore50?.toFixed(2) || 'N/A'})`;
                            } else if (details.zScore50 > 1.0) {
                                return `Overvalued Bias (Z-Score: ${details.zScore50?.toFixed(2) || 'N/A'})`;
                            } else if (details.zScore50 < -1.0) {
                                return `Undervalued Bias (Z-Score: ${details.zScore50?.toFixed(2) || 'N/A'})`;
                            } else {
                                return `Neutral (Z-Score: ${details.zScore50?.toFixed(2) || 'N/A'})`;
                            }
                        default: return "N/A";
                    }
                }

                let scores = [];
                Object.keys(FINAL_WEIGHTS).forEach(name => {
                    const key = NAME_KEY_MAP[name];
                    const rawScore = lastDayRawScores[key];
                    const weight = FINAL_WEIGHTS[name];
                    const details = {
                        dist200,
                        pctB,
                        rsiVal: dailyIndicatorArrays.rsiArr[lastIdx],
                        adxVal: dailyIndicatorArrays.adxData.adx[lastIdx],
                        pdiVal: dailyIndicatorArrays.adxData.pdi[lastIdx],
                        mdiVal: dailyIndicatorArrays.adxData.mdi[lastIdx],
                        histVal: dailyIndicatorArrays.macdData.histogram[lastIdx],
                        slope_d: dailyIndicatorArrays.macdData.slope[lastIdx],
                        macdLine_d: dailyIndicatorArrays.macdData.macdLine[lastIdx],
                        signalLine_d: dailyIndicatorArrays.macdData.signalLine[lastIdx],
                        ma200_val: sma200_i,
                        sd200_val: sd200_i,
                        macdLine_m: macdLine_m,
                        signalLine_m: signalLine_m,
                        histVal_m: histVal_m,
                        slope_m: slope_m,
                        zScore50: zScore50, // Using 50-day MA z-score for the indicator
                        slopeThreshold: 0.005, // Pass thresholds to interpretation for consistent messaging
                        histNearZeroThreshold: 0.02,
                        // Monthly MACD thresholds
                        monthlySlopeThreshold: dynamicThresholds ? (dynamicThresholds.macdMonthlySlope_threshold || 0.01) : 0.01,
                        monthlyHistNearZeroThreshold: dynamicThresholds ? (dynamicThresholds.macdMonthlyHist_nearZeroThreshold || 0.05) : 0.05
                    };

                    let val = rawScore;
                    if (name === 'RSI (Daily)') {
                        val = renderRSIBar(details.rsiVal);
                    } else if (name === 'ADX/DI (Daily)') {
                        val = `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-300 text-left">ADX:</span> <span class="text-gray-400 text-right">${details.adxVal !== null ? details.adxVal.toFixed(2) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-green-400 text-left">+DI:</span> <span class="text-green-400 text-right">${details.pdiVal !== null ? details.pdiVal.toFixed(1) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-red-400 text-left">-DI:</span> <span class="text-red-400 text-right">${details.mdiVal !== null ? details.mdiVal.toFixed(1) : 'N/A'}</span></div>`;
                    } else if (name === 'Bollinger Bands') {
                        val = upperBB !== null ? `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-400 text-left">P%B:</span> <span class="text-gray-400 text-right">${pctB.toFixed(2)}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-green-500 text-left">Upper Band:</span> <span class="text-green-500 text-right">$${upperBB.toFixed(2)}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-red-500 text-left">Lower Band:</span> <span class="text-red-500 text-right">$${lowerBB.toFixed(2)}</span></div>` : 'N/A';
                    } else if (name === 'Price vs. 200-DMA (Dist)') {
                        // dist200 is percentage ABOVE 200-DMA (0 if at or below)
                        val = dist200 !== null ? (dist200 > 0 ? dist200.toFixed(2) + '% above' : 'At or below') : 'N/A';
                    } else if (name === '50-DMA Z-Score') {
                        // Using 50-day MA z-score for the indicator
                        val = zScore50 !== null ? zScore50.toFixed(2) : 'N/A';
                    } else if (name === 'MACD (Daily)') {
                        val = `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-400 text-left">MACD:</span> <span class="text-gray-400 text-right">${details.macdLine_d !== null ? details.macdLine_d.toFixed(2) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-400 text-left">Signal:</span> <span class="text-gray-400 text-right">${details.signalLine_d !== null ? details.signalLine_d.toFixed(2) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-yellow-300 text-left">Hist:</span> <span class="text-yellow-300 text-right">${details.histVal !== null ? details.histVal.toFixed(2) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-400 text-left">Slope:</span> <span class="text-gray-400 text-right">${details.slope_d !== null ? details.slope_d.toFixed(2) : 'N/A'}</span></div>`;
                    } else if (name === 'MACD (Monthly)') {
                        val = `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-400 text-left">MACD:</span> <span class="text-gray-400 text-right">${details.macdLine_m !== null ? details.macdLine_m.toFixed(2) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-400 text-left">Signal:</span> <span class="text-gray-400 text-right">${details.signalLine_m !== null ? details.signalLine_m.toFixed(2) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-yellow-300 text-left">Hist:</span> <span class="text-yellow-300 text-right">${details.histVal_m !== null ? details.histVal_m.toFixed(2) : 'N/A'}</span></div>` +
                              `<div class="text-xs font-mono flex justify-between w-full"><span class="text-gray-400 text-left">Slope:</span> <span class="text-gray-400 text-right">${details.slope_m !== null ? details.slope_m.toFixed(2) : 'N/A'}</span></div>`;
                    }

                    const scoreObj = {
                        name: name,
                        val: val,
                        score: rawScore,
                        weight: weight,
                        interp: getInterp(name, rawScore, details)
                    };
                    
                    // Add MACD breakdown if available
                    if (name === 'MACD (Monthly)' && lastDayRawScores.macd_m_breakdown) {
                        scoreObj.macdBreakdown = lastDayRawScores.macd_m_breakdown;
                    } else if (name === 'MACD (Daily)' && lastDayRawScores.macd_d_breakdown) {
                        scoreObj.macdBreakdown = lastDayRawScores.macd_d_breakdown;
                    }
                    
                    scores.push(scoreObj);
                });

                const maStats = {
                    ma50: { val: sma50_i, dist: dist50, zScore: zScore50 },
                    ma100: { val: sma100_i, dist: dist100, zScore: zScore100 },
                    ma200: { val: sma200_i, dist: dist200_display, zScore: zScore200 } // Use display format for consistency
                };

                const recentHighLow = calculateRecentHighLow(highs, lows);
                const fibLevels = calculateDeMarkFibLevels(highs, lows, closes, dates);
                
                // Detect current regime for regime-switching ensemble
                let currentRegime = 'TRANSITION';
                let detectedRegimeModel = null;
                if (useRegimeSwitching && timeframeModels[selectedLookahead]) {
                    const regimeEnsemble = timeframeModels[selectedLookahead];
                    if (regimeEnsemble && regimeEnsemble.models) {
                        // Detect current regime using philosophy framework
                        const monthlyMACDForRegime = monthlyMACDForLastDay;
                        const dailyMACDForRegime = dailyMACDForLastDay;
                        const adxForRegime = { adx: adxData.adx[lastIdx], pdi: adxData.pdi[lastIdx], mdi: adxData.mdi[lastIdx] };
                        const trendHealthForRegime = assessTrendHealth(monthlyMACDForRegime, dailyMACDForRegime, adxForRegime, null);
                        currentRegime = detectMarketRegime(adxForRegime, null, trendHealthForRegime);
                        detectedRegimeModel = regimeEnsemble.models[currentRegime] || regimeEnsemble.models.fallback;
                        console.log(`Current regime detected: ${currentRegime}, using model: ${detectedRegimeModel ? currentRegime : 'fallback'}`);
                    }
                }
                
                // Now that all variables are defined, apply Philosophy Framework
                // Calculate price vs 200-DMA for context (full distance: positive = above, negative = below)
                // Note: This is different from the indicator calculation which only uses percentage above
                const priceVs200DMA = sma200_arr[lastIdx] ? ((currentPrice - sma200_arr[lastIdx]) / sma200_arr[lastIdx]) * 100 : null;
                
                // Always try to apply philosophy framework
                console.log('Attempting to apply philosophy framework...');
                console.log('Monthly MACD data:', monthlyMACDForLastDay);
                console.log('FINAL_WEIGHTS:', FINAL_WEIGHTS);
                console.log('Raw scores:', rawScoresWithNames);
                
                try {
                    if (typeof applyPhilosophyFramework === 'function') {
                        philosophyResult = applyPhilosophyFramework(rawScoresWithNames, FINAL_WEIGHTS, {
                            monthlyMACD: monthlyMACDForLastDay,
                            dailyMACD: dailyMACDForLastDay,
                            adxData: {
                                adx: adxData.adx[lastIdx],
                                pdi: adxData.pdi[lastIdx],
                                mdi: adxData.mdi[lastIdx]
                            },
                            rsi: dailyIndicatorArrays.rsiArr[lastIdx],
                            bollingerBands: {
                                pctB: pctB,
                                upper: upperBB,
                                lower: lowerBB
                            },
                            zScore: zScore50, // Using 50-day MA z-score instead of 200-day MA
                            priceVs200DMA: priceVs200DMA,
                            sma50: sma50_arr[lastIdx],
                            sma100: sma100_arr[lastIdx],
                            sma200: sma200_arr[lastIdx],
                            fibLevels: fibLevels,
                            priorHighs: recentHighs,
                            priorLows: recentLows,
                            priceHistory: priceHistory,
                            currentPrice: currentPrice
                        });
                        
                        if (philosophyResult && philosophyResult.finalScore !== undefined) {
                            philosophyAlignedScore = philosophyResult.finalScore;
                            console.log('✓ Philosophy Framework Result:', philosophyResult);
                        } else {
                            console.warn('Philosophy framework returned invalid result:', philosophyResult);
                            philosophyResult = null;
                        }
                    } else {
                        console.error('applyPhilosophyFramework function not found!');
                        philosophyResult = null;
                    }
                } catch (error) {
                    console.error('✗ Error applying philosophy framework:', error);
                    console.error('Error name:', error.name);
                    console.error('Error message:', error.message);
                    console.error('Error stack:', error.stack);
                    // Fall back to original score if framework fails
                    philosophyResult = null;
                }
                
                // Debug: Log if philosophy framework didn't run
                if (!philosophyResult) {
                    console.warn('⚠ Philosophy framework did not produce a result. Using original score.');
                }

                renderChart(dates, closes, sma50_arr, sma100_arr, sma200_arr, sma1050_arr, upperBBs, lowerBBs, fibLevels, historicalDates, historicalScores);
                renderMACDChart('dailyMacdChart', dailyData.dates, macdData, 'daily');
                renderMACDChart('monthlyMacdChart', monthlyData.dates, macdDataMonthly, 'monthly');
                renderScoreTimeSeriesChart(historicalDates, historicalScores);
                // Use the primary training lookahead window for display (match training to validation)
                const displayLookahead = LOOKAHEAD_WINDOWS[LOOKAHEAD_WINDOWS.length - 1]; // Use last (longest) window
                // Use finalTotalScore (raw weighted score) for main display, not philosophyAlignedScore
                // Philosophy framework result is only for display in the philosophy card
                renderResults(ticker, companyName, currentPrice, finalTotalScore, scores, maStats, recentHighLow, fibLevels, historicalStats, historicalDates, displayLookahead, validationResults, REFERENCE_RIDGE_WEIGHTS, ridgeHistoricalStats, ridgeValidationResults, philosophyResult, useRegimeSwitching ? currentRegime : null, dates, closes);

            } catch (error) {
                console.error("Signal calculation error:", error);
                errorMsg.innerText = `Error: ${error.message}`;
                errorMsg.classList.remove('hidden');
                resultsArea.classList.add('hidden');
            }
            finally {
                loading.classList.add('hidden');
            }
        }


        function renderResults(ticker, companyName, currentPrice, totalScore, scores, maStats, recentHighLow, fibLevels, historicalStats, historicalDates, lookaheadDays, validationResults, referenceRidgeWeights = {}, ridgeHistoricalStats = null, ridgeValidationResults = null, philosophyResult = null, currentRegime = null, dates = null, closes = null) {
            const resultsArea = document.getElementById('resultsArea');
            const finalScoreCard = document.getElementById('finalScoreCard');
            
            // Check which model is selected (show reference stats when Gradient Boosting or Elastic Net is selected)
            const modelSelection = document.getElementById('modelSelection').value;
            const useGradientBoosting = modelSelection === 'gradientboosting';
            const useElasticNet = modelSelection === 'elasticnet';
            const showRidgeReference = useGradientBoosting || useElasticNet;
            
            // Update table header to conditionally show Ridge (Ref) column
            const breakdownTableHeader = document.querySelector('#breakdownTable thead tr');
            if (breakdownTableHeader) {
                const ridgeRefHeader = breakdownTableHeader.querySelector('th:last-child');
                if (showRidgeReference && ridgeRefHeader && ridgeRefHeader.textContent.includes('Ridge (Ref)')) {
                    ridgeRefHeader.style.display = '';
                } else if (!showRidgeReference && ridgeRefHeader) {
                    ridgeRefHeader.style.display = 'none';
                }
            }
            
            // Update grid columns for historical stats and validation metrics displays
            const historicalStatsDisplayEl = document.getElementById('historicalStatsDisplay');
            const validationMetricsDisplayEl = document.getElementById('validationMetricsDisplay');
            if (historicalStatsDisplayEl) {
                historicalStatsDisplayEl.className = `grid ${showRidgeReference ? 'grid-cols-3' : 'grid-cols-2'} gap-y-1 gap-x-4 text-xs font-mono text-gray-400 border-b border-gray-700/50 pb-2 mb-2`;
            }
            if (validationMetricsDisplayEl) {
                validationMetricsDisplayEl.className = `grid ${showRidgeReference ? 'grid-cols-3' : 'grid-cols-2'} gap-y-1 gap-x-4 text-xs font-mono text-gray-400 border-b border-gray-700/50 pb-2 mb-2 mt-2`;
            }

            document.getElementById('tickerCompanyNameDisplay').innerText = companyName;
            document.getElementById('currentPriceDisplay').innerText = '$' + currentPrice.toFixed(2);
            document.getElementById('finalScoreDisplay').innerText = (totalScore > 0 ? "+" : "") + (totalScore * 100).toFixed(0) + '%';

            // Calculate probability of stock moving higher during forecast horizon
            // Use sigmoid function to convert score (-1 to +1 range) to probability (0% to 100%)
            // Score of 0 = 50% probability, positive scores = higher probability, negative = lower
            const probabilityHigher = Math.max(0, Math.min(100, 50 + (totalScore * 50)));
            document.getElementById('probabilityHigherDisplay').innerText = probabilityHigher.toFixed(1) + '%';

            // Signal label and styling from composite score (-1 to +1). More gradation for nuance.
            let signalText = 'NEUTRAL';
            let bgColorClass = 'bg-yellow-900/30';
            let textColorClass = 'text-yellow-400';
            let borderColor = '#fbbf24';

            if (totalScore >= 0.25) {
                signalText = 'STRONGLY BULLISH';
                bgColorClass = 'bg-green-900/30';
                textColorClass = 'text-green-400';
                borderColor = '#10b981';
            } else if (totalScore >= 0.10) {
                signalText = 'BULLISH';
                bgColorClass = 'bg-emerald-900/30';
                textColorClass = 'text-emerald-400';
                borderColor = '#059669';
            } else if (totalScore >= 0.05) {
                signalText = 'LEAN BULLISH';
                bgColorClass = 'bg-teal-900/30';
                textColorClass = 'text-teal-400';
                borderColor = '#2dd4bf';
            } else if (totalScore > -0.05) {
                signalText = 'NEUTRAL';
                bgColorClass = 'bg-yellow-900/30';
                textColorClass = 'text-yellow-400';
                borderColor = '#fbbf24';
            } else if (totalScore >= -0.10) {
                signalText = 'LEAN BEARISH';
                bgColorClass = 'bg-amber-900/30';
                textColorClass = 'text-amber-400';
                borderColor = '#f59e0b';
            } else if (totalScore >= -0.25) {
                signalText = 'BEARISH';
                bgColorClass = 'bg-orange-900/30';
                textColorClass = 'text-orange-400';
                borderColor = '#f97316';
            } else {
                signalText = 'STRONGLY BEARISH';
                bgColorClass = 'bg-red-900/30';
                textColorClass = 'text-red-400';
                borderColor = '#ef4444';
            }

            const signalTextDisplay = document.getElementById('signalTextDisplay');
            signalTextDisplay.innerText = signalText;
            signalTextDisplay.className = `text-lg font-extrabold px-3 py-1 rounded-full shadow-lg transition-colors ${textColorClass} ${bgColorClass} border`;
            signalTextDisplay.style.borderColor = borderColor;

            finalScoreCard.style.borderImage = `linear-gradient(to bottom right, ${borderColor}, #0a4d96) 1`;

            // Display Philosophical Framework Analysis
            const philosophyDisplay = document.getElementById('philosophyDisplay');
            console.log('=== PHILOSOPHY FRAMEWORK DISPLAY ===');
            console.log('Philosophy Display Element:', philosophyDisplay);
            console.log('Philosophy Result:', philosophyResult);
            console.log('Philosophy Result type:', typeof philosophyResult);
            
            if (!philosophyDisplay) {
                console.error('❌ philosophyDisplay element not found in DOM!');
            }
            
            if (philosophyDisplay && philosophyResult) {
                console.log('✓ Displaying philosophy framework results');
                const meta = philosophyResult.metadata;
                const mainTrend = meta.mainTrend;
                const trendHealth = meta.trendHealth;
                const extremes = meta.extremes;
                const momentum = meta.momentum;
                const vulnerability = meta.vulnerability;
                const reversal = meta.reversalClassification;
                const supportResistance = meta.supportResistance;
                const supportBounce = meta.supportBounce;
                const regime = meta.regime;
                
                // Trend alignment indicator
                const trendAlignIcon = philosophyResult.trendAlignment === 'ALIGNED' ? '✅' : 
                                     philosophyResult.trendAlignment === 'CONFLICTING' ? '⚠️' : '➖';
                const trendAlignColor = philosophyResult.trendAlignment === 'ALIGNED' ? 'text-green-400' : 
                                       philosophyResult.trendAlignment === 'CONFLICTING' ? 'text-red-400' : 'text-gray-400';
                
                // Risk level styling
                const riskColor = philosophyResult.riskLevel === 'HIGH' ? 'text-red-400' : 
                                 philosophyResult.riskLevel === 'LOW' ? 'text-green-400' : 'text-yellow-400';
                
                // Entry opportunity indicator
                const entryIcon = philosophyResult.entryOpportunity ? '🎯' : '🚫';
                const entryColor = philosophyResult.entryOpportunity ? 'text-green-400' : 'text-gray-400';
                
                let philosophyHTML = `
                    <div class="bg-gray-700/60 rounded-lg p-3 border-2 border-blue-500/40 mt-3 shadow-lg">
                        <h3 class="text-blue-400 text-sm uppercase tracking-wider mb-2 font-semibold border-b border-blue-500/30 pb-1.5">Philosophical Framework Analysis</h3>
                        
                        <div class="grid grid-cols-2 gap-3 text-xs">
                            <div>
                                <span class="text-gray-400">Main Trend:</span>
                                <span class="ml-2 font-semibold ${mainTrend === 'BULLISH' ? 'text-green-400' : mainTrend === 'BEARISH' ? 'text-red-400' : 'text-gray-400'}">
                                    ${mainTrend} (Monthly MACD)
                                </span>
                            </div>
                            <div>
                                <span class="text-gray-400">Trend Alignment:</span>
                                <span class="ml-2 font-semibold ${trendAlignColor}">
                                    ${trendAlignIcon} ${philosophyResult.trendAlignment}
                                </span>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Trend Health:</span>
                                <span class="ml-2 font-semibold ${trendHealth.isHealthy ? 'text-green-400' : 'text-red-400'}">
                                    ${trendHealth.strength} ${trendHealth.isHealthy ? '✅' : '⚠️'}
                                </span>
                            </div>
                            <div>
                                <span class="text-gray-400">Risk Level:</span>
                                <span class="ml-2 font-semibold ${riskColor}">
                                    ${philosophyResult.riskLevel}
                                </span>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Signal Type:</span>
                                <span class="ml-2 font-semibold text-blue-400">
                                    ${philosophyResult.signalType.replace('_', ' ')}
                                </span>
                            </div>
                            <div>
                                <span class="text-gray-400">Trend Entry Opportunity:</span>
                                <span class="ml-2 font-semibold ${entryColor}">
                                    ${entryIcon} ${philosophyResult.entryOpportunity ? 'YES' : 'NO'}
                                </span>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Market Regime:</span>
                                <span class="ml-2 font-semibold text-purple-400">
                                    ${regime.replace('_', ' ')}
                                </span>
                            </div>
                            <div>
                                <span class="text-gray-400">Main Trend Vulnerability:</span>
                                <span class="ml-2 font-semibold ${vulnerability > 0.7 ? 'text-red-400' : vulnerability > 0.4 ? 'text-yellow-400' : 'text-green-400'}">
                                    ${(vulnerability * 100).toFixed(0)}%
                                </span>
                            </div>
                        </div>
                        
                        ${extremes.isExtreme ? `
                            <div class="mt-2 pt-2 border-t border-gray-700/50">
                                <span class="text-gray-400 text-xs">Extreme Conditions:</span>
                                <span class="ml-2 text-xs font-semibold ${extremes.extremeType === 'OVERBOUGHT' ? 'text-red-400' : 'text-green-400'}">
                                    ${extremes.extremeType} (${extremes.extremeIndicators.join(', ')})
                                </span>
                            </div>
                        ` : ''}
                        
                        ${momentum.isSlowing ? `
                            <div class="mt-1.5">
                                <span class="text-gray-400 text-xs">Momentum:</span>
                                <span class="ml-2 text-xs font-semibold text-yellow-400">
                                    ${momentum.slowdownType} ⚠️
                                </span>
                            </div>
                        ` : ''}
                        
                        ${reversal.reversalType !== 'TREND_CONTINUATION' ? `
                            <div class="mt-1.5">
                                <span class="text-gray-400 text-xs">Reversal Type:</span>
                                <span class="ml-2 text-xs font-semibold ${reversal.reversalType === 'PULLBACK' ? 'text-green-400' : 'text-red-400'}">
                                    ${reversal.reversalType.replace('_', ' ')} (${(reversal.confidence * 100).toFixed(0)}% confidence)
                                </span>
                            </div>
                        ` : ''}
                        
                        ${supportResistance.nearestSupport && supportResistance.isAtSupport ? `
                            <div class="mt-1.5">
                                <span class="text-gray-400 text-xs">Support Level:</span>
                                <span class="ml-2 text-xs font-semibold text-green-400">
                                    At ${supportResistance.nearestSupport.type} ($${supportResistance.nearestSupport.level.toFixed(2)})
                                    ${supportBounce.bounced ? ' - Bounced ✅' : ''}
                                </span>
                            </div>
                        ` : ''}
                        
                        ${philosophyResult.warningFlags.length > 0 ? `
                            <div class="mt-2 pt-2 border-t border-red-700/50">
                                <span class="text-red-400 text-xs font-semibold">⚠️ Warning Flags:</span>
                                <ul class="mt-0.5 space-y-0.5">
                                    ${philosophyResult.warningFlags.map(flag => `<li class="text-red-300 text-xs">• ${flag}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
                
                philosophyDisplay.innerHTML = philosophyHTML;
                console.log('✓ Philosophy framework HTML inserted into DOM');
            } else if (philosophyDisplay) {
                console.warn('⚠ Philosophy result is null/undefined, clearing display');
                philosophyDisplay.innerHTML = '<div class="text-yellow-400 text-xs p-2 bg-yellow-900/20 rounded border border-yellow-700/50">Philosophical Framework: No analysis available (check console for details)</div>';
            } else {
                console.error('❌ Cannot display philosophy framework - element not found');
            }

            const historicalStatsDisplay = document.getElementById('historicalStatsDisplay');
            if (historicalStats && historicalDates) {
                const getRetClass = (ret) => {
                    if (ret > 0) return 'text-green-400';
                    if (ret < 0) return 'text-red-400';
                    return 'text-gray-400';
                };
                const getRetText = (ret) => {
                    if (ret === null) return 'N/A';
                    return (ret > 0 ? '+' : '') + ret.toFixed(2) + '%';
                };

                const bullRetClass = getRetClass(historicalStats.bullishReturn);
                const bearRetClass = getRetClass(historicalStats.bearishReturn);

                // Helper function to format Ridge Regression stats with smaller, less visible font
                const getRidgeStat = (stat) => {
                    if (!ridgeHistoricalStats) return '<span class="text-gray-600" style="font-size: 0.9em;">-</span>';
                    const value = ridgeHistoricalStats[stat];
                    if (value === null || value === undefined) return '<span class="text-gray-600" style="font-size: 0.9em;">N/A</span>';
                    // bullishReturn and bearishReturn are already percentages (multiplied by 100), scores need multiplication
                    if (typeof value === 'number' && (stat === 'avgScore' || stat === 'minScore' || stat === 'maxScore')) {
                        return `<span class="text-gray-500" style="font-size: 0.9em;">${(value * 100).toFixed(2)}%</span>`;
                    } else if (typeof value === 'number' && (stat === 'bullishReturn' || stat === 'bearishReturn')) {
                        return `<span class="text-gray-500" style="font-size: 0.9em;">${(value > 0 ? '+' : '') + value.toFixed(2)}%</span>`;
                    }
                    return `<span class="text-gray-500" style="font-size: 0.9em;">${value}</span>`;
                };

                const getRidgeRetClass = (ret) => {
                    if (!ridgeHistoricalStats || ret === null) return 'text-gray-500';
                    if (ret > 0) return 'text-green-500';
                    if (ret < 0) return 'text-red-500';
                    return 'text-gray-500';
                };

                const ridgeBullRetClass = getRidgeRetClass(ridgeHistoricalStats ? ridgeHistoricalStats.bullishReturn : null);
                const ridgeBearRetClass = getRidgeRetClass(ridgeHistoricalStats ? ridgeHistoricalStats.bearishReturn : null);

                const headerColSpan = showRidgeReference ? 'col-span-3' : 'col-span-2';
                historicalStatsDisplay.innerHTML = `
                    <span class="${headerColSpan} text-white font-semibold text-sm border-b border-gray-700/50 pb-1 mb-1">Signal History (Last ${historicalDates.length} Days)</span>

                    <span class="text-gray-200">Score Percentile:</span> <span id="stat-percentile" class="text-right text-white">${historicalStats.percentile !== null ? Math.round(historicalStats.percentile) + 'th' : 'N/A'}</span>
                    ${showRidgeReference ? (ridgeHistoricalStats && ridgeHistoricalStats.percentile !== null ? `<span class="text-gray-500 text-right" style="font-size: 0.9em;">${Math.round(ridgeHistoricalStats.percentile)}th</span>` : '<span class="text-gray-500 text-right" style="font-size: 0.9em;">-</span>') : ''}

                    <span class="text-gray-400">Min/Max Score:</span>
                    <span id="stat-min-max" class="text-right text-white">
                        ${renderScoreQuartileBar({
                            min: historicalStats.minScore,
                            q1: historicalStats.q1Score,
                            q2: historicalStats.medianScore,
                            q3: historicalStats.q3Score,
                            max: historicalStats.maxScore,
                            current: totalScore
                        })}
                    </span>
                    ${showRidgeReference && ridgeHistoricalStats ? `<span class="text-gray-500" style="font-size: 0.9em;">${ridgeHistoricalStats.minScore !== null ? (ridgeHistoricalStats.minScore * 100).toFixed(2) + '%' : 'N/A'} / ${ridgeHistoricalStats.maxScore !== null ? (ridgeHistoricalStats.maxScore * 100).toFixed(2) + '%' : 'N/A'}</span>` : ''}

                    <span class="text-gray-400"><span class="text-green-400">Bullish</span> Count (>10%):</span> <span id="stat-bull-count" class="text-right text-green-400 font-semibold">${historicalStats.bullishCount}</span>
                    ${showRidgeReference ? getRidgeStat('bullishCount') : ''}

                    <span class="text-gray-400"><span class="text-red-400">Bearish</span> Count (<0%):</span> <span id="stat-bear-count" class="text-right text-red-400 font-semibold">${historicalStats.bearishCount}</span>
                    ${showRidgeReference ? getRidgeStat('bearishCount') : ''}

                    <span class="text-gray-400">Neutral Count (0-10%):</span> <span id="stat-neutral-count" class="text-right text-yellow-400 font-semibold">${historicalStats.neutralCount}</span>
                    ${showRidgeReference ? getRidgeStat('neutralCount') : ''}

                    <span class="text-gray-400 font-bold border-t border-gray-700/50 pt-1 mt-1 ${headerColSpan}">Avg. ${lookaheadDays}-Day Forward Return</span>

                    <span class="text-gray-400">After <span class="text-green-400">Bullish</span> Signal:</span> <span id="stat-bull-ret" class="text-right ${bullRetClass} font-semibold">${getRetText(historicalStats.bullishReturn)}</span>
                    ${showRidgeReference ? `<span class="text-right ${ridgeBullRetClass}" style="font-size: 0.9em;">${ridgeHistoricalStats ? getRetText(ridgeHistoricalStats.bullishReturn) : '-'}</span>` : ''}

                    <span class="text-gray-400">After <span class="text-red-400">Bearish</span> Signal:</span> <span id="stat-bear-ret" class="text-right ${bearRetClass} font-semibold">${getRetText(historicalStats.bearishReturn)}</span>
                    ${showRidgeReference ? `<span class="text-right ${ridgeBearRetClass}" style="font-size: 0.9em;">${ridgeHistoricalStats ? getRetText(ridgeHistoricalStats.bearishReturn) : '-'}</span>` : ''}
                `;
            } else {
                historicalStatsDisplay.innerHTML = '<span class="col-span-3 text-gray-400">Not enough historical data to calculate signal statistics.</span>';
            }

            // Display walk-forward validation metrics
            const validationMetricsDisplay = document.getElementById('validationMetricsDisplay');
            if (validationResults && validationResults.error) {
                const extra = [];
                if (validationResults.availableDataPoints !== undefined) {
                    extra.push(`Days: ${validationResults.availableDataPoints}`);
                }
                if (validationResults.validRowCount !== undefined) {
                    extra.push(`Valid rows: ${validationResults.validRowCount}`);
                }
                const extraText = extra.length ? ` (${extra.join(' | ')})` : '';
                validationMetricsDisplay.innerHTML = `<span class="col-span-3 text-yellow-400 text-xs">${validationResults.error}${extraText}</span>`;
            } else if (validationResults && validationResults.overall && validationResults.overall.totalSignals > 0) {
                const overall = validationResults.overall;
                const getMetricClass = (val, isPositive = true) => {
                    if (val === null || val === undefined) return 'text-gray-400';
                    if (isPositive) return val > 0 ? 'text-green-400' : val < 0 ? 'text-red-400' : 'text-gray-400';
                    return 'text-gray-400';
                };

                // Helper function to format Ridge Regression validation stats
                const getRidgeValidationStat = (value, formatter = (v) => v) => {
                    if (!ridgeValidationResults || !ridgeValidationResults.overall) return '<span class="text-gray-600" style="font-size: 0.9em;">-</span>';
                    if (value === null || value === undefined) return '<span class="text-gray-600" style="font-size: 0.9em;">-</span>';
                    return `<span class="text-gray-500" style="font-size: 0.9em;">${formatter(value)}</span>`;
                };

                // Calculate Win/Loss Ratio (most important metric - shows asymmetry)
                const winLossRatio = overall.avgLoss !== 0 && overall.avgLoss !== null ? Math.abs(overall.avgWin / overall.avgLoss) : null;
                const ridgeWinLossRatio = ridgeValidationResults && ridgeValidationResults.overall && ridgeValidationResults.overall.avgLoss !== 0 && ridgeValidationResults.overall.avgLoss !== null ? Math.abs(ridgeValidationResults.overall.avgWin / ridgeValidationResults.overall.avgLoss) : null;
                const getWinLossRatioClass = (ratio) => {
                    if (ratio === null || ratio === undefined) return 'text-gray-400';
                    if (ratio >= 2.0) return 'text-green-400'; // Excellent: 2:1 or better
                    if (ratio >= 1.5) return 'text-green-300'; // Good: 1.5:1 to 2:1
                    if (ratio >= 1.2) return 'text-yellow-400'; // Acceptable: 1.2:1 to 1.5:1
                    if (ratio >= 1.0) return 'text-yellow-500'; // Marginal: 1:1 to 1.2:1
                    return 'text-red-400'; // Poor: less than 1:1
                };

                const validationHeaderColSpan = showRidgeReference ? 'col-span-3' : 'col-span-2';
                validationMetricsDisplay.innerHTML = `
                    <span class="${validationHeaderColSpan} text-blue-400 font-semibold text-sm border-b border-gray-700/50 pb-1 mb-1">Walk-Forward Validation <span class="text-xs text-gray-500">(Out-of-Sample)</span></span>
                    
                    <span class="text-gray-200">Sharpe Ratio:</span> <span class="text-right ${getMetricClass(overall.sharpeRatio)} font-semibold">${overall.sharpeRatio.toFixed(2)}</span>
                    ${showRidgeReference ? getRidgeValidationStat(ridgeValidationResults && ridgeValidationResults.overall ? ridgeValidationResults.overall.sharpeRatio : null, v => v.toFixed(2)) : ''}

                    <span class="text-gray-400">Avg Return:</span> <span class="text-right ${getMetricClass(overall.avgReturn)} font-semibold">${(overall.avgReturn > 0 ? '+' : '') + (overall.avgReturn * 100).toFixed(2)}%</span>
                    ${showRidgeReference ? getRidgeValidationStat(ridgeValidationResults && ridgeValidationResults.overall ? ridgeValidationResults.overall.avgReturn : null, v => (v > 0 ? '+' : '') + (v * 100).toFixed(2) + '%') : ''}

                    <span class="text-gray-400">Win/Loss Ratio:</span> <span class="text-right ${getWinLossRatioClass(winLossRatio)} font-semibold">${winLossRatio !== null ? winLossRatio.toFixed(2) + ':1' : 'N/A'}</span>
                    ${showRidgeReference && ridgeWinLossRatio !== null ? `<span class="text-gray-500" style="font-size: 0.9em;">${ridgeWinLossRatio.toFixed(2)}:1</span>` : ''}

                    <div class="${validationHeaderColSpan} rounded border border-gray-500/50 py-1 my-0.5 grid ${showRidgeReference ? 'grid-cols-3' : 'grid-cols-2'} gap-x-2">
                        <span class="text-gray-400 text-xs">Avg Win:</span>
                        <span class="text-right text-xs ${getMetricClass(overall.avgWin)}">${(overall.avgWin > 0 ? '+' : '') + (overall.avgWin * 100).toFixed(2)}%</span>
                        ${showRidgeReference && ridgeValidationResults && ridgeValidationResults.overall && ridgeValidationResults.overall.avgWin !== null && ridgeValidationResults.overall.avgWin !== undefined ? `<span class="text-gray-500 text-xs text-right" style="font-size: 0.9em;">${(ridgeValidationResults.overall.avgWin > 0 ? '+' : '') + (ridgeValidationResults.overall.avgWin * 100).toFixed(2)}%</span>` : ''}
                        <span class="text-gray-400 text-xs">Avg Loss:</span>
                        <span class="text-right text-xs ${getMetricClass(overall.avgLoss)}">${(overall.avgLoss * 100).toFixed(2)}%</span>
                        ${showRidgeReference && ridgeValidationResults && ridgeValidationResults.overall && ridgeValidationResults.overall.avgLoss !== null && ridgeValidationResults.overall.avgLoss !== undefined ? `<span class="text-gray-500 text-xs text-right" style="font-size: 0.9em;">${(ridgeValidationResults.overall.avgLoss * 100).toFixed(2)}%</span>` : ''}
                    </div>

                    <span class="text-gray-400 text-xs">Hit Rate:</span> <span class="text-right text-xs ${getMetricClass(overall.hitRate)}">${(overall.hitRate * 100).toFixed(1)}%</span>
                    ${showRidgeReference ? getRidgeValidationStat(ridgeValidationResults && ridgeValidationResults.overall ? ridgeValidationResults.overall.hitRate : null, v => (v * 100).toFixed(1) + '%') : ''}

                    <span class="text-gray-400 text-xs">Total Signals:</span> <span class="text-right text-xs text-gray-300">${overall.totalSignals}</span>
                    ${showRidgeReference ? getRidgeValidationStat(ridgeValidationResults && ridgeValidationResults.overall ? ridgeValidationResults.overall.totalSignals : null, v => v) : ''}

                    <span class="text-gray-400 text-xs">Validation Periods:</span> <span class="text-right text-xs text-gray-300">${validationResults.periods ? validationResults.periods.length : 0}</span>
                    ${showRidgeReference ? getRidgeValidationStat(ridgeValidationResults && ridgeValidationResults.periods ? ridgeValidationResults.periods.length : null, v => v) : ''}
                `;
            } else if (validationResults && validationResults.overall && validationResults.overall.totalSignals === 0) {
                validationMetricsDisplay.innerHTML = '<span class="col-span-3 text-yellow-400 text-xs">Walk-forward validation ran but found no valid test periods. This may occur if indicators have many null values in the historical data.</span>';
            } else if (validationResults === null) {
                validationMetricsDisplay.innerHTML = '<span class="col-span-3 text-yellow-400 text-xs">Walk-forward validation was not executed. Check console for details about weight calculation and data availability.</span>';
            } else {
                // validationResults exists but doesn't have expected structure
                const errorMsg = validationResults.error || 'Unknown validation issue';
                validationMetricsDisplay.innerHTML = `<span class="col-span-3 text-yellow-400 text-xs">Walk-forward validation issue: ${errorMsg}. Check console for details.</span>`;
            }

            const keyTechLevelsDisplay = document.getElementById('keyTechLevelsDisplay');
            keyTechLevelsDisplay.innerHTML = '';

            const maSection = document.createElement('div');
            maSection.className = 'mb-2';
            maSection.innerHTML = `
                <h4 class="text-xs uppercase tracking-wider text-gray-400 mb-0.5 font-semibold">Moving Averages (Daily)</h4>
                <div class="grid grid-cols-4 gap-x-2 text-xs font-mono py-0.5 font-bold border-b border-gray-700/50">
                    <span class="text-gray-400">MA Level</span>
                    <span class="text-gray-400 text-right">Value</span>
                    <span class="text-gray-400 text-right">Dist to Price</span>
                    <span class="text-gray-400 text-right">Z-Score (200)</span>
                </div>
            `;
            keyTechLevelsDisplay.appendChild(maSection);

            const maPoints = [
                { label: '50-DMA', stat: maStats.ma50 },
                { label: '100-DMA', stat: maStats.ma100 },
                { label: '200-DMA', stat: maStats.ma200 }
            ];

            // Define MA colors to match the chart
            const maColors = {
                '50-DMA': '#ef4444',  // red
                '100-DMA': '#fde047', // light yellow
                '200-DMA': '#3b82f6'  // blue
            };

            maPoints.forEach(p => {
                const dist = p.stat.dist;
                const zScore = p.stat.zScore;
                const maColor = maColors[p.label] || 'text-gray-400'; // Get color or fallback

                // Color logic: positive dist = traveling UP to MA (green/bullish), negative dist = traveling DOWN to MA (red/bearish)
                // Use a threshold to determine when it's significantly above/below vs neutral
                let distClass = 'text-gray-400';
                if (dist !== null) {
                    if (dist > 1.0) {
                        distClass = 'text-green-400'; // Price below MA, traveling up (bullish - price needs to rise)
                    } else if (dist < -1.0) {
                        distClass = 'text-red-400'; // Price above MA, traveling down (bearish - price needs to fall)
                    } else {
                        distClass = 'text-yellow-400'; // Price near MA (neutral)
                    }
                }
                const zScoreClass = zScore === null ? 'text-gray-400' : (Math.abs(zScore) > 2 ? 'text-yellow-400' : 'text-gray-400');

                const row = document.createElement('div');
                row.className = 'grid grid-cols-4 gap-x-2 text-xs font-mono py-0.5';
                row.innerHTML = `
                    <span style="color: ${maColor};" class="font-semibold">${p.label}</span>
                    <span class="text-gray-300 text-right">$${p.stat.val !== null ? p.stat.val.toFixed(2) : 'N/A'}</span>
                    <span class="text-right ${distClass}">${dist !== null ? (dist > 0 ? '+' : '') + dist.toFixed(2) + '%' : 'N/A'}</span>
                    <span class="text-right ${zScoreClass}">${zScore !== null ? zScore.toFixed(2) : '--'}</span>
                `;
                keyTechLevelsDisplay.appendChild(row);
            });

            const hlSection = document.createElement('div');
            hlSection.className = 'border-t border-gray-700/50 pt-4 mt-4';

            // Safeguard in case we don't have proper 52-week data
            const rangeLow = recentHighLow.recentLow;
            const rangeHigh = recentHighLow.recentHigh;
            const current = currentPrice;

            let lowPos = 0;
            let highPos = 100;
            let currentPos = 50;

            if (
                typeof rangeLow === 'number' &&
                typeof rangeHigh === 'number' &&
                rangeHigh > rangeLow &&
                typeof current === 'number'
            ) {
                lowPos = 0;
                highPos = 100;
                currentPos = ((current - rangeLow) / (rangeHigh - rangeLow)) * 100;
                currentPos = Math.max(0, Math.min(100, currentPos));
            }

            hlSection.innerHTML = `
                <h4 class="text-xs uppercase tracking-wider text-gray-400 mb-3 font-semibold">52-Week Range</h4>
                <!-- 52-week mini range bar -->
                <div class="mt-1 pt-6">
                    <div class="relative h-2 w-full rounded-full bg-gray-800 overflow-visible">
                        <!-- Full 52-week band -->
                        <div class="absolute inset-0 bg-gradient-to-r from-red-500/40 via-yellow-500/40 to-green-500/40"></div>
                        <!-- Low label above bar -->
                        <div 
                            class="absolute text-[10px] font-mono text-red-400 whitespace-nowrap text-center leading-tight"
                            style="left: 0%; top: -2.25rem; transform: translateX(0%);"
                        >
                            Low<br/>$${rangeLow?.toFixed(2) ?? '--'}
                        </div>
                        <!-- Current price marker and label -->
                        <div 
                            class="absolute -top-1 h-4 w-0.5 bg-white shadow-lg"
                            style="left: ${currentPos}%; transform: translateX(-50%);"
                            title="Current Price"
                        ></div>
                        <div 
                            class="absolute text-[10px] font-mono text-white whitespace-nowrap text-center leading-tight"
                            style="left: ${currentPos}%; top: -2.25rem; transform: translateX(-50%);"
                        >
                            Current<br/>$${current?.toFixed(2) ?? '--'}
                        </div>
                        <!-- High label above bar -->
                        <div 
                            class="absolute text-[10px] font-mono text-green-400 whitespace-nowrap text-center leading-tight"
                            style="left: 100%; top: -2.25rem; transform: translateX(-100%);"
                        >
                            High<br/>$${rangeHigh?.toFixed(2) ?? '--'}
                        </div>
                    </div>
                </div>
            `;
            keyTechLevelsDisplay.appendChild(hlSection);


            if (fibLevels) {
                const fibSection = document.createElement('div');
                fibSection.className = 'border-t border-gray-700/50 pt-4 mt-4';
                fibSection.innerHTML = `
                    <h4 class="text-xs uppercase tracking-wider text-gray-400 mb-0.5 font-semibold">Fibonacci Retracement (${fibLevels.measuredTrend} Swing)</h4>
                    <div class="flex justify-between text-xs font-mono text-white mb-0.5">
                        <span>Swing Start (${fibLevels.swingStartType}):</span>
                        <span class="text-white">$${fibLevels.swingStart.toFixed(2)} (${fibLevels.swingStartDate})</span>
                    </div>
                    <div class="flex justify-between text-xs font-mono text-white mb-1 border-b border-gray-700/50 pb-0.5">
                        <span>Swing End (${fibLevels.swingEndType}):</span>
                        <span class="text-white">$${fibLevels.swingEnd.toFixed(2)} (${fibLevels.swingEndDate})</span>
                    </div>
                `;

                const fibLevelsList = ['38.2%', '50.0%', '61.8%'];
                fibLevelsList.forEach(level => {
                    const price = fibLevels[level];
                    const distance = fibLevels[level + 'Dist'];
                    if (price) {
                        // Color logic: positive dist = traveling UP to fib level (green/bullish), negative dist = traveling DOWN to fib level (red/bearish)
                        // Use a threshold to determine when it's significantly above/below vs neutral
                        let distClass = 'text-gray-400';
                        if (distance !== null && distance !== undefined) {
                            if (distance > 1.0) {
                                distClass = 'text-green-400'; // Price below fib level, traveling up (bullish - price needs to rise)
                            } else if (distance < -1.0) {
                                distClass = 'text-red-400'; // Price above fib level, traveling down (bearish - price needs to fall)
                            } else {
                                distClass = 'text-yellow-400'; // Price near fib level (neutral)
                            }
                        }
                        const levelColor = fibColors[level]; // Get color from fibColors
                        fibSection.innerHTML += `
                            <div class="grid grid-cols-3 gap-x-2 text-xs font-mono py-0.5">
                                <span style="color: ${levelColor};" class="font-semibold">${level} Level:</span>
                                <span class="text-gray-300 text-right">$${price.toFixed(2)}</span>
                                <span class="text-right ${distClass}">${(distance > 0 ? '+' : '') + distance.toFixed(2)}%</span>
                            </div>
                        `;
                    }
                });
                keyTechLevelsDisplay.appendChild(fibSection);
            }

            // Add Price Performance section below Fibonacci levels
            if (dates && closes && closes.length > 0 && dates.length > 0) {
                const pricePerfSection = document.createElement('div');
                pricePerfSection.className = 'border-t border-gray-700/50 pt-4 mt-4';
                
                const currentPrice = closes[closes.length - 1];
                const currentDate = new Date(dates[dates.length - 1]);
                
                // Helper function to find price at a specific date
                const findPriceAtDate = (targetDate) => {
                    for (let i = dates.length - 1; i >= 0; i--) {
                        const date = new Date(dates[i]);
                        if (date <= targetDate) {
                            return closes[i];
                        }
                    }
                    return null;
                };
                
                // Calculate performance metrics
                const performanceMetrics = [];
                
                // 1 Day
                if (closes.length >= 2) {
                    const oneDayAgo = closes[closes.length - 2];
                    const change1D = currentPrice - oneDayAgo;
                    const pct1D = (change1D / oneDayAgo) * 100;
                    performanceMetrics.push({ label: '1 Day', change: change1D, percent: pct1D });
                }
                
                // 1 Week (7 days)
                if (closes.length >= 7) {
                    const oneWeekAgo = closes[closes.length - 7];
                    const change1W = currentPrice - oneWeekAgo;
                    const pct1W = (change1W / oneWeekAgo) * 100;
                    performanceMetrics.push({ label: '1 Week', change: change1W, percent: pct1W });
                }
                
                // 1 Month (approximately 21 trading days)
                if (closes.length >= 21) {
                    const oneMonthAgo = closes[closes.length - 21];
                    const change1M = currentPrice - oneMonthAgo;
                    const pct1M = (change1M / oneMonthAgo) * 100;
                    performanceMetrics.push({ label: '1 Month', change: change1M, percent: pct1M });
                }
                
                // YTD (Year to Date)
                const yearStart = new Date(currentDate.getFullYear(), 0, 1);
                const ytdPrice = findPriceAtDate(yearStart);
                if (ytdPrice) {
                    const changeYTD = currentPrice - ytdPrice;
                    const pctYTD = (changeYTD / ytdPrice) * 100;
                    performanceMetrics.push({ label: 'YTD', change: changeYTD, percent: pctYTD });
                }
                
                // 1 Year (approximately 252 trading days)
                if (closes.length >= 252) {
                    const oneYearAgo = closes[closes.length - 252];
                    const change1Y = currentPrice - oneYearAgo;
                    const pct1Y = (change1Y / oneYearAgo) * 100;
                    performanceMetrics.push({ label: '1 Year', change: change1Y, percent: pct1Y });
                } else if (closes.length > 0) {
                    // Use first available price if less than 1 year of data
                    const firstPrice = closes[0];
                    const change1Y = currentPrice - firstPrice;
                    const pct1Y = (change1Y / firstPrice) * 100;
                    performanceMetrics.push({ label: '1 Year', change: change1Y, percent: pct1Y });
                }
                
                // Display performance metrics
                if (performanceMetrics.length > 0) {
                    let metricsHTML = '<h4 class="text-xs uppercase tracking-wider text-gray-400 mb-2 font-semibold">Price Performance</h4>';
                    performanceMetrics.forEach(metric => {
                        const color = metric.percent >= 0 ? 'text-green-400' : 'text-red-400';
                        const sign = metric.percent >= 0 ? '+' : '';
                        const formattedValue = `${sign}${metric.percent.toFixed(2)}%`;
                        const labelClass = metric.label === 'YTD' ? color : 'text-gray-400';
                        const rowContent = `
                            <div class="grid grid-cols-2 gap-x-2 text-xs font-mono py-0.5">
                                <span class="${labelClass}">${metric.label}:</span>
                                <span class="${color} font-semibold text-right">${formattedValue}</span>
                            </div>
                        `;
                        metricsHTML += metric.label === 'YTD'
                            ? `<div class="rounded border border-gray-500/50 my-0.5">${rowContent}</div>`
                            : rowContent;
                    });
                    pricePerfSection.innerHTML = metricsHTML;
                    keyTechLevelsDisplay.appendChild(pricePerfSection);
                }
            }


            const breakdownTableBody = document.getElementById('breakdownTableBody');
            breakdownTableBody.innerHTML = '';

            scores.forEach(item => {
                const contrib = item.score * item.weight;
                const contribText = (contrib > 0 ? '+' : '') + (contrib * 100).toFixed(1) + '%';
                let scoreColor = 'text-yellow-400';
                if (item.score > 0) scoreColor = 'text-green-400';
                else if (item.score < 0) scoreColor = 'text-red-400';
                let contributionClass = scoreColor;
                
                // Calculate Ridge Regression weight if available and Gradient Boosting or Elastic Net is selected
                let ridgeWeightDisplay = '';
                if (showRidgeReference && referenceRidgeWeights && referenceRidgeWeights[item.name] !== undefined) {
                    const ridgeWeight = referenceRidgeWeights[item.name];
                    ridgeWeightDisplay = `<span class="text-gray-500" style="font-size: 0.9em;">${(ridgeWeight * 100).toFixed(1)}%</span>`;
                }
                
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-700/50 transition-colors';
                
                // Create MACD score cell with tooltip if breakdown is available
                let scoreCellContent = `${(item.score > 0 ? '+' : '') + item.score.toFixed(2)}`;
                if (item.macdBreakdown) {
                    const breakdown = item.macdBreakdown;
                    const tooltipId = `macd-tooltip-${item.name.replace(/\s+/g, '-').toLowerCase()}`;
                    scoreCellContent = `
                        <div class="relative inline-block cursor-help group" style="position: relative;">
                            <span class="underline decoration-dotted">${(item.score > 0 ? '+' : '') + item.score.toFixed(2)}</span>
                            <div id="${tooltipId}" class="absolute left-1/2 transform -translate-x-1/2 top-full mt-2 w-80 bg-gray-900 border border-gray-600 rounded-lg shadow-2xl p-4 text-xs z-[9999] opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 pointer-events-none" style="min-width: 320px;">
                                <div class="text-blue-400 font-bold mb-2 text-sm border-b border-gray-600 pb-2">${item.name} Score Breakdown</div>
                                ${breakdown.weightsUsed && breakdown.weightsUsed.volatilityRegime === 'DYNAMIC' ? `
                                <div class="mb-3 pb-2 border-b border-gray-700">
                                    <div class="flex justify-between items-center mb-1">
                                        <span class="text-yellow-400 text-xs font-semibold">Volatility Regime:</span>
                                        <span class="text-white text-xs font-bold">${breakdown.weightsUsed.volatilityRegimeName || 'DYNAMIC'}</span>
                                    </div>
                                    <div class="text-gray-400 text-xs mt-1">Dynamic Weights: A=${breakdown.weightsUsed.rawWeights.A}% B=${breakdown.weightsUsed.rawWeights.B}% C=${breakdown.weightsUsed.rawWeights.C}% D=${breakdown.weightsUsed.rawWeights.D}%</div>
                                </div>
                                ` : ''}
                                <div class="space-y-3 pt-2">
                                    <div class="border-l-2 border-blue-500 pl-3">
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-300 font-semibold">A. Trend Regime (0-${breakdown.weightsUsed ? breakdown.weightsUsed.rawWeights.A : 30}):</span>
                                            <span class="text-white font-mono font-bold">${breakdown.trendRegime.score.toFixed(1)}/${breakdown.trendRegime.maxScore.toFixed(1)}</span>
                                        </div>
                                        <div class="text-gray-400 text-xs mt-1 pl-0">${breakdown.trendRegime.description}</div>
                                    </div>
                                    
                                    <div class="border-l-2 border-blue-500 pl-3">
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-300 font-semibold">B. Signal Position (0-${breakdown.weightsUsed ? breakdown.weightsUsed.rawWeights.B : 30}):</span>
                                            <span class="text-white font-mono font-bold">${breakdown.signalPosition.score.toFixed(1)}/${breakdown.signalPosition.maxScore.toFixed(1)}</span>
                                        </div>
                                        <div class="text-gray-400 text-xs mt-1 pl-0">${breakdown.signalPosition.description}</div>
                                    </div>
                                    
                                    <div class="border-l-2 border-blue-500 pl-3">
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-300 font-semibold">C. Histogram Expansion (0-${breakdown.weightsUsed ? breakdown.weightsUsed.rawWeights.C : 25}):</span>
                                            <span class="text-white font-mono font-bold">${breakdown.histogramExpansion.score.toFixed(1)}/${breakdown.histogramExpansion.maxScore.toFixed(1)}</span>
                                        </div>
                                        <div class="text-gray-400 text-xs mt-1 pl-0">${breakdown.histogramExpansion.description}</div>
                                    </div>
                                    
                                    <div class="border-l-2 border-blue-500 pl-3">
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-300 font-semibold">D. Cross Quality (0-${breakdown.weightsUsed ? breakdown.weightsUsed.rawWeights.D : 15}):</span>
                                            <span class="text-white font-mono font-bold">${breakdown.crossQuality.score.toFixed(1)}/${breakdown.crossQuality.maxScore.toFixed(1)}</span>
                                        </div>
                                        <div class="text-gray-400 text-xs mt-1 pl-0">${breakdown.crossQuality.description}</div>
                                    </div>
                                    
                                    <div class="border-t border-gray-600 mt-3 pt-3 flex justify-between items-center">
                                        <span class="text-blue-400 font-semibold">Total Raw Score:</span>
                                        <span class="text-white font-mono font-bold">${breakdown.totalRawScore.toFixed(1)}/100</span>
                                    </div>
                                    <div class="text-gray-400 text-xs mt-1">Normalized: ${(breakdown.normalizedScore > 0 ? '+' : '') + breakdown.normalizedScore.toFixed(3)}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                row.innerHTML = `
                    <td class="px-4 py-2 text-white font-semibold whitespace-nowrap">${item.name}</td>
                    <td class="px-4 py-2 text-gray-300 whitespace-nowrap">${item.val}</td>
                    <td class="px-4 py-2 ${scoreColor}">${item.interp}</td>
                    <td class="px-2 py-2 text-center font-mono ${scoreColor} font-semibold">${scoreCellContent}</td>
                    <td class="px-2 py-2 text-center text-gray-400">${(item.weight * 100).toFixed(1)}%</td>
                    <td class="px-2 py-2 text-right ${contributionClass}">${contribText}</td>
                    ${showRidgeReference ? `<td class="px-2 py-2 text-right text-gray-500" style="font-size: 0.9em;">${ridgeWeightDisplay}</td>` : ''}
                `;
                breakdownTableBody.appendChild(row);
            });

            const footerScorePct = totalScore * 100;
            document.getElementById('footerTotalScore').innerText = (footerScorePct > 0 ? "+" : "") + footerScorePct.toFixed(0) + "%";
            
            // Update footer colspan based on whether Ridge (Ref) column is shown
            const footerRow = document.querySelector('#breakdownTable tfoot tr');
            if (footerRow) {
                const footerColspan = showRidgeReference ? 6 : 6; // Keep colspan at 6 (spanning first 6 columns), Ridge (Ref) is column 7
                const footerTd = footerRow.querySelector('td:first-child');
                if (footerTd) footerTd.setAttribute('colspan', footerColspan.toString());
            }

            // Render category analysis
            renderCategoryAnalysis(scores);

            resultsArea.classList.remove('hidden');
        }

        function renderCategoryAnalysis(scores) {
            const categoryAnalysisCard = document.getElementById('categoryAnalysisCard');
            categoryAnalysisCard.innerHTML = '';

            // Define category mappings
            const categoryIndicators = {
                'Trend': ['MACD (Monthly)', 'MACD (Daily)'],
                'Mean-Reversion': ['RSI (Daily)', 'Bollinger Bands', '50-DMA Z-Score'],
                'Trend-Following': ['ADX/DI (Daily)', 'Price vs. 200-DMA (Dist)']
            };

            const categoryDescriptions = {
                'Trend': {
                    description: 'Identifies the direction and momentum of market trends through MACD analysis across multiple timeframes.',
                    icon: 'fas fa-chart-line'
                },
                'Mean-Reversion': {
                    description: 'Detects when prices deviate from historical norms, identifying oversold and overbought conditions.',
                    icon: 'fas fa-exchange-alt'
                },
                'Trend-Following': {
                    description: 'Confirms and follows existing trends, measuring trend strength and price position relative to moving averages.',
                    icon: 'fas fa-route'
                }
            };

            // Calculate category metrics
            Object.keys(categoryIndicators).forEach(categoryName => {
                const indicators = categoryIndicators[categoryName];
                const categoryScores = scores.filter(s => indicators.includes(s.name));
                
                // Calculate total weighted contribution for the category (what actually impacts the final signal)
                let totalContribution = 0;
                let categoryContributions = [];

                categoryScores.forEach(item => {
                    const contribution = item.score * item.weight;
                    totalContribution += contribution;
                    categoryContributions.push({
                        name: item.name,
                        score: item.score,
                        contribution: contribution,
                        interpretation: item.interp
                    });
                });

                // Use total weighted contribution for category characterization (aligned with how final signal is calculated)
                const categoryScore = totalContribution;

                // Generate descriptive text based on category score
                // Use different language for Mean-Reversion (consolidation focus) vs others (momentum focus)
                const isMeanReversion = categoryName === 'Mean-Reversion';
                const isTrend = categoryName === 'Trend';
                
                // For Trend category, analyze MACD agreement/conflict
                // Note: Monthly MACD score now directly reflects histogram direction (positive histogram = positive score, negative histogram = negative score)
                let monthlyMACD = null;
                let dailyMACD = null;
                let macdAgreement = null; // true = agreement, false = conflict
                
                if (isTrend) {
                    categoryScores.forEach(item => {
                        if (item.name === 'MACD (Monthly)') monthlyMACD = item.score;
                        if (item.name === 'MACD (Daily)') dailyMACD = item.score;
                    });
                    
                    if (monthlyMACD !== null && dailyMACD !== null) {
                        // Agreement: both positive (both bullish) or both negative (both bearish)
                        // Monthly MACD score sign directly matches histogram direction, so agreement means both pointing same direction
                        macdAgreement = (monthlyMACD >= 0 && dailyMACD >= 0) || (monthlyMACD <= 0 && dailyMACD <= 0);
                    }
                }
                
                let intensity = 'Moderate';
                let direction = 'Neutral';
                let description = '';
                let colorClass = 'text-gray-400';
                let bgClass = 'bg-gray-900/50';
                let borderClass = 'border-gray-700';

                // Thresholds adjusted for weighted contributions (typically smaller than raw scores)
                // Strong signals: > 0.10 (category contributing significantly to final signal)
                // Moderate signals: > 0.03 (meaningful contribution)
                // Neutral: -0.03 to 0.03 (minimal contribution)
                if (categoryScore > 0.10) {
                    intensity = 'Strong';
                    direction = 'Bullish';
                    colorClass = 'text-green-400';
                    bgClass = 'bg-green-900/20';
                    borderClass = 'border-green-700/50';
                    if (isMeanReversion) {
                        description = 'This category indicates strong oversold conditions with potential for price recovery. The indicators suggest prices have deviated significantly below historical norms, creating favorable conditions for consolidation or upward reversion. Market positioning appears stretched, which may lead to a normalization of price action.';
                    } else if (isTrend && monthlyMACD !== null && dailyMACD !== null) {
                        if (macdAgreement) {
                            description = `The major trend (Monthly MACD: ${monthlyMACD >= 0 ? '+' : ''}${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are in agreement, indicating a strong bullish trend. Both timeframes are confirming upward momentum, suggesting sustained directional strength.`;
                        } else {
                            description = `The major trend (Monthly MACD: ${monthlyMACD >= 0 ? '+' : ''}${monthlyMACD.toFixed(2)}) is bullish, but the minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) shows conflict. While the longer-term trend remains positive, the minor trend may be signaling potential trend weakness or a short-term pause in momentum.`;
                        }
                    } else {
                        description = 'This category is exhibiting robust bullish characteristics. The underlying indicators are aligning to suggest sustained upward momentum, with multiple signals confirming a positive directional bias. Market participants appear to be demonstrating conviction in the current trend direction.';
                    }
                } else if (categoryScore > 0.03) {
                    intensity = 'Moderate';
                    direction = 'Bullish';
                    colorClass = 'text-teal-400';
                    bgClass = 'bg-teal-900/20';
                    borderClass = 'border-teal-700/50';
                    if (isMeanReversion) {
                        description = 'This category shows moderate oversold conditions with a tendency toward consolidation. The indicators suggest prices are below typical ranges, which may support price stabilization or gradual reversion. Current readings point toward potential consolidation as markets work toward equilibrium.';
                    } else if (isTrend && monthlyMACD !== null && dailyMACD !== null) {
                        if (macdAgreement) {
                            // Both are bullish (positive scores)
                            description = `The major trend (Monthly MACD histogram: positive, score: ${monthlyMACD >= 0 ? '+' : ''}${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are in agreement, suggesting a moderate bullish trend. Both timeframes are confirming positive momentum, though not at extreme levels.`;
                        } else {
                            // Monthly is bullish but daily shows conflict
                            description = `The major trend (Monthly MACD histogram: positive, score: ${monthlyMACD >= 0 ? '+' : ''}${monthlyMACD.toFixed(2)}) remains bullish, but the minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) shows conflict. The minor trend may be signaling some trend weakness or a near-term divergence from the longer-term positive direction.`;
                        }
                    } else {
                        description = 'This category displays constructive bullish tendencies. The signals are favorable but not yet at extremes, suggesting a measured but positive outlook. The indicators point toward continued strength with room for further development.';
                    }
                } else if (categoryScore > -0.03) {
                    intensity = 'Neutral';
                    direction = 'Neutral';
                    colorClass = 'text-gray-400';
                    bgClass = 'bg-gray-900/50';
                    borderClass = 'border-gray-700';
                    if (isMeanReversion) {
                        description = 'This category reflects a balanced state near historical norms, indicating consolidation patterns are likely. The indicators show prices are neither significantly extended nor compressed, suggesting the market is in a stable equilibrium phase. Current conditions favor continued consolidation rather than directional moves.';
                    } else if (isTrend && monthlyMACD !== null && dailyMACD !== null) {
                        if (macdAgreement) {
                            // Both near neutral
                            description = `The major trend (Monthly MACD histogram: near zero, score: ${monthlyMACD >= 0 ? '+' : ''}${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are both near neutral, indicating an unclear trend environment. Both timeframes suggest a balanced state with minimal directional bias.`;
                        } else {
                            // Monthly and daily are in conflict
                            const monthlyDirection = monthlyMACD >= 0 ? 'positive' : 'negative';
                            description = `The major trend (Monthly MACD histogram: ${monthlyDirection}, score: ${monthlyMACD >= 0 ? '+' : ''}${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are in conflict, with opposing signals. The minor trend is signaling potential trend weakness relative to the major trend, suggesting uncertainty in the current directional environment.`;
                        }
                    } else {
                        description = 'This category is in a balanced state, with conflicting signals creating a neutral reading. The indicators are not providing a clear directional bias, suggesting the market is in a transitional phase or consolidating. Current conditions warrant monitoring for emerging directional clarity.';
                    }
                } else if (categoryScore > -0.10) {
                    intensity = 'Moderate';
                    direction = 'Bearish';
                    colorClass = 'text-orange-400';
                    bgClass = 'bg-orange-900/20';
                    borderClass = 'border-orange-700/50';
                    if (isMeanReversion) {
                        description = 'This category indicates moderate overbought conditions with potential for consolidation or pullback. The indicators suggest prices have moved above typical ranges, which may lead to price stabilization or reversion. Current readings point toward consolidation as markets work toward more normalized levels.';
                    } else if (isTrend && monthlyMACD !== null && dailyMACD !== null) {
                        const monthlyDirection = monthlyMACD >= 0 ? 'positive' : 'negative';
                        if (macdAgreement) {
                            // Both pointing same direction
                            if (monthlyMACD >= 0) {
                                description = `The major trend (Monthly MACD histogram: positive, score: +${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are in agreement, but the category contribution suggests moderate weakness. The monthly histogram remains positive, indicating the longer-term trend is still bullish, though momentum may be moderating.`;
                            } else {
                                description = `The major trend (Monthly MACD histogram: negative, score: ${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are in agreement, suggesting a moderate bearish trend. Both timeframes are confirming negative momentum, though not at extreme levels.`;
                            }
                        } else {
                            // Monthly and daily are in conflict
                            if (monthlyMACD >= 0) {
                                description = `The major trend (Monthly MACD histogram: positive, score: +${monthlyMACD.toFixed(2)}) remains bullish, but the minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) shows conflict. While the longer-term monthly histogram confirms positive momentum, the daily MACD divergence is pulling the category score into bearish territory, suggesting potential trend weakness or a short-term pause.`;
                            } else {
                                description = `The major trend (Monthly MACD histogram: negative, score: ${monthlyMACD.toFixed(2)}) remains bearish, but the minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) shows conflict. The minor trend may be signaling some trend weakness or a near-term divergence from the longer-term negative direction.`;
                            }
                        }
                    } else {
                        description = 'This category is showing bearish inclinations with moderate conviction. The indicators are pointing toward potential weakness, though the signals are not yet at extreme levels. Caution is warranted as negative momentum may be building.';
                    }
                } else {
                    intensity = 'Strong';
                    direction = 'Bearish';
                    colorClass = 'text-red-400';
                    bgClass = 'bg-red-900/20';
                    borderClass = 'border-red-700/50';
                    if (isMeanReversion) {
                        description = 'This category signals strong overbought conditions with potential for significant consolidation or downward reversion. The indicators suggest prices have deviated substantially above historical norms, creating conditions favorable for price normalization. Market positioning appears stretched, which may lead to consolidation or reversion to mean levels.';
                    } else if (isTrend && monthlyMACD !== null && dailyMACD !== null) {
                        const monthlyDirection = monthlyMACD >= 0 ? 'positive' : 'negative';
                        if (macdAgreement) {
                            // Both pointing same direction
                            if (monthlyMACD >= 0) {
                                description = `The major trend (Monthly MACD histogram: positive, score: +${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are in agreement, but the category contribution suggests significant weakness. The monthly histogram remains positive, indicating the longer-term trend is still bullish, though the daily MACD weakness is creating a strong bearish category contribution.`;
                            } else {
                                description = `The major trend (Monthly MACD histogram: negative, score: ${monthlyMACD.toFixed(2)}) and minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) are in agreement, indicating a strong bearish trend. Both timeframes are confirming downward momentum, with monthly histogram negative and daily MACD supportive, suggesting sustained directional weakness.`;
                            }
                        } else {
                            // Monthly and daily are in conflict
                            if (monthlyMACD >= 0) {
                                description = `The major trend (Monthly MACD histogram: positive, score: +${monthlyMACD.toFixed(2)}) remains bullish, but the minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) shows strong conflict. While the longer-term monthly histogram confirms positive momentum, the daily MACD divergence is creating a strong bearish category reading, suggesting significant potential trend weakness or a major short-term pause.`;
                            } else {
                                description = `The major trend (Monthly MACD histogram: negative, score: ${monthlyMACD.toFixed(2)}) remains bearish, but the minor trend (Daily MACD: ${dailyMACD >= 0 ? '+' : ''}${dailyMACD.toFixed(2)}) shows conflict. While the longer-term monthly histogram confirms negative momentum, the daily MACD divergence may signal potential trend weakness or a short-term pause.`;
                            }
                        }
                    } else {
                        description = 'This category is signaling strong bearish dynamics. Multiple indicators are converging to suggest significant downward pressure, with signals pointing toward sustained negative momentum. Market participants appear to be positioning defensively.';
                    }
                }

                const categoryCard = document.createElement('div');
                categoryCard.className = `border ${borderClass} rounded-lg p-4 ${bgClass} transition-all hover:shadow-lg`;
                categoryCard.innerHTML = `
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center">
                            <i class="${categoryDescriptions[categoryName].icon} ${colorClass} text-xl mr-3"></i>
                            <h4 class="font-bold text-white text-base">${categoryName}</h4>
                        </div>
                        <div class="text-right" style="min-width: 100px;">
                            <div class="text-sm font-mono ${colorClass} font-bold" style="text-align: right; letter-spacing: 0.05em;">
                                ${(categoryScore >= 0 ? '+' : '') + categoryScore.toFixed(2)}
                            </div>
                            <div class="text-xs text-gray-500 mt-0.5" style="text-align: right;">${intensity} ${direction}</div>
                            <div class="text-xs text-gray-600 mt-0.5" style="text-align: right;">Total Contribution</div>
                        </div>
                    </div>
                    <p class="text-xs text-gray-300 leading-relaxed mb-3">${categoryDescriptions[categoryName].description}</p>
                    <p class="text-xs text-gray-400 italic leading-relaxed mb-3">${description}</p>
                    <div class="border-t ${borderClass} pt-3 mt-3">
                        <div class="text-xs text-gray-500 mb-2">Indicator Breakdown:</div>
                        <div class="space-y-1.5">
                            ${categoryContributions.map(item => {
                                const itemColor = item.score > 0 ? 'text-green-400' : item.score < 0 ? 'text-red-400' : 'text-gray-400';
                                return `
                                    <div class="flex justify-between items-start text-xs">
                                        <span class="text-gray-300 flex-1">${item.name}:</span>
                                        <span class="text-gray-400 ml-2 text-right flex-shrink-0">
                                            <span class="font-mono ${itemColor}">${(item.score > 0 ? '+' : '') + item.score.toFixed(2)}</span>
                                            <span class="text-gray-500 ml-1">(${(item.contribution > 0 ? '+' : '') + (item.contribution * 100).toFixed(1)}%)</span>
                                        </span>
                                    </div>
                                    <div class="text-xs text-gray-500 italic ml-2 mb-1">${item.interpretation}</div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
                categoryAnalysisCard.appendChild(categoryCard);
            });
        }


        // Scroll to top immediately when page loads
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
        
        window.onload = function() {
            // Scroll to top when app opens (redundant but ensures it happens)
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            // Initialize tabs - show Quantum tab by default
            switchTab('quantum');
            
            const tickerInput = document.getElementById('tickerInput');
            if (tickerInput.value === '') {
                tickerInput.value = 'AAPL';
            }
            
            // Select all text when input is focused/clicked so it can be typed over
            if (tickerInput) {
                // Select all on mousedown (before focus) to ensure text is selected
                tickerInput.addEventListener('mousedown', function(e) {
                    if (document.activeElement !== e.target) {
                        e.preventDefault();
                        e.target.focus();
                        e.target.select();
                    }
                });
                
                // Select all on focus
                tickerInput.addEventListener('focus', function(e) {
                    e.target.select();
                });
                
                // Also select all on click (in case focus doesn't trigger)
                tickerInput.addEventListener('click', function(e) {
                    e.target.select();
                });
                
                // Convert input to uppercase as user types
                tickerInput.addEventListener('input', function(e) {
                    const cursorPosition = e.target.selectionStart;
                    e.target.value = e.target.value.toUpperCase();
                    // Restore cursor position after converting to uppercase
                    e.target.setSelectionRange(cursorPosition, cursorPosition);
                });
                
                // Also convert on paste
                tickerInput.addEventListener('paste', function(e) {
                    setTimeout(() => {
                        const cursorPosition = e.target.selectionStart;
                        e.target.value = e.target.value.toUpperCase();
                        e.target.setSelectionRange(cursorPosition, cursorPosition);
                    }, 0);
                });
            }
            
            // Handle lookahead button clicks
            const lookaheadButtons = document.querySelectorAll('.lookahead-btn');
            
            // Ensure 30 days is the default active button
            const defaultButton = document.querySelector('.lookahead-btn[data-value="30"]');
            if (defaultButton && !defaultButton.classList.contains('active')) {
                // Remove active from all buttons
                lookaheadButtons.forEach(b => {
                    b.classList.remove('active', 'bg-blue-600', 'border-blue-500', 'text-white');
                    b.classList.add('bg-gray-800', 'border-gray-600', 'text-gray-300');
                });
                // Set 30 days as active
                defaultButton.classList.add('active', 'bg-blue-600', 'border-blue-500', 'text-white');
                defaultButton.classList.remove('bg-gray-800', 'border-gray-600', 'text-gray-300');
            }
            
            lookaheadButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    lookaheadButtons.forEach(b => {
                        b.classList.remove('active', 'bg-blue-600', 'border-blue-500', 'text-white');
                        b.classList.add('bg-gray-800', 'border-gray-600', 'text-gray-300');
                    });
                    // Add active class to clicked button
                    this.classList.add('active', 'bg-blue-600', 'border-blue-500', 'text-white');
                    this.classList.remove('bg-gray-800', 'border-gray-600', 'text-gray-300');
                });
            });
        };
        
        // Add event listeners for 24-month zoom buttons on interest rates charts
        function setupInterestRatesZoomButtons() {
            const zoomButtons = [
                { 
                    id: 'termPremiumZoom24', 
                    get: () => termPremiumZoom24, 
                    set: (v) => termPremiumZoom24 = v, 
                    process: () => {
                        const data = termPremiumFullData;
                        if (data) processTermPremium(data.map(d => ({ date: d.date, value: d.tp2Y })), data.map(d => ({ date: d.date, value: d.tp10Y })));
                    }
                },
                { 
                    id: 'forwardPremiumZoom24', 
                    get: () => forwardPremiumZoom24, 
                    set: (v) => forwardPremiumZoom24 = v, 
                    process: () => {
                        const data = forwardPremiumFullData;
                        if (data) processForwardTermPremium(data.map(d => ({ date: d.date, value: d.fp5Y })), data.map(d => ({ date: d.date, value: d.fp10Y })));
                    }
                },
                { 
                    id: 'termPremiumComparisonZoom24', 
                    get: () => termPremiumComparisonZoom24, 
                    set: (v) => termPremiumComparisonZoom24 = v, 
                    process: () => {
                        const data = termPremiumComparisonFullData;
                        if (data) {
                            // Extract the original data format
                            const termPremium10YData = data.map(d => ({ date: d.date, value: d.tp10Y }));
                            const forwardPremium10YData = data.map(d => ({ date: d.date, value: d.fp10Y }));
                            processTermPremiumComparison(termPremium10YData, forwardPremium10YData);
                        }
                    }
                },
                { 
                    id: 'yieldDecompZoom24', 
                    get: () => yieldDecompZoom24, 
                    set: (v) => yieldDecompZoom24 = v, 
                    process: () => {
                        const data = yieldDecompFullData;
                        if (data && data.length > 0) {
                            const gs10Data = data.map(d => ({ date: d.date, value: d.yield }));
                            const realYield10YData = data.map(d => ({ date: d.date, value: d.realRate }));
                            const termPremium10YData = data.map(d => ({ date: d.date, value: d.termPremium }));
                            processYieldDecomposition(gs10Data, realYield10YData, termPremium10YData);
                        }
                    }
                },
                { 
                    id: 'inflationChartZoom24', 
                    get: () => inflationChartZoom24, 
                    set: (v) => inflationChartZoom24 = v, 
                    process: () => {
                        const data = inflationChartFullData;
                        if (data) processInflationExpectations(data.map(d => ({ date: d.date, value: d.inf10Y })), data.map(d => ({ date: d.date, value: d.inf5Y5Y })));
                    }
                },
                { 
                    id: 'realYieldZoom24', 
                    get: () => realYieldZoom24, 
                    set: (v) => realYieldZoom24 = v, 
                    process: () => {
                        if (realYieldFullData) processRealYields(realYieldFullData, yield10YFullData);
                    }
                },
                { 
                    id: 'dotPlotZoom24', 
                    get: () => dotPlotZoom24, 
                    set: (v) => dotPlotZoom24 = v, 
                    process: () => {
                        if (rawYield2YData) processDotPlotComparison(rawYield2YData, rawFedFundsData, rawDotPlotMedianData);
                    }
                },
                { 
                    id: 'inflationCpiPceZoom24', 
                    get: () => inflationCpiPceZoom24, 
                    set: (v) => inflationCpiPceZoom24 = v, 
                    process: () => {
                        if (rawCpiOverallData) processInflationCpiPce(
                            rawCpiOverallData || [], rawCpiCoreData || [], rawPceOverallData || [], rawPceCoreData || [],
                            rawCpiShelterData || [], rawCpiFoodData || [], rawCpiEnergyData || [], rawCpiTransportData || [],
                            rawCpiMedicalData || [], rawCpiEducationData || [], rawCpiApparelData || [], rawCpiRecreationData || [], rawCpiOtherData || [],
                            rawDallasTrimmedData || []
                        );
                    }
                }
            ];

            zoomButtons.forEach(btnConfig => {
                const btn = document.getElementById(btnConfig.id);
                if (btn) {
                    // Update initial button state based on flag
                    const isZoomed = btnConfig.get();
                    btn.textContent = isZoomed ? 'Show Full' : 'Zoom 2Y';
                    if (isZoomed) {
                        btn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                        btn.classList.remove('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                    } else {
                        btn.classList.add('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                        btn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                    }

                    // Add listener if not already added
                    if (!btn.hasAttribute('data-listener-added')) {
                        btn.setAttribute('data-listener-added', 'true');
                        btn.addEventListener('click', function() {
                            // Toggle flag
                            const newState = !btnConfig.get();
                            btnConfig.set(newState);
                            
                            // Update UI
                            this.textContent = newState ? 'Show Full' : 'Zoom 2Y';
                            if (newState) {
                                this.classList.add('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                                this.classList.remove('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                            } else {
                                this.classList.add('bg-gray-700', 'hover:bg-gray-600', 'text-gray-300', 'border-gray-600');
                                this.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'text-white', 'border-blue-500');
                            }

                            // Re-process with cached data
                            btnConfig.process();
                        });
                    }
                }
            });
        }

        // Setup zoom buttons when interest rates tab is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setupInterestRatesZoomButtons();
                // Initialize footer description for default tab
                updateFooterDescription('quantum');
            });
        } else {
            setupInterestRatesZoomButtons();
            updateFooterDescription('quantum');
        }
        
        // Also setup when switching to interest rates tab
        if (window.switchTab) {
            const originalSwitchTab = window.switchTab;
            window.switchTab = function(tabName) {
                originalSwitchTab(tabName);
                if (tabName === 'interest') {
                    setTimeout(setupInterestRatesZoomButtons, 100);
                }
            };
        }

    </script>

    <footer class="mt-12 max-w-7xl mx-auto p-4 md:p-10">
        <div id="footerDescription" class="bg-gray-800 rounded-xl shadow-2xl p-6 border border-gray-700/50">
                <h3 class="text-blue-400 text-lg font-semibold mb-4">Multi-Timeframe Dynamic Weight Calibration</h3>
            <p class="text-gray-100 text-xs leading-relaxed">
                <span class="text-gray-100 text-xs">This system uses <strong class="text-cyan-400 text-xs">machine learning</strong> to determine optimal indicator weights by analyzing historical relationships between technical indicators and future price returns. The system evaluates seven indicators (MACD Monthly, MACD Daily, RSI, ADX/DI, Bollinger Bands, Price vs. 200-DMA Distance, and 50-DMA Z-Score) using a user-selected forecast horizon (10, 30, 60, or 90 days).</span>
                <br><br>
                <strong class="text-white text-xs">Model Training Process:</strong>
                <span class="text-gray-100 text-xs">For each historical day, the system collects raw indicator scores (normalized to -1 to +1 range) and the corresponding forward return for the user-selected forecast horizon (10, 30, 60, or 90 days). A machine learning model is trained to predict forward returns from these indicator scores, learning which indicators are most predictive for that specific time horizon. The model is trained specifically on the selected forecast horizon to optimize performance for the user's chosen investment timeframe.</span>
                <br><br>
                <strong class="text-white text-xs">Available Machine Learning Models:</strong>
                <ul class="list-disc list-inside mt-2 mb-2 space-y-1 text-xs ml-2">
                    <li class="text-gray-100 text-xs"><strong class="text-blue-400 text-xs">Ridge Regression</strong> <span class="text-gray-300 text-xs">(default, faster)</span>: A linear model with L2 regularization that prevents overfitting while maintaining computational efficiency. Extracts weights from model coefficients (absolute values, normalized to sum to 1).</li>
                    <li class="text-gray-100 text-xs"><strong class="text-green-400 text-xs">Gradient Boosting</strong> <span class="text-gray-300 text-xs">(when enabled)</span>: An ensemble of decision trees that captures complex, non-linear relationships. Uses data-driven feature importance with correlation and variance weighting (60% correlation, 40% normalized variance). Weights are determined by predictive power.</li>
                    <li class="text-gray-100 text-xs"><strong class="text-purple-400 text-xs">Elastic Net</strong> <span class="text-gray-300 text-xs">(when enabled)</span>: A linear model combining L1 (Lasso) and L2 (Ridge) regularization, providing a balance between feature selection and coefficient shrinkage. Useful when dealing with correlated indicators.</li>
                    <li class="text-gray-100 text-xs"><strong class="text-yellow-400 text-xs">Regime Switching</strong> <span class="text-gray-300 text-xs">(when enabled)</span>: An ensemble approach that trains separate models for different market regimes (Strong Trend, Weak Trend, Ranging, Transition). The system automatically detects the current regime and uses the appropriate model, with a fallback model for uncertain periods.</li>
                </ul>
                <br>
                <strong class="text-white text-xs">Equal Category Weighting (Optional):</strong>
                <span class="text-gray-100 text-xs">When the "Equal Category Weighting" option is enabled, the system forces equal total weight distribution across three indicator categories: <strong class="text-cyan-400 text-xs">Trend</strong> (MACD Monthly, MACD Daily), <strong class="text-cyan-400 text-xs">Mean-Reversion</strong> (RSI, Bollinger Bands, 50-DMA Z-Score), and <strong class="text-cyan-400 text-xs">Trend-Following</strong> (ADX/DI, Price vs. 200-DMA). Each category receives 1/3 of total weight, distributed proportionally among its indicators based on their relative importance. When disabled, weights are determined purely by predictive power without category constraints.</span>
                <br><br>
                <span class="text-xs"><strong class="text-white text-xs">Weight Extraction and Capping:</strong> <span class="text-gray-100 text-xs">Weights are extracted from the trained model (coefficients for Ridge/Elastic Net, feature importance for Gradient Boosting, consensus weights for Regime Switching). All indicator weights are then capped at 25% maximum (10% for Price vs. 200-DMA) to prevent any single indicator from dominating the signal. This ensures balanced signal generation across all indicators.</span></span>
                <br><br>
                <strong class="text-white text-xs">Category Analysis:</strong>
                <span class="text-gray-100 text-xs">The Category Analysis section displays the total weighted contribution (raw score × weight) for each indicator category, showing what's actually driving the final signal score. This is calculated the same way as the final signal (sum of weighted contributions), making it directly aligned with the model's output. The analysis includes detailed interpretations that account for category-specific characteristics, such as MACD agreement/conflict analysis for the Trend category. Individual indicator breakdowns show both raw scores and their weighted contributions for full transparency.</span>
                <br><br>
                <span class="text-xs"><strong class="text-white text-xs">Walk-Forward Validation:</strong> <span class="text-gray-100 text-xs">Validation uses</span> <strong class="text-red-400 text-xs">walk-forward testing</strong><span class="text-gray-100 text-xs">, ensuring the model generalizes beyond the training data and provides realistic performance metrics including hit rates, Sharpe ratios, and win/loss ratios. This method trains the model on historical data and tests it on future unseen data, simulating real-world trading conditions. When Ridge Regression is the primary model, a reference Ridge Regression validation is also provided for comparison.</span></span>
            </p>
        </div>
    </footer>
</body>
</html>
</html>